/* ------------------------------------------------------------------------------
The MIT License

Copyright (c) LibGit2Sharp contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------ */

//#define LEAKS_IDENTIFYING
//#define LEAKS_TRACKING

namespace LibGit2Sharp
{
    using LibGit2Sharp.Core.Handles;
    using LibGit2Sharp.Core;
    using LibGit2Sharp.Handlers;
    using LibGit2Sharp;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Security.Cryptography.X509Certificates;
    using System.Security;
    using System.Text.RegularExpressions;
    using System.Text;
    using System;

    /// <summary>
    /// Information about a rebase step that was just completed.
    /// </summary>
    public class AfterRebaseStepInfo
    {
        /// <summary>
        /// Needed for mocking.
        /// </summary>
        protected AfterRebaseStepInfo()
        { }

        internal AfterRebaseStepInfo(RebaseStepInfo stepInfo, Commit commit, long completedStepIndex, long totalStepCount)
        {
            StepInfo = stepInfo;
            Commit = commit;
            WasPatchAlreadyApplied = false;
            CompletedStepIndex = completedStepIndex;
            TotalStepCount = totalStepCount;
        }

        /// <summary>
        /// Constructor to call when the patch has already been applied for this step.
        /// </summary>
        /// <param name="stepInfo"></param>
        /// <param name="completedStepIndex"/>
        /// <param name="totalStepCount"></param>
        internal AfterRebaseStepInfo(RebaseStepInfo stepInfo, long completedStepIndex, long totalStepCount)
            : this (stepInfo, null, completedStepIndex, totalStepCount)
        {
            WasPatchAlreadyApplied = true;
        }

        /// <summary>
        /// The info on the completed step.
        /// </summary>
        public virtual RebaseStepInfo StepInfo { get; private set; }

        /// <summary>
        /// The commit generated by the step, if any.
        /// </summary>
        public virtual Commit Commit { get; private set; }

        /// <summary>
        /// Was the changes for this step already applied. If so,
        /// <see cref="AfterRebaseStepInfo.Commit"/> will be null.
        /// </summary>
        public virtual bool WasPatchAlreadyApplied { get; private set; }

        /// <summary>
        /// The index of the step that was just completed.
        /// </summary>
        public virtual long CompletedStepIndex { get; private set; }

        /// <summary>
        /// The total number of steps in the rebase operation.
        /// </summary>
        public virtual long TotalStepCount { get; private set; }
    }

    /// <summary>
    /// The exception that is thrown when the provided specification cannot uniquely identify a reference, an object or a path.
    /// </summary>
    [Serializable]
    public class AmbiguousSpecificationException : NativeException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AmbiguousSpecificationException"/> class.
        /// </summary>
        public AmbiguousSpecificationException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="AmbiguousSpecificationException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public AmbiguousSpecificationException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="AmbiguousSpecificationException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public AmbiguousSpecificationException(string format, params object[] args)
            : base(String.Format(format, args))
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AmbiguousSpecificationException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public AmbiguousSpecificationException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="AmbiguousSpecificationException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected AmbiguousSpecificationException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal override GitErrorCode ErrorCode
        {
            get
            {
                return GitErrorCode.Ambiguous;
            }
        }
    }

    /// <summary>
    /// The exception that is thrown when an operation which requires a
    /// working directory is performed against a bare repository.
    /// </summary>
    [Serializable]
    public class BareRepositoryException : NativeException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.BareRepositoryException"/> class.
        /// </summary>
        public BareRepositoryException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.BareRepositoryException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public BareRepositoryException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.BareRepositoryException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public BareRepositoryException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.BareRepositoryException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public BareRepositoryException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.BareRepositoryException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected BareRepositoryException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal BareRepositoryException(string message, GitErrorCategory category)
            : base(message, category)
        { }

        internal override GitErrorCode ErrorCode
        {
            get
            {
                return GitErrorCode.BareRepo;
            }
        }
    }

    /// <summary>
    /// Information about a rebase step that is about to be performed.
    /// </summary>
    public class BeforeRebaseStepInfo
    {
        /// <summary>
        /// Needed for mocking.
        /// </summary>
        protected BeforeRebaseStepInfo()
        { }

        internal BeforeRebaseStepInfo(RebaseStepInfo stepInfo, long stepIndex, long totalStepCount)
        {
            StepInfo = stepInfo;
            StepIndex = stepIndex;
            TotalStepCount = totalStepCount;
        }

        /// <summary>
        /// Information on the step that is about to be performed.
        /// </summary>
        public virtual RebaseStepInfo StepInfo { get; private set; }

        /// <summary>
        /// The index of the step that is to be run.
        /// </summary>
        public virtual long StepIndex { get; private set; }

        /// <summary>
        /// The total number of steps in the rebase operation.
        /// </summary>
        public virtual long TotalStepCount { get; private set; }
    }

    /// <summary>
    /// A contiguous group of lines that have been traced to a single commit.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class BlameHunk : IEquatable<BlameHunk>
    {
        private static readonly LambdaEqualityHelper<BlameHunk> equalityHelper =
            new LambdaEqualityHelper<BlameHunk>(x => x.LineCount,
                                                x => x.FinalStartLineNumber,
                                                x => x.FinalSignature,
                                                x => x.InitialStartLineNumber,
                                                x => x.InitialSignature,
                                                x => x.InitialCommit);

        internal unsafe BlameHunk(IRepository repository, git_blame_hunk* rawHunk)
        {
            var origId = ObjectId.BuildFromPtr(&rawHunk->orig_commit_id);
            var finalId = ObjectId.BuildFromPtr(&rawHunk->final_commit_id);

            finalCommit = new Lazy<Commit>(() => repository.Lookup<Commit>(finalId));
            origCommit = new Lazy<Commit>(() => repository.Lookup<Commit>(origId));

            if (rawHunk->orig_path != null)
            {
                InitialPath = LaxUtf8Marshaler.FromNative(rawHunk->orig_path);
            }

            LineCount = (int)rawHunk->lines_in_hunk.ToUInt32();

            // Libgit2's line numbers are 1-based
            FinalStartLineNumber = (int)rawHunk->final_start_line_number.ToUInt32() - 1;
            InitialStartLineNumber = (int)rawHunk->orig_start_line_number.ToUInt32() - 1;

            // Signature objects need to have ownership of their native pointers
            if (rawHunk->final_signature != null)
            {
                FinalSignature = new Signature(rawHunk->final_signature);
            }

            if (rawHunk->orig_signature != null)
            {
                InitialSignature = new Signature(rawHunk->orig_signature);
            }
        }

        /// <summary>
        /// For easier mocking
        /// </summary>
        protected BlameHunk()
        { }

        /// <summary>
        /// Determine if this hunk contains a given line.
        /// </summary>
        /// <param name="line">Line number to test</param>
        /// <returns>True if this hunk contains the given line.</returns>
        public virtual bool ContainsLine(int line)
        {
            return FinalStartLineNumber <= line && line < FinalStartLineNumber + LineCount;
        }

        /// <summary>
        /// Number of lines in this hunk.
        /// </summary>
        public virtual int LineCount { get; private set; }

        /// <summary>
        /// The line number where this hunk begins, as of <see cref="FinalCommit"/>
        /// </summary>
        public virtual int FinalStartLineNumber { get; private set; }

        /// <summary>
        /// Signature of the most recent change to this hunk.
        /// </summary>
        public virtual Signature FinalSignature { get; private set; }

        /// <summary>
        /// Commit which most recently changed this file.
        /// </summary>
        public virtual Commit FinalCommit { get { return finalCommit.Value; } }

        /// <summary>
        /// Line number where this hunk begins, as of <see cref="FinalCommit"/>, in <see cref="InitialPath"/>.
        /// </summary>
        public virtual int InitialStartLineNumber { get; private set; }

        /// <summary>
        /// Signature of the oldest-traced change to this hunk.
        /// </summary>
        public virtual Signature InitialSignature { get; private set; }

        /// <summary>
        /// Commit to which the oldest change to this hunk has been traced.
        /// </summary>
        public virtual Commit InitialCommit { get { return origCommit.Value; } }

        /// <summary>
        /// Path to the file where this hunk originated, as of <see cref="InitialCommit"/>.
        /// </summary>
        public virtual string InitialPath { get; private set; }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0}-{1} ({2})",
                                     FinalStartLineNumber,
                                     FinalStartLineNumber+LineCount-1,
                                     FinalCommit.ToString().Substring(0,7));
            }
        }

        private readonly Lazy<Commit> finalCommit;
        private readonly Lazy<Commit> origCommit;

        /// <summary>
        /// Indicates whether the current object is equal to another object of the same type.
        /// </summary>
        /// <returns>
        /// true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
        /// </returns>
        /// <param name="other">An object to compare with this object.</param>
        public bool Equals(BlameHunk other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="BlameHunk"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="BlameHunk"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="BlameHunk"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as BlameHunk);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode();
        }

        /// <summary>
        /// Tests if two <see cref="BlameHunk"/>s are equal.
        /// </summary>
        /// <param name="left">First hunk to compare.</param>
        /// <param name="right">Second hunk to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(BlameHunk left, BlameHunk right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="BlameHunk"/>s are unequal.
        /// </summary>
        /// <param name="left">First hunk to compare.</param>
        /// <param name="right">Second hunk to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(BlameHunk left, BlameHunk right)
        {
            return !Equals(left, right);
        }
    }

    /// <summary>
    /// The result of a blame operation.
    /// </summary>
    public class BlameHunkCollection : IEnumerable<BlameHunk>
    {
        private readonly IRepository repo;
        private readonly List<BlameHunk> hunks = new List<BlameHunk>();

        /// <summary>
        /// For easy mocking
        /// </summary>
        protected BlameHunkCollection() { }

        internal unsafe BlameHunkCollection(Repository repo, RepositoryHandle repoHandle, string path, BlameOptions options)
        {
            this.repo = repo;

            var rawopts = new git_blame_options
            {
                version = 1,
                flags = options.Strategy.ToGitBlameOptionFlags(),
                min_line = new UIntPtr((uint)options.MinLine),
                max_line = new UIntPtr((uint)options.MaxLine),
            };

            if (options.StartingAt != null)
            {
                fixed (byte* p = rawopts.newest_commit.Id)
                {
                    Marshal.Copy(repo.Committish(options.StartingAt).Oid.Id, 0, new IntPtr(p), git_oid.Size);
                }
            }

            if (options.StoppingAt != null)
            {
                fixed (byte* p = rawopts.oldest_commit.Id)
                {
                    Marshal.Copy(repo.Committish(options.StoppingAt).Oid.Id, 0, new IntPtr(p), git_oid.Size);
                }
            }

            using (var blameHandle = Proxy.git_blame_file(repoHandle, path, rawopts))
            {
                var numHunks = NativeMethods.git_blame_get_hunk_count(blameHandle);
                for (uint i = 0; i < numHunks; ++i)
                {
                    var rawHunk = Proxy.git_blame_get_hunk_byindex(blameHandle, i);
                    hunks.Add(new BlameHunk(this.repo, rawHunk));
                }
            }
        }

        /// <summary>
        /// Access blame hunks by index.
        /// </summary>
        /// <param name="idx">The index of the hunk to retrieve</param>
        /// <returns>The <see cref="BlameHunk"/> at the given index.</returns>
        public virtual BlameHunk this[int idx]
        {
            get { return hunks[idx]; }
        }

        /// <summary>
        /// Access blame hunks by the file line.
        /// </summary>
        /// <param name="line">Line number to search for</param>
        /// <returns>The <see cref="BlameHunk"/> that contains the specified file line.</returns>
        public virtual BlameHunk HunkForLine(int line)
        {
            var hunk = hunks.FirstOrDefault(x => x.ContainsLine(line));
            if (hunk != null)
            {
                return hunk;
            }
            throw new ArgumentOutOfRangeException("line", "No hunk for that line");
        }

        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        /// <filterpriority>2</filterpriority>
        public virtual IEnumerator<BlameHunk> GetEnumerator()
        {
            return hunks.GetEnumerator();
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }

    /// <summary>
    /// Strategy used for blaming.
    /// </summary>
    public enum BlameStrategy
    {
        /// <summary>
        /// Track renames of the file, but no block movement.
        /// </summary>
        Default,

        // Track copies within the same file. (NOT SUPPORTED IN LIBGIT2 YET)
        //TrackCopiesSameFile,

        // Track movement across files within the same commit. (NOT SUPPORTED IN LIBGIT2 YET)
        //TrackCopiesSameCommitMoves,

        // Track copies across files within the same commit. (NOT SUPPORTED IN LIBGIT2 YET)
        //TrackCopiesSameCommitCopies,

        // Track copies across all files in all commits. (NOT SUPPORTED IN LIBGIT2 YET)
        //TrackCopiesAnyCommitCopies
    }

    /// <summary>
    /// Optional adjustments to the behavior of blame.
    /// </summary>
    public sealed class BlameOptions
    {
        /// <summary>
        /// Strategy to use to determine the blame for each line.
        /// The default is <see cref="BlameStrategy.Default"/>.
        /// </summary>
        public BlameStrategy Strategy { get; set; }

        /// <summary>
        /// Latest commitish to consider (the starting point).
        /// If null, blame will use HEAD.
        /// </summary>
        public object StartingAt { get; set; }

        /// <summary>
        /// Oldest commitish to consider (the stopping point).
        /// If null, blame will continue until all the lines have been blamed,
        /// or until a commit with no parents is reached.
        /// </summary>
        public object StoppingAt { get; set; }

        /// <summary>
        /// First text line in the file to blame (lines start at 1).
        /// If this is set to 0, the blame begins at line 1.
        /// </summary>
        public int MinLine { get; set; }

        /// <summary>
        /// Last text line in the file to blame (lines start at 1).
        /// If this is set to 0, blame ends with the last line in the file.
        /// </summary>
        public int MaxLine { get; set; }
    }

    /// <summary>
    /// Stores the binary content of a tracked file.
    /// </summary>
    /// <remarks>
    /// Since the introduction of partially cloned repositories, blobs might be missing on your local repository (see https://git-scm.com/docs/partial-clone)
    /// </remarks>
    public class Blob : GitObject
    {
        private readonly ILazy<Int64> lazySize;
        private readonly ILazy<bool> lazyIsBinary;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Blob()
        { }

        internal Blob(Repository repo, ObjectId id)
            : base(repo, id)
        {
            lazySize = GitObjectLazyGroup.Singleton(repo, id, Proxy.git_blob_rawsize, throwIfMissing: true);
            lazyIsBinary = GitObjectLazyGroup.Singleton(repo, id, Proxy.git_blob_is_binary, throwIfMissing: true);
        }

        /// <summary>
        /// Gets the size in bytes of the raw content of a blob.
        /// <para> Please note that this would load entire blob content in the memory to compute the Size.
        /// In order to read blob size from header, Repository.ObjectDatabase.RetrieveObjectMetadata(Blob.Id).Size
        /// can be used.
        /// </para>
        /// </summary>
        /// <exception cref="NotFoundException">Throws if blob is missing</exception>
        public virtual long Size { get { return lazySize.Value; } }

        /// <summary>
        ///  Determine if the blob content is most certainly binary or not.
        /// </summary>
        /// <exception cref="NotFoundException">Throws if blob is missing</exception>
        public virtual bool IsBinary { get { return lazyIsBinary.Value; } }

        /// <summary>
        /// Gets the blob content in a <see cref="Stream"/>.
        /// </summary>
        /// <exception cref="NotFoundException">Throws if blob is missing</exception>
        public virtual Stream GetContentStream()
        {
            return Proxy.git_blob_rawcontent_stream(repo.Handle, Id, Size);
        }

#if LIBGIT2_HAVE_DEPRECATE
        /// <summary>
        /// Gets the blob content in a <see cref="Stream"/> as it would be
        /// checked out to the working directory.
        /// <param name="filteringOptions">Parameter controlling content filtering behavior</param>
        /// </summary>
        /// <exception cref="NotFoundException">Throws if blob is missing</exception>
        public virtual Stream GetContentStream(FilteringOptions filteringOptions)
        {
            Ensure.ArgumentNotNull(filteringOptions, "filteringOptions");

            return Proxy.git_blob_filtered_content_stream(repo.Handle, Id, filteringOptions.HintPath, false);
        }
#endif

        /// <summary>
        /// Gets the blob content, decoded with UTF8 encoding if the encoding cannot be detected from the byte order mark
        /// </summary>
        /// <returns>Blob content as text.</returns>
        /// <exception cref="NotFoundException">Throws if blob is missing</exception>
        public virtual string GetContentText()
        {
            return ReadToEnd(GetContentStream(), null);
        }

        /// <summary>
        /// Gets the blob content decoded with the specified encoding,
        /// or according to byte order marks, or the specified encoding as a fallback
        /// </summary>
        /// <param name="encoding">The encoding of the text to use, if it cannot be detected</param>
        /// <returns>Blob content as text.</returns>
        /// <exception cref="NotFoundException">Throws if blob is missing</exception>
        public virtual string GetContentText(Encoding encoding)
        {
            Ensure.ArgumentNotNull(encoding, "encoding");

            return ReadToEnd(GetContentStream(), encoding);
        }

#if LIBGIT2_HAVE_DEPRECATE
        /// <summary>
        /// Gets the blob content, decoded with UTF8 encoding if the encoding cannot be detected
        /// </summary>
        /// <param name="filteringOptions">Parameter controlling content filtering behavior</param>
        /// <returns>Blob content as text.</returns>
        /// <exception cref="NotFoundException">Throws if blob is missing</exception>
        public virtual string GetContentText(FilteringOptions filteringOptions)
        {
            return GetContentText(filteringOptions, null);
        }

        /// <summary>
        /// Gets the blob content as it would be checked out to the
        /// working directory, decoded with the specified encoding,
        /// or according to byte order marks, with UTF8 as fallback,
        /// if <paramref name="encoding"/> is null.
        /// </summary>
        /// <param name="filteringOptions">Parameter controlling content filtering behavior</param>
        /// <param name="encoding">The encoding of the text. (default: detected or UTF8)</param>
        /// <returns>Blob content as text.</returns>
        /// <exception cref="NotFoundException">Throws if blob is missing</exception>
        public virtual string GetContentText(FilteringOptions filteringOptions, Encoding encoding)
        {
            Ensure.ArgumentNotNull(filteringOptions, "filteringOptions");

            return ReadToEnd(GetContentStream(filteringOptions), encoding);
        }
#endif

        private static string ReadToEnd(Stream stream, Encoding encoding)
        {
            using (var reader = new StreamReader(stream, encoding ?? LaxUtf8Marshaler.Encoding, encoding == null))
            {
                return reader.ReadToEnd();
            }
        }
    }

    /// <summary>
    /// A branch is a special kind of reference
    /// </summary>
    public class Branch : ReferenceWrapper<Commit>
    {
        private readonly Lazy<Branch> trackedBranch;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Branch()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Branch"/> class.
        /// </summary>
        /// <param name="repo">The repo.</param>
        /// <param name="reference">The reference.</param>
        /// <param name="canonicalName">The full name of the reference</param>
        internal Branch(Repository repo, Reference reference, string canonicalName)
            : this(repo, reference, _ => canonicalName)
        { }

        /// <summary>
        /// Initializes a new instance of an orphaned <see cref="Branch"/> class.
        /// <para>
        ///   This <see cref="Branch"/> instance will point to no commit.
        /// </para>
        /// </summary>
        /// <param name="repo">The repo.</param>
        /// <param name="reference">The reference.</param>
        internal Branch(Repository repo, Reference reference)
            : this(repo, reference, r => r.TargetIdentifier)
        { }

        private Branch(Repository repo, Reference reference, Func<Reference, string> canonicalNameSelector)
            : base(repo, reference, canonicalNameSelector)
        {
            trackedBranch = new Lazy<Branch>(ResolveTrackedBranch);
        }

        /// <summary>
        /// Gets the <see cref="TreeEntry"/> pointed at by the <paramref name="relativePath"/> in the <see cref="Tip"/>.
        /// </summary>
        /// <param name="relativePath">The relative path to the <see cref="TreeEntry"/> from the <see cref="Tip"/> working directory.</param>
        /// <returns><c>null</c> if nothing has been found, the <see cref="TreeEntry"/> otherwise.</returns>
        public virtual TreeEntry this[string relativePath]
        {
            get
            {
                if (Tip == null)
                {
                    return null;
                }

                return Tip[relativePath];
            }
        }

        /// <summary>
        /// Gets a value indicating whether this instance is a remote.
        /// </summary>
        /// <value>
        /// <c>true</c> if this instance is remote; otherwise, <c>false</c>.
        /// </value>
        public virtual bool IsRemote
        {
            get { return IsRemoteBranch(CanonicalName); }
        }

        /// <summary>
        /// Gets the remote branch which is connected to this local one, or null if there is none.
        /// </summary>
        public virtual Branch TrackedBranch
        {
            get { return trackedBranch.Value; }
        }

        /// <summary>
        /// Determines if this local branch is connected to a remote one.
        /// </summary>
        public virtual bool IsTracking
        {
            get { return TrackedBranch != null; }
        }

        /// <summary>
        /// Gets additional information about the tracked branch.
        /// </summary>
        public virtual BranchTrackingDetails TrackingDetails
        {
            get { return new BranchTrackingDetails(repo, this); }
        }

        /// <summary>
        /// Gets a value indicating whether this instance is current branch (HEAD) in the repository.
        /// </summary>
        /// <value>
        /// <c>true</c> if this instance is the current branch; otherwise, <c>false</c>.
        /// </value>
        public virtual bool IsCurrentRepositoryHead
        {
            get
            {
                if (this is DetachedHead)
                {
                    return repo.Head.Reference.TargetIdentifier == this.Reference.TargetIdentifier;
                }

                return repo.Head.Reference.TargetIdentifier == this.CanonicalName;
            }
        }

        /// <summary>
        /// Gets the <see cref="Commit"/> that this branch points to.
        /// </summary>
        public virtual Commit Tip
        {
            get { return TargetObject; }
        }

        /// <summary>
        /// Gets the commits on this branch. (Starts walking from the References's target).
        /// </summary>
        public virtual ICommitLog Commits
        {
            get { return repo.Commits.QueryBy(new CommitFilter { IncludeReachableFrom = this }); }
        }

        /// <summary>
        /// Gets the configured canonical name of the upstream branch.
        /// <para>
        ///   This is the upstream reference to which this branch will be pushed.
        ///   It corresponds to the "branch.branch_name.merge" property of the config file.
        /// </para>
        /// </summary>
        public virtual string UpstreamBranchCanonicalName
        {
            get
            {
                if (IsRemote)
                {
                    using (var remote = repo.Network.Remotes.RemoteForName(RemoteName))
                    {
                        return remote.FetchSpecTransformToSource(CanonicalName);
                    }
                }

                return UpstreamBranchCanonicalNameFromLocalBranch();
            }
        }

        /// <summary>
        /// Get the name of the remote for the branch.
        /// <para>
        ///   If this is a local branch, this will return the configured
        ///   <see cref="Remote"/> to fetch from and push to. If this is a
        ///   remote-tracking branch, this will return the name of the remote
        ///   containing the tracked branch. If there is no tracking information,
        ///   this will return null.
        /// </para>
        /// </summary>
        public virtual string RemoteName
        {
            get
            {
                return IsRemote
                    ? RemoteNameFromRemoteTrackingBranch()
                    : RemoteNameFromLocalBranch();
            }
        }

        private string UpstreamBranchCanonicalNameFromLocalBranch()
        {
            ConfigurationEntry<string> mergeRefEntry = repo.Config.Get<string>("branch", FriendlyName, "merge");

            if (mergeRefEntry == null)
            {
                return null;
            }

            return mergeRefEntry.Value;
        }

        private string RemoteNameFromLocalBranch()
        {
            ConfigurationEntry<string> remoteEntry = repo.Config.Get<string>("branch", FriendlyName, "remote");

            if (remoteEntry == null)
            {
                return null;
            }

            string remoteName = remoteEntry.Value;

            if (string.IsNullOrEmpty(remoteName) ||
                string.Equals(remoteName, ".", StringComparison.Ordinal))
            {
                return null;
            }

            return remoteName;

        }

        private string RemoteNameFromRemoteTrackingBranch()
        {
            return Proxy.git_branch_remote_name(repo.Handle, CanonicalName, false);
        }

        private Branch ResolveTrackedBranch()
        {
            if (IsRemote)
            {
                return null;
            }

            string trackedReferenceName = Proxy.git_branch_upstream_name(repo.Handle, CanonicalName);

            if (trackedReferenceName == null)
            {
                return null;
            }

            Branch branch = repo.Branches[trackedReferenceName];

            if (branch != null)
            {
                return branch;
            }

            return new Branch(repo, new VoidReference(repo, trackedReferenceName), trackedReferenceName);
        }

        private static bool IsRemoteBranch(string canonicalName)
        {
            return canonicalName.LooksLikeRemoteTrackingBranch();
        }

        /// <summary>
        /// Removes redundent leading namespaces (regarding the kind of
        /// reference being wrapped) from the canonical name.
        /// </summary>
        /// <returns>The friendly shortened name</returns>
        protected override string Shorten()
        {
            if (CanonicalName.LooksLikeLocalBranch())
            {
                return CanonicalName.Substring(Reference.LocalBranchPrefix.Length);
            }

            if (CanonicalName.LooksLikeRemoteTrackingBranch())
            {
                return CanonicalName.Substring(Reference.RemoteTrackingBranchPrefix.Length);
            }

            throw new ArgumentException(string.Format(CultureInfo.InvariantCulture,
                                                      "'{0}' does not look like a valid branch name.",
                                                      CanonicalName));
        }
    }

    /// <summary>
    /// The collection of Branches in a <see cref="Repository"/>
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class BranchCollection : IEnumerable<Branch>
    {
        internal readonly Repository repo;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected BranchCollection()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="BranchCollection"/> class.
        /// </summary>
        /// <param name="repo">The repo.</param>
        internal BranchCollection(Repository repo)
        {
            this.repo = repo;
        }

        /// <summary>
        /// Gets the <see cref="LibGit2Sharp.Branch"/> with the specified name.
        /// </summary>
        public virtual Branch this[string name]
        {
            get
            {
                Ensure.ArgumentNotNullOrEmptyString(name, "name");

                if (LooksLikeABranchName(name))
                {
                    return BuildFromReferenceName(name);
                }

                Branch branch = BuildFromReferenceName(ShortToLocalName(name));
                if (branch != null)
                {
                    return branch;
                }

                branch = BuildFromReferenceName(ShortToRemoteName(name));
                if (branch != null)
                {
                    return branch;
                }

                return BuildFromReferenceName(ShortToRefName(name));
            }
        }

        private static string ShortToLocalName(string name)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0}{1}", Reference.LocalBranchPrefix, name);
        }

        private static string ShortToRemoteName(string name)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0}{1}", Reference.RemoteTrackingBranchPrefix, name);
        }

        private static string ShortToRefName(string name)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0}{1}", "refs/", name);
        }

        private Branch BuildFromReferenceName(string canonicalName)
        {
            var reference = repo.Refs.Resolve<Reference>(canonicalName);
            return reference == null ? null : new Branch(repo, reference, canonicalName);
        }

        #region IEnumerable<Branch> Members

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<Branch> GetEnumerator()
        {
            return Proxy.git_branch_iterator(repo, GitBranchType.GIT_BRANCH_ALL)
                        .ToList()
                        .GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        /// <summary>
        /// Create a new local branch with the specified name
        /// </summary>
        /// <param name="name">The name of the branch.</param>
        /// <param name="committish">Revparse spec for the target commit.</param>
        /// <returns>A new <see cref="Branch"/>.</returns>
        public virtual Branch Add(string name, string committish)
        {
            return Add(name, committish, false);
        }

        /// <summary>
        /// Create a new local branch with the specified name
        /// </summary>
        /// <param name="name">The name of the branch.</param>
        /// <param name="commit">The target commit.</param>
        /// <returns>A new <see cref="Branch"/>.</returns>
        public virtual Branch Add(string name, Commit commit)
        {
            return Add(name, commit, false);
        }

        /// <summary>
        /// Create a new local branch with the specified name
        /// </summary>
        /// <param name="name">The name of the branch.</param>
        /// <param name="commit">The target commit.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing branch, false otherwise.</param>
        /// <returns>A new <see cref="Branch"/>.</returns>
        public virtual Branch Add(string name, Commit commit, bool allowOverwrite)
        {
            Ensure.ArgumentNotNull(commit, "commit");

            return Add(name, commit.Sha, allowOverwrite);
        }

        /// <summary>
        /// Create a new local branch with the specified name
        /// </summary>
        /// <param name="name">The name of the branch.</param>
        /// <param name="committish">Revparse spec for the target commit.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing branch, false otherwise.</param>
        /// <returns>A new <see cref="Branch"/>.</returns>
        public virtual Branch Add(string name, string committish, bool allowOverwrite)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");
            Ensure.ArgumentNotNullOrEmptyString(committish, "committish");

            using (Proxy.git_branch_create_from_annotated(repo.Handle, name, committish, allowOverwrite))
            { }

            var branch = this[ShortToLocalName(name)];
            return branch;
        }

        /// <summary>
        /// Deletes the branch with the specified name.
        /// </summary>
        /// <param name="name">The name of the branch to delete.</param>
        public virtual void Remove(string name)
        {
            Remove(name, false);
        }

        /// <summary>
        /// Deletes the branch with the specified name.
        /// </summary>
        /// <param name="name">The name of the branch to delete.</param>
        /// <param name="isRemote">True if the provided <paramref name="name"/> is the name of a remote branch, false otherwise.</param>
        public virtual void Remove(string name, bool isRemote)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");

            string branchName = isRemote ? Reference.RemoteTrackingBranchPrefix + name : name;

            Branch branch = this[branchName];

            if (branch == null)
            {
                return;
            }

            Remove(branch);
        }
        /// <summary>
        /// Deletes the specified branch.
        /// </summary>
        /// <param name="branch">The branch to delete.</param>
        public virtual void Remove(Branch branch)
        {
            Ensure.ArgumentNotNull(branch, "branch");

            using (ReferenceHandle referencePtr = repo.Refs.RetrieveReferencePtr(branch.CanonicalName))
            {
                Proxy.git_branch_delete(referencePtr);
            }
        }

        /// <summary>
        /// Rename an existing local branch, using the default reflog message
        /// </summary>
        /// <param name="currentName">The current branch name.</param>
        /// <param name="newName">The new name the existing branch should bear.</param>
        /// <returns>A new <see cref="Branch"/>.</returns>
        public virtual Branch Rename(string currentName, string newName)
        {
            return Rename(currentName, newName, false);
        }

        /// <summary>
        /// Rename an existing local branch, using the default reflog message
        /// </summary>
        /// <param name="currentName">The current branch name.</param>
        /// <param name="newName">The new name the existing branch should bear.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing branch, false otherwise.</param>
        /// <returns>A new <see cref="Branch"/>.</returns>
        public virtual Branch Rename(string currentName, string newName, bool allowOverwrite)
        {
            Ensure.ArgumentNotNullOrEmptyString(currentName, "currentName");
            Ensure.ArgumentNotNullOrEmptyString(newName, "newName");

            Branch branch = this[currentName];

            if (branch == null)
            {
                throw new LibGit2SharpException("No branch named '{0}' exists in the repository.");
            }

            return Rename(branch, newName, allowOverwrite);
        }

        /// <summary>
        /// Rename an existing local branch
        /// </summary>
        /// <param name="branch">The current local branch.</param>
        /// <param name="newName">The new name the existing branch should bear.</param>
        /// <returns>A new <see cref="Branch"/>.</returns>
        public virtual Branch Rename(Branch branch, string newName)
        {
            return Rename(branch, newName, false);
        }

        /// <summary>
        /// Rename an existing local branch
        /// </summary>
        /// <param name="branch">The current local branch.</param>
        /// <param name="newName">The new name the existing branch should bear.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing branch, false otherwise.</param>
        /// <returns>A new <see cref="Branch"/>.</returns>
        public virtual Branch Rename(Branch branch, string newName, bool allowOverwrite)
        {
            Ensure.ArgumentNotNull(branch, "branch");
            Ensure.ArgumentNotNullOrEmptyString(newName, "newName");

            if (branch.IsRemote)
            {
                throw new LibGit2SharpException("Cannot rename branch '{0}'. It's a remote tracking branch.",
                                                branch.FriendlyName);
            }

            using (ReferenceHandle referencePtr = repo.Refs.RetrieveReferencePtr(Reference.LocalBranchPrefix + branch.FriendlyName))
            {
                using (Proxy.git_branch_move(referencePtr, newName, allowOverwrite))
                { }
            }

            var newBranch = this[newName];
            return newBranch;
        }

        /// <summary>
        /// Update properties of a branch.
        /// </summary>
        /// <param name="branch">The branch to update.</param>
        /// <param name="actions">Delegate to perform updates on the branch.</param>
        /// <returns>The updated branch.</returns>
        public virtual Branch Update(Branch branch, params Action<BranchUpdater>[] actions)
        {
            var updater = new BranchUpdater(repo, branch);

            foreach (Action<BranchUpdater> action in actions)
            {
                action(updater);
            }

            return this[branch.FriendlyName];
        }

        private static bool LooksLikeABranchName(string referenceName)
        {
            return referenceName == "HEAD" ||
                referenceName.LooksLikeLocalBranch() ||
                referenceName.LooksLikeRemoteTrackingBranch();
        }

        private string DebuggerDisplay
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Count = {0}", this.Count()); }
        }
    }

    /// <summary>
    /// Tracking information for a <see cref="Branch"/>
    /// </summary>
    public class BranchTrackingDetails
    {
        private readonly HistoryDivergence historyDivergence;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected BranchTrackingDetails()
        { }

        internal BranchTrackingDetails(Repository repo, Branch branch)
        {
            if (!branch.IsTracking || branch.Tip == null || branch.TrackedBranch.Tip == null)
            {
                historyDivergence = new NullHistoryDivergence();
                return;
            }

            historyDivergence = repo.ObjectDatabase.CalculateHistoryDivergence(branch.Tip, branch.TrackedBranch.Tip);
        }

        /// <summary>
        /// Gets the number of commits that exist in this local branch but don't exist in the tracked one.
        /// <para>
        ///   This property will return <c>null</c> if this local branch has no upstream configuration
        ///   or if the upstream branch does not exist
        /// </para>
        /// </summary>
        public virtual int? AheadBy
        {
            get { return historyDivergence.AheadBy; }
        }

        /// <summary>
        /// Gets the number of commits that exist in the tracked branch but don't exist in this local one.
        /// <para>
        ///   This property will return <c>null</c> if this local branch has no upstream configuration
        ///   or if the upstream branch does not exist
        /// </para>
        /// </summary>
        public virtual int? BehindBy
        {
            get { return historyDivergence.BehindBy; }
        }

        /// <summary>
        /// Gets the common ancestor of the local branch and its tracked remote branch.
        /// <para>
        ///   This property will return <c>null</c> if this local branch has no upstream configuration,
        ///   the upstream branch does not exist, or either branch is an orphan.
        /// </para>
        /// </summary>
        public virtual Commit CommonAncestor
        {
            get { return historyDivergence.CommonAncestor; }
        }
    }

    /// <summary>
    /// Exposes properties of a branch that can be updated.
    /// </summary>
    public class BranchUpdater
    {
        private readonly Repository repo;
        private readonly Branch branch;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected BranchUpdater()
        { }

        internal BranchUpdater(Repository repo, Branch branch)
        {
            Ensure.ArgumentNotNull(repo, "repo");
            Ensure.ArgumentNotNull(branch, "branch");

            this.repo = repo;
            this.branch = branch;
        }

        /// <summary>
        /// Sets the upstream information for the branch.
        /// <para>
        ///   Passing null or string.Empty will unset the upstream.
        /// </para>
        /// <para>
        ///   The upstream branch name is with respect to the current repository.
        ///   So, passing "refs/remotes/origin/master" will set the current branch
        ///   to track "refs/heads/master" on the origin. Passing in
        ///   "refs/heads/master" will result in the branch tracking the local
        ///   master branch.
        /// </para>
        /// </summary>
        public virtual string TrackedBranch
        {
            set
            {
                if (string.IsNullOrEmpty(value))
                {
                    UnsetUpstream();
                    return;
                }

                SetUpstream(value);
            }
        }

        /// <summary>
        /// Set the upstream branch for this branch.
        /// <para>
        ///   To track the "master" branch on the "origin" remote, set the
        ///   <see cref="Remote"/> property to "origin" and the <see cref="UpstreamBranch"/>
        ///   property to "refs/heads/master".
        /// </para>
        /// </summary>
        public virtual string UpstreamBranch
        {
            set
            {
                SetUpstreamBranch(value);
            }
        }

        /// <summary>
        /// Set the upstream remote for this branch.
        /// <para>
        ///   To track the "master" branch on the "origin" remote, set the
        ///   <see cref="Remote"/> property to "origin" and the <see cref="UpstreamBranch"/>
        ///   property to "refs/heads/master".
        /// </para>
        /// </summary>
        public virtual string Remote
        {
            set
            {
                SetUpstreamRemote(value);
            }
        }

        private void UnsetUpstream()
        {
            SetUpstreamRemote(string.Empty);
            SetUpstreamBranch(string.Empty);
        }

        /// <summary>
        /// Set the upstream information for the current branch.
        /// <para>
        /// The upstream branch name is with respect to the current repository.
        /// So, passing "refs/remotes/origin/master" will set the current branch
        /// to track "refs/heads/master" on the origin. Passing in
        /// "refs/heads/master" will result in the branch tracking the local
        /// master branch.
        /// </para>
        /// </summary>
        /// <param name="upstreamBranchName">The remote branch to track (e.g. refs/remotes/origin/master).</param>
        private void SetUpstream(string upstreamBranchName)
        {
            if (branch.IsRemote)
            {
                throw new LibGit2SharpException("Cannot set upstream branch on a remote branch.");
            }

            string remoteName;
            string branchName;

            GetUpstreamInformation(upstreamBranchName, out remoteName, out branchName);

            SetUpstreamRemote(remoteName);
            SetUpstreamBranch(branchName);
        }

        /// <summary>
        /// Set the upstream merge branch for the local branch.
        /// </summary>
        /// <param name="mergeBranchName">The merge branch in the upstream remote's namespace.</param>
        private void SetUpstreamBranch(string mergeBranchName)
        {
            string configKey = string.Format(CultureInfo.InvariantCulture, "branch.{0}.merge", branch.FriendlyName);

            if (string.IsNullOrEmpty(mergeBranchName))
            {
                repo.Config.Unset(configKey);
            }
            else
            {
                repo.Config.Set(configKey, mergeBranchName);
            }
        }

        /// <summary>
        /// Set the upstream remote for the local branch.
        /// </summary>
        /// <param name="remoteName">The name of the remote to set as the upstream branch.</param>
        private void SetUpstreamRemote(string remoteName)
        {
            string configKey = string.Format(CultureInfo.InvariantCulture, "branch.{0}.remote", branch.FriendlyName);

            if (string.IsNullOrEmpty(remoteName))
            {
                repo.Config.Unset(configKey);
            }
            else
            {
                if (!remoteName.Equals(".", StringComparison.Ordinal))
                {
                    // Verify that remote exists.
                    using (repo.Network.Remotes.RemoteForName(remoteName)) { }
                }

                repo.Config.Set(configKey, remoteName);
            }
        }

        /// <summary>
        /// Get the upstream remote and merge branch name from a Canonical branch name.
        /// This will return the remote name (or ".") if a local branch for the remote name.
        /// </summary>
        /// <param name="canonicalName">The canonical branch name to parse.</param>
        /// <param name="remoteName">The name of the corresponding remote the branch belongs to
        /// or "." if it is a local branch.</param>
        /// <param name="mergeBranchName">The name of the upstream branch to merge into.</param>
        private void GetUpstreamInformation(string canonicalName, out string remoteName, out string mergeBranchName)
        {
            remoteName = null;
            mergeBranchName = null;

            if (canonicalName.LooksLikeLocalBranch())
            {
                remoteName = ".";
                mergeBranchName = canonicalName;
            }
            else if (canonicalName.LooksLikeRemoteTrackingBranch())
            {
                remoteName = Proxy.git_branch_remote_name(repo.Handle, canonicalName, true);

                using (var remote = repo.Network.Remotes.RemoteForName(remoteName))
                {
                    mergeBranchName = remote.FetchSpecTransformToSource(canonicalName);
                }
            }
            else
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture,
                                                          "'{0}' does not look like a valid canonical branch name.",
                                                          canonicalName));
            }
        }
    }

    /// <summary>
    /// Flags to identify libgit2 compiled features.
    /// </summary>
    [Flags]
    public enum BuiltInFeatures
    {
        /// <summary>
        /// No optional features are compiled into libgit2.
        /// </summary>
        None = 0,

        /// <summary>
        /// Threading support is compiled into libgit2.
        /// </summary>
        Threads = (1 << 0),

        /// <summary>
        /// Support for remotes over the HTTPS protocol is compiled into
        /// libgit2.
        /// </summary>
        Https = (1 << 1),

        /// <summary>
        /// Support for remotes over the SSH protocol is compiled into
        /// libgit2.
        /// </summary>
        Ssh = (1 << 2),

        /// <summary>
        /// Support for sub-second resolution in file modification times
        /// is compiled into libgit2.
        /// </summary>
        NSec = (1 << 3),
    }

    /// <summary>
    /// Top-level certificate type. The usable certificates inherit from this class.
    /// </summary>
    public abstract class Certificate
    {
    }

    /// <summary>
    /// This class represents the hostkey which is avaiable when connecting to a SSH host.
    /// </summary>
    public class CertificateSsh : Certificate
    {
        /// <summary>
        /// For mocking purposes
        /// </summary>
        protected CertificateSsh()
        { }

        /// <summary>
        /// The MD5 hash of the host. Meaningful if <see cref="HasMD5"/> is true
        /// </summary>
        public readonly byte[] HashMD5;

        /// <summary>
        /// The SHA1 hash of the host. Meaningful if <see cref="HasSHA1"/> is true
        /// </summary>
        public readonly byte[] HashSHA1;

        /// <summary>
        /// True if we have the MD5 hostkey hash from the server
        /// </summary>
        public readonly bool HasMD5;

        /// <summary>
        /// True if we have the SHA1 hostkey hash from the server
        /// </summary>
        public readonly bool HasSHA1;

        internal unsafe CertificateSsh(git_certificate_ssh* cert)
        {

            HasMD5  = cert->type.HasFlag(GitCertificateSshType.MD5);
            HasSHA1 = cert->type.HasFlag(GitCertificateSshType.SHA1);

            HashMD5 = new byte[16];
            for (var i = 0; i < HashMD5.Length; i++)
            {
                HashMD5[i] = cert->HashMD5[i];
            }

            HashSHA1 = new byte[20];
            for (var i = 0; i < HashSHA1.Length; i++)
            {
                HashSHA1[i] = cert->HashSHA1[i];
            }
        }

        internal unsafe IntPtr ToPointer()
        {
            GitCertificateSshType sshCertType = 0;
            if (HasMD5)
            {
                sshCertType |= GitCertificateSshType.MD5;
            }
            if (HasSHA1)
            {
                sshCertType |= GitCertificateSshType.SHA1;
            }

            var gitCert = new git_certificate_ssh()
            {
                cert_type = GitCertificateType.Hostkey,
                type = sshCertType,
            };

            fixed (byte *p = &HashMD5[0])
            {
                for (var i = 0; i < HashMD5.Length; i++)
                {
                    gitCert.HashMD5[i] = p[i];
                }
            }

            fixed (byte *p = &HashSHA1[0])
            {
                for (var i = 0; i < HashSHA1.Length; i++)
                {
                    gitCert.HashSHA1[i] = p[i];
                }
            }

            var ptr = Marshal.AllocHGlobal(Marshal.SizeOf(gitCert));
            Marshal.StructureToPtr(gitCert, ptr, false);

            return ptr;
        }
    }

    /// <summary>
    /// Conains a X509 certificate
    /// </summary>
    public class CertificateX509 : Certificate
    {
        /// <summary>
        /// For mocking purposes
        /// </summary>
        protected CertificateX509()
        { }

        /// <summary>
        /// The certificate.
        /// </summary>
        public virtual X509Certificate Certificate { get; private set; }

        internal unsafe CertificateX509(git_certificate_x509* cert)
        {
            int len = checked((int) cert->len.ToUInt32());
            byte[] data = new byte[len];
            Marshal.Copy(new IntPtr(cert->data), data, 0, len);
            Certificate = new X509Certificate(data);
        }

        internal CertificateX509(X509Certificate cert)
        {
            Certificate = cert;
        }

        internal unsafe IntPtr ToPointers(out IntPtr dataPtr)
        {
            var certData = Certificate.Export(X509ContentType.Cert);
            dataPtr = Marshal.AllocHGlobal(certData.Length);
            Marshal.Copy(certData, 0, dataPtr, certData.Length);
            var gitCert = new git_certificate_x509()
            {
                cert_type = GitCertificateType.X509,
                data = (byte*) dataPtr.ToPointer(),
                len = (UIntPtr)certData.Length,
            };

            var ptr = Marshal.AllocHGlobal(Marshal.SizeOf(gitCert));
            Marshal.StructureToPtr(gitCert, ptr, false);

            return ptr;
        }
    }

    /// <summary>
    /// The kind of changes that a Diff can report.
    /// </summary>
    public enum ChangeKind
    {
        /// <summary>
        /// No changes detected.
        /// </summary>
        Unmodified = 0,

        /// <summary>
        /// The file was added.
        /// </summary>
        Added = 1,

        /// <summary>
        /// The file was deleted.
        /// </summary>
        Deleted = 2,

        /// <summary>
        /// The file content was modified.
        /// </summary>
        Modified = 3,

        /// <summary>
        /// The file was renamed.
        /// </summary>
        Renamed = 4,

        /// <summary>
        /// The file was copied.
        /// </summary>
        Copied = 5,

        /// <summary>
        /// The file is ignored in the workdir.
        /// </summary>
        Ignored = 6,

        /// <summary>
        /// The file is untracked in the workdir.
        /// </summary>
        Untracked = 7,

        /// <summary>
        /// The type (i.e. regular file, symlink, submodule, ...)
        /// of the file was changed.
        /// </summary>
        TypeChanged = 8,

        /// <summary>
        /// Entry is unreadable.
        /// </summary>
        Unreadable = 9,

        /// <summary>
        /// Entry is currently in conflict.
        /// </summary>
        Conflicted = 10,
    }

    /// <summary>
    /// Class to handle the mapping between libgit2 progress_cb callback on the git_checkout_opts
    /// structure to the CheckoutProgressHandler delegate.
    /// </summary>
    internal class CheckoutCallbacks
    {
        /// <summary>
        /// The managed delegate (e.g. from library consumer) to be called in response to the checkout progress callback.
        /// </summary>
        private readonly CheckoutProgressHandler onCheckoutProgress;

        /// <summary>
        /// The managed delegate (e.g. from library consumer) to be called in response to the checkout notify callback.
        /// </summary>
        private readonly CheckoutNotifyHandler onCheckoutNotify;

        /// <summary>
        /// Constructor to set up native callback for given managed delegate.
        /// </summary>
        /// <param name="onCheckoutProgress"><see cref="CheckoutProgressHandler"/> delegate to call in response to checkout progress_cb</param>
        /// <param name="onCheckoutNotify"><see cref="CheckoutNotifyHandler"/> delegate to call in response to checkout notification callback.</param>
        private CheckoutCallbacks(CheckoutProgressHandler onCheckoutProgress, CheckoutNotifyHandler onCheckoutNotify)
        {
            this.onCheckoutProgress = onCheckoutProgress;
            this.onCheckoutNotify = onCheckoutNotify;
        }

        /// <summary>
        /// The method to pass for the native checkout progress callback.
        /// </summary>
        public progress_cb CheckoutProgressCallback
        {
            get
            {
                if (this.onCheckoutProgress != null)
                {
                    return this.OnGitCheckoutProgress;
                }

                return null;
            }
        }

        /// <summary>
        /// The method to pass for the native checkout notify callback.
        /// </summary>
        public checkout_notify_cb CheckoutNotifyCallback
        {
            get
            {
                if (this.onCheckoutNotify != null)
                {
                    return this.OnGitCheckoutNotify;
                }

                return null;
            }
        }

        /// <summary>
        /// Generate a delegate matching the signature of the native progress_cb callback and wraps the <see cref="CheckoutProgressHandler"/> delegate.
        /// </summary>
        /// <param name="onCheckoutProgress"><see cref="CheckoutProgressHandler"/> that should be wrapped in the native callback.</param>
        /// <param name="onCheckoutNotify"><see cref="CheckoutNotifyHandler"/> delegate to call in response to checkout notification callback.</param>
        /// <returns>The delegate with signature matching the expected native callback.</returns>
        internal static CheckoutCallbacks From(CheckoutProgressHandler onCheckoutProgress, CheckoutNotifyHandler onCheckoutNotify)
        {
            return new CheckoutCallbacks(onCheckoutProgress, onCheckoutNotify);
        }

        /// <summary>
        /// The delegate with a signature that matches the native checkout progress_cb function's signature.
        /// </summary>
        /// <param name="str">The path that was updated.</param>
        /// <param name="completedSteps">The number of completed steps.</param>
        /// <param name="totalSteps">The total number of steps.</param>
        /// <param name="payload">Payload object.</param>
        private void OnGitCheckoutProgress(IntPtr str, UIntPtr completedSteps, UIntPtr totalSteps, IntPtr payload)
        {
            if (onCheckoutProgress != null)
            {
                // Convert null strings into empty strings.
                FilePath path = LaxFilePathMarshaler.FromNative(str) ?? FilePath.Empty;

                onCheckoutProgress(path.Native, (int)completedSteps, (int)totalSteps);
            }
        }

        private int OnGitCheckoutNotify(
            CheckoutNotifyFlags why,
            IntPtr pathPtr,
            IntPtr baselinePtr,
            IntPtr targetPtr,
            IntPtr workdirPtr,
            IntPtr payloadPtr)
        {
            bool result = true;
            if (this.onCheckoutNotify != null)
            {
                FilePath path = LaxFilePathMarshaler.FromNative(pathPtr) ?? FilePath.Empty;
                result = onCheckoutNotify(path.Native, why);
            }

            return Proxy.ConvertResultToCancelFlag(result);
        }
    }

    /// <summary>
    /// The exception that is thrown when a checkout cannot be performed
    /// because of a conflicting change staged in the index, or unstaged
    /// in the working directory.
    /// </summary>
    [Serializable]
    public class CheckoutConflictException : NativeException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.CheckoutConflictException"/> class.
        /// </summary>
        public CheckoutConflictException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.CheckoutConflictException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public CheckoutConflictException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.CheckoutConflictException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public CheckoutConflictException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.CheckoutConflictException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public CheckoutConflictException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.CheckoutConflictException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected CheckoutConflictException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal CheckoutConflictException(string message, GitErrorCategory category)
            : base(message, category)
        { }

        internal override GitErrorCode ErrorCode
        {
            get
            {
                return GitErrorCode.Conflict;
            }
        }
    }

    /// <summary>
    /// Enum specifying what content checkout should write to disk
    /// for conflicts.
    /// </summary>
    public enum CheckoutFileConflictStrategy
    {
        /// <summary>
        /// Use the default behavior for handling file conflicts. This is
        /// controlled by the merge.conflictstyle config option, and is "Merge"
        /// if no option is explicitly set.
        /// </summary>
        Normal,

        /// <summary>
        /// For conflicting files, checkout the "ours" (stage 2)  version of
        /// the file from the index.
        /// </summary>
        Ours,

        /// <summary>
        /// For conflicting files, checkout the "theirs" (stage 3) version of
        /// the file from the index.
        /// </summary>
        Theirs,

        /// <summary>
        /// Write normal merge files for conflicts.
        /// </summary>
        Merge,

        /// <summary>
        /// Write diff3 formated files for conflicts.
        /// </summary>
        Diff3
    }

    /// <summary>
    /// Options controlling Checkout behavior.
    /// </summary>
    [Flags]
    public enum CheckoutModifiers
    {
        /// <summary>
        /// No checkout flags - use default behavior.
        /// </summary>
        None = 0,

        /// <summary>
        /// Proceed with checkout even if the index or the working tree differs from HEAD.
        /// This will throw away local changes.
        /// </summary>
        Force,
    }

    /// <summary>
    /// Flags controlling checkout notification behavior.
    /// </summary>
    [Flags]
    public enum CheckoutNotifyFlags
    {

        /// <summary>
        /// No checkout notification.
        /// </summary>
        None = 0, /* GIT_CHECKOUT_NOTIFY_NONE */

        /// <summary>
        /// Notify on conflicting paths.
        /// </summary>
        Conflict = (1 << 0), /* GIT_CHECKOUT_NOTIFY_CONFLICT */

        /// <summary>
        /// Notify about dirty files. These are files that do not need
        /// an update, but no longer match the baseline.
        /// </summary>
        Dirty = (1 << 1), /* GIT_CHECKOUT_NOTIFY_DIRTY */

        /// <summary>
        /// Notify for files that will be updated.
        /// </summary>
        Updated = (1 << 2), /* GIT_CHECKOUT_NOTIFY_UPDATED */

        /// <summary>
        /// Notify for untracked files.
        /// </summary>
        Untracked = (1 << 3), /* GIT_CHECKOUT_NOTIFY_UNTRACKED */

        /// <summary>
        /// Notify about ignored file.
        /// </summary>
        Ignored = (1 << 4), /* GIT_CHECKOUT_NOTIFY_IGNORED */
    }

    /// <summary>
    /// Collection of parameters controlling Checkout behavior.
    /// </summary>
    public sealed class CheckoutOptions : IConvertableToGitCheckoutOpts
    {
        /// <summary>
        /// Options controlling checkout behavior.
        /// </summary>
        public CheckoutModifiers CheckoutModifiers { get; set; }

        /// <summary>
        /// The flags specifying what conditions are
        /// reported through the OnCheckoutNotify delegate.
        /// </summary>
        public CheckoutNotifyFlags CheckoutNotifyFlags { get; set; }

        /// <summary>
        /// Delegate to be called during checkout for files that match
        /// desired filter specified with the NotifyFlags property.
        /// </summary>
        public CheckoutNotifyHandler OnCheckoutNotify { get; set; }

        /// Delegate through which checkout will notify callers of
        /// certain conditions. The conditions that are reported is
        /// controlled with the CheckoutNotifyFlags property.
        public CheckoutProgressHandler OnCheckoutProgress { get; set; }

        CheckoutStrategy IConvertableToGitCheckoutOpts.CheckoutStrategy
        {
            get
            {
                return CheckoutModifiers.HasFlag(CheckoutModifiers.Force)
                    ? CheckoutStrategy.GIT_CHECKOUT_FORCE
                    : CheckoutStrategy.GIT_CHECKOUT_SAFE;
            }
        }

        /// <summary>
        /// Generate a <see cref="CheckoutCallbacks"/> object with the delegates
        /// hooked up to the native callbacks.
        /// </summary>
        /// <returns></returns>
        CheckoutCallbacks IConvertableToGitCheckoutOpts.GenerateCallbacks()
        {
            return CheckoutCallbacks.From(OnCheckoutProgress, OnCheckoutNotify);
        }
    }

    /// <summary>
    /// Options controlling CherryPick behavior.
    /// </summary>
    public sealed class CherryPickOptions : MergeAndCheckoutOptionsBase
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CherryPickOptions"/> class.
        /// By default the cherry pick will be committed if there are no conflicts.
        /// </summary>
        public CherryPickOptions()
        { }

        /// <summary>
        /// When cherry picking a merge commit, the parent number to consider as
        /// mainline, starting from offset 1.
        /// <para>
        ///  As a merge commit has multiple parents, cherry picking a merge commit
        ///  will take only the changes relative to the given parent.  The parent
        ///  to consider changes based on is called the mainline, and must be
        ///  specified by its number (i.e. offset).
        /// </para>
        /// </summary>
        public int Mainline { get; set; }
    }

    /// <summary>
    /// Class to report the result of a cherry picked.
    /// </summary>
    public class CherryPickResult
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected CherryPickResult()
        { }

        internal CherryPickResult(CherryPickStatus status, Commit commit = null)
        {
            Commit = commit;
            Status = status;
        }

        /// <summary>
        /// The resulting commit of the cherry pick.
        /// <para>
        ///   This will return <code>null</code> if the cherry pick was not committed.
        ///     This can happen if:
        ///       1) The cherry pick resulted in conflicts.
        ///       2) The option to not commit on success is set.
        ///   </para>
        /// </summary>
        public virtual Commit Commit { get; private set; }

        /// <summary>
        /// The status of the cherry pick.
        /// </summary>
        public virtual CherryPickStatus Status { get; private set; }
    }

    /// <summary>
    /// The status of what happened as a result of a cherry-pick.
    /// </summary>
    public enum CherryPickStatus
    {
        /// <summary>
        /// The commit was successfully cherry picked.
        /// </summary>
        CherryPicked,

        /// <summary>
        /// The cherry pick resulted in conflicts.
        /// </summary>
        Conflicts
    }

    /// <summary>
    /// Options to define clone behaviour
    /// </summary>
    public sealed class CloneOptions : IConvertableToGitCheckoutOpts
    {
        /// <summary>
        /// Creates default <see cref="CloneOptions"/> for a non-bare clone
        /// </summary>
        public CloneOptions()
        {
            Checkout = true;
        }

        /// <summary>
        /// Commit depth to check out.
        /// </summary>
        public int Depth = 0;

        /// <summary>
        /// True will result in a bare clone, false a full clone.
        /// </summary>
        public bool IsBare { get; set; }

        /// <summary>
        /// If true, the origin's HEAD will be checked out. This only applies
        /// to non-bare repositories.
        /// </summary>
        public bool Checkout { get; set; }

        /// <summary>
        /// The name of the branch to checkout. When unspecified the
        /// remote's default branch will be used instead.
        /// </summary>
        public string BranchName { get; set; }

        /// <summary>
        /// Recursively clone submodules.
        /// </summary>
        public bool RecurseSubmodules { get; set; }

        /// <summary>
        /// Handler for checkout progress information.
        /// </summary>
        public CheckoutProgressHandler OnCheckoutProgress { get; set; }

        /// <summary>
        /// Gets or sets the fetch options.
        /// </summary>
        public FetchOptions FetchOptions = new FetchOptions();

        #region IConvertableToGitCheckoutOpts

        CheckoutCallbacks IConvertableToGitCheckoutOpts.GenerateCallbacks()
        {
            return CheckoutCallbacks.From(OnCheckoutProgress, null);
        }

        CheckoutStrategy IConvertableToGitCheckoutOpts.CheckoutStrategy
        {
            get
            {
                return this.Checkout
                    ? CheckoutStrategy.GIT_CHECKOUT_SAFE
                    : CheckoutStrategy.GIT_CHECKOUT_NONE;
            }
        }

        CheckoutNotifyFlags IConvertableToGitCheckoutOpts.CheckoutNotifyFlags
        {
            get { return CheckoutNotifyFlags.None; }
        }

        #endregion
    }

    public static partial class Commands
    {
        /// <summary>
        /// Checkout the specified <see cref="Branch"/>, reference or SHA.
        /// <para>
        ///   If the committishOrBranchSpec parameter resolves to a branch name, then the checked out HEAD will
        ///   will point to the branch. Otherwise, the HEAD will be detached, pointing at the commit sha.
        /// </para>
        /// </summary>
        /// <param name="repository">The repository to act on</param>
        /// <param name="committishOrBranchSpec">A revparse spec for the commit or branch to checkout.</param>
        /// <returns>The <see cref="Branch"/> that was checked out.</returns>
        public static Branch Checkout(IRepository repository, string committishOrBranchSpec)
        {
            return Checkout(repository, committishOrBranchSpec, new CheckoutOptions());
        }

        /// <summary>
        /// Checkout the specified <see cref="Branch"/>, reference or SHA.
        /// <para>
        ///   If the committishOrBranchSpec parameter resolves to a branch name, then the checked out HEAD will
        ///   will point to the branch. Otherwise, the HEAD will be detached, pointing at the commit sha.
        /// </para>
        /// </summary>
        /// <param name="repository">The repository to act on</param>
        /// <param name="committishOrBranchSpec">A revparse spec for the commit or branch to checkout.</param>
        /// <param name="options"><see cref="CheckoutOptions"/> controlling checkout behavior.</param>
        /// <returns>The <see cref="Branch"/> that was checked out.</returns>
        public static Branch Checkout(IRepository repository, string committishOrBranchSpec, CheckoutOptions options)
        {
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNullOrEmptyString(committishOrBranchSpec, "committishOrBranchSpec");
            Ensure.ArgumentNotNull(options, "options");

            Reference reference = null;
            GitObject obj = null;
            Branch branch = null;

            try
            {
                repository.RevParse(committishOrBranchSpec, out reference, out obj);
            }
            catch (NotFoundException)
            {
                // If committishOrBranchSpec is not a local branch but matches a tracking branch
                // in exactly one remote, use it. This is the "git checkout" command's default behavior.
                // https://git-scm.com/docs/git-checkout#Documentation/git-checkout.txt-emgitcheckoutemltbranchgt
                var remoteBranches = repository.Network.Remotes
                    .SelectMany(r => repository.Branches.Where(b =>
                        b.IsRemote &&
                        b.CanonicalName == "refs/remotes/" + r.Name + "/" + committishOrBranchSpec))
                    .ToList();

                if (remoteBranches.Count == 1)
                {
                    branch = repository.CreateBranch(committishOrBranchSpec, remoteBranches[0].Tip);
                    repository.Branches.Update(branch, b => b.TrackedBranch = remoteBranches[0].CanonicalName);

                    return Checkout(repository, branch, options);
                }

                if (remoteBranches.Count > 1)
                {
                    throw new AmbiguousSpecificationException("'"+committishOrBranchSpec+"' matched multiple ("+remoteBranches.Count+") remote tracking branches");
                }

                throw;
            }

            if (reference != null && reference.IsLocalBranch)
            {
                branch = repository.Branches[reference.CanonicalName];
                return Checkout(repository, branch, options);
            }

            Commit commit = obj.Peel<Commit>(true);
            Checkout(repository, commit.Tree, options, committishOrBranchSpec);

            return repository.Head;
        }

        /// <summary>
        /// Checkout the tip commit of the specified <see cref="Branch"/> object. If this commit is the
        /// current tip of the branch, will checkout the named branch. Otherwise, will checkout the tip commit
        /// as a detached HEAD.
        /// </summary>
        /// <param name="repository">The repository to act on</param>
        /// <param name="branch">The <see cref="Branch"/> to check out.</param>
        /// <returns>The <see cref="Branch"/> that was checked out.</returns>
        public static Branch Checkout(IRepository repository, Branch branch)
        {
            return Checkout(repository, branch, new CheckoutOptions());
        }

        /// <summary>
        /// Checkout the tip commit of the specified <see cref="Branch"/> object. If this commit is the
        /// current tip of the branch, will checkout the named branch. Otherwise, will checkout the tip commit
        /// as a detached HEAD.
        /// </summary>
        /// <param name="repository">The repository to act on</param>
        /// <param name="branch">The <see cref="Branch"/> to check out.</param>
        /// <param name="options"><see cref="CheckoutOptions"/> controlling checkout behavior.</param>
        /// <returns>The <see cref="Branch"/> that was checked out.</returns>
        public static Branch Checkout(IRepository repository, Branch branch, CheckoutOptions options)
        {
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNull(branch, "branch");
            Ensure.ArgumentNotNull(options, "options");

            // Make sure this is not an unborn branch.
            if (branch.Tip == null)
            {
                throw new UnbornBranchException("The tip of branch '{0}' is null. There's nothing to checkout.",
                    branch.FriendlyName);
            }

            if (!branch.IsRemote && !(branch is DetachedHead) &&
                string.Equals(repository.Refs[branch.CanonicalName].TargetIdentifier, branch.Tip.Id.Sha,
                    StringComparison.OrdinalIgnoreCase))
            {
                Checkout(repository, branch.Tip.Tree, options, branch.CanonicalName);
            }
            else
            {
                Checkout(repository, branch.Tip.Tree, options, branch.Tip.Id.Sha);
            }

            return repository.Head;
        }

        /// <summary>
        /// Checkout the specified <see cref="LibGit2Sharp.Commit"/>.
        /// <para>
        ///   Will detach the HEAD and make it point to this commit sha.
        /// </para>
        /// </summary>
        /// <param name="repository">The repository to act on</param>
        /// <param name="commit">The <see cref="LibGit2Sharp.Commit"/> to check out.</param>
        /// <returns>The <see cref="Branch"/> that was checked out.</returns>
        public static Branch Checkout(IRepository repository, Commit commit)
        {
            return Checkout(repository, commit, new CheckoutOptions());
        }

        /// <summary>
        /// Checkout the specified <see cref="LibGit2Sharp.Commit"/>.
        /// <para>
        ///   Will detach the HEAD and make it point to this commit sha.
        /// </para>
        /// </summary>
        /// <param name="repository">The repository to act on</param>
        /// <param name="commit">The <see cref="LibGit2Sharp.Commit"/> to check out.</param>
        /// <param name="options"><see cref="CheckoutOptions"/> controlling checkout behavior.</param>
        /// <returns>The <see cref="Branch"/> that was checked out.</returns>
        public static Branch Checkout(IRepository repository, Commit commit, CheckoutOptions options)
        {
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNull(commit, "commit");
            Ensure.ArgumentNotNull(options, "options");

            Checkout(repository, commit.Tree, options, commit.Id.Sha);

            return repository.Head;
        }

        /// <summary>
        /// Internal implementation of Checkout that expects the ID of the checkout target
        /// to already be in the form of a canonical branch name or a commit ID.
        /// </summary>
        /// <param name="repository">The repository to act on</param>
        /// <param name="tree">The <see cref="Tree"/> to checkout.</param>
        /// <param name="checkoutOptions"><see cref="CheckoutOptions"/> controlling checkout behavior.</param>
        /// <param name="refLogHeadSpec">The spec which will be written as target in the reflog.</param>
        public static void Checkout(IRepository repository, Tree tree, CheckoutOptions checkoutOptions, string refLogHeadSpec)
        {
            repository.Checkout(tree, null, checkoutOptions);

            repository.Refs.MoveHeadTarget(refLogHeadSpec);
        }

    }

    /// <summary>
    /// Class to serve as namespacing for the command-emulating methods
    /// </summary>
    public static partial class Commands
    {
        private static RemoteHandle RemoteFromNameOrUrl(RepositoryHandle repoHandle, string remote)
        {
            RemoteHandle handle = null;
            handle = Proxy.git_remote_lookup(repoHandle, remote, false);

            // If that wasn't the name of a remote, let's use it as a url
            if (handle == null)
            {
                handle = Proxy.git_remote_create_anonymous(repoHandle, remote);
            }

            return handle;
        }

        /// <summary>
        /// Perform a fetch
        /// </summary>
        /// <param name="repository">The repository in which to fetch.</param>
        /// <param name="remote">The remote to fetch from. Either as a remote name or a URL</param>
        /// <param name="options">Fetch options.</param>
        /// <param name="logMessage">Log message for any ref updates.</param>
        /// <param name="refspecs">List of refspecs to apply as active.</param>
        public static void Fetch(Repository repository, string remote, IEnumerable<string> refspecs, FetchOptions options, string logMessage)
        {
            Ensure.ArgumentNotNull(remote, "remote");

            options = options ?? new FetchOptions();
            using (var remoteHandle = RemoteFromNameOrUrl(repository.Handle, remote))
            using (var fetchOptionsWrapper = new GitFetchOptionsWrapper())
            {

                var callbacks = new RemoteCallbacks(options);
                GitRemoteCallbacks gitCallbacks = callbacks.GenerateCallbacks();

                // It is OK to pass the reference to the GitCallbacks directly here because libgit2 makes a copy of
                // the data in the git_remote_callbacks structure. If, in the future, libgit2 changes its implementation
                // to store a reference to the git_remote_callbacks structure this would introduce a subtle bug
                // where the managed layer could move the git_remote_callbacks to a different location in memory,
                // but libgit2 would still reference the old address.
                //
                // Also, if GitRemoteCallbacks were a class instead of a struct, we would need to guard against
                // GC occuring in between setting the remote callbacks and actual usage in one of the functions afterwords.
                var fetchOptions = fetchOptionsWrapper.Options;
                fetchOptions.RemoteCallbacks = gitCallbacks;
                fetchOptions.download_tags = Proxy.git_remote_autotag(remoteHandle);

                if (options.TagFetchMode.HasValue)
                {
                    fetchOptions.download_tags = options.TagFetchMode.Value;
                }

                if (options.Prune.HasValue)
                {
                    fetchOptions.Prune = options.Prune.Value ? FetchPruneStrategy.Prune : FetchPruneStrategy.NoPrune;
                }
                else
                {
                    fetchOptions.Prune = FetchPruneStrategy.FromConfigurationOrDefault;
                }

                if (options.CustomHeaders != null && options.CustomHeaders.Length > 0)
                {
                    fetchOptions.CustomHeaders = GitStrArrayManaged.BuildFrom(options.CustomHeaders);
                }

                fetchOptions.ProxyOptions = options.ProxyOptions.CreateGitProxyOptions();

                Proxy.git_remote_fetch(remoteHandle, refspecs, fetchOptions, logMessage);
            }

        }
    }

    /// <summary>
    /// Fetch changes from the configured upstream remote and branch into the branch pointed at by HEAD.
    /// </summary>
    public static partial class Commands
    {
        /// <summary>
        /// Fetch changes from the configured upstream remote and branch into the branch pointed at by HEAD.
        /// </summary>
        /// <param name="repository">The repository.</param>
        /// <param name="merger">The signature to use for the merge.</param>
        /// <param name="options">The options for fetch and merging.</param>
        public static MergeResult Pull(Repository repository, Signature merger, PullOptions options)
        {
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNull(merger, "merger");

            options = options ?? new PullOptions();
            Branch currentBranch = repository.Head;

            if (!currentBranch.IsTracking)
            {
                throw new LibGit2SharpException("There is no tracking information for the current branch.");
            }

            if (currentBranch.RemoteName == null)
            {
                throw new LibGit2SharpException("No upstream remote for the current branch.");
            }

            Commands.Fetch(repository, currentBranch.RemoteName, new string[0], options.FetchOptions, null);
            return repository.MergeFetchedRefs(merger, options.MergeOptions);
        }
    }

    public static partial class Commands
    {

        /// <summary>
        /// Removes a file from the staging area, and optionally removes it from the working directory as well.
        /// <para>
        ///   If the file has already been deleted from the working directory, this method will only deal
        ///   with promoting the removal to the staging area.
        /// </para>
        /// <para>
        ///   The default behavior is to remove the file from the working directory as well.
        /// </para>
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name="path">The path of the file within the working directory.</param>
        public static void Remove(IRepository repository, string path)
        {
            Remove(repository, path, true, null);
        }

        /// <summary>
        /// Removes a file from the staging area, and optionally removes it from the working directory as well.
        /// <para>
        ///   If the file has already been deleted from the working directory, this method will only deal
        ///   with promoting the removal to the staging area.
        /// </para>
        /// <para>
        ///   The default behavior is to remove the file from the working directory as well.
        /// </para>
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name="path">The path of the file within the working directory.</param>
        /// <param name="removeFromWorkingDirectory">True to remove the file from the working directory, False otherwise.</param>
        public static void Remove(IRepository repository, string path, bool removeFromWorkingDirectory)
        {
            Remove(repository, path, removeFromWorkingDirectory, null);
        }

        /// <summary>
        /// Removes a file from the staging area, and optionally removes it from the working directory as well.
        /// <para>
        ///   If the file has already been deleted from the working directory, this method will only deal
        ///   with promoting the removal to the staging area.
        /// </para>
        /// <para>
        ///   The default behavior is to remove the file from the working directory as well.
        /// </para>
        /// <para>
        ///   When not passing a <paramref name="explicitPathsOptions"/>, the passed path will be treated as
        ///   a pathspec. You can for example use it to pass the relative path to a folder inside the working directory,
        ///   so that all files beneath this folders, and the folder itself, will be removed.
        /// </para>
        /// </summary>
        /// <param name="repository">The repository in which to operate</param>
        /// <param name="path">The path of the file within the working directory.</param>
        /// <param name="removeFromWorkingDirectory">True to remove the file from the working directory, False otherwise.</param>
        /// <param name="explicitPathsOptions">
        /// The passed <paramref name="path"/> will be treated as an explicit path.
        /// Use these options to determine how unmatched explicit paths should be handled.
        /// </param>
        public static void Remove(IRepository repository, string path, bool removeFromWorkingDirectory, ExplicitPathsOptions explicitPathsOptions)
        {
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNull(path, "path");

            Remove(repository, new[] { path }, removeFromWorkingDirectory, explicitPathsOptions);
        }

        /// <summary>
        /// Removes a collection of fileS from the staging, and optionally removes them from the working directory as well.
        /// <para>
        ///   If a file has already been deleted from the working directory, this method will only deal
        ///   with promoting the removal to the staging area.
        /// </para>
        /// <para>
        ///   The default behavior is to remove the files from the working directory as well.
        /// </para>
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name="paths">The collection of paths of the files within the working directory.</param>
        public static void Remove(IRepository repository, IEnumerable<string> paths)
        {
            Remove(repository, paths, true, null);
        }

        /// <summary>
        /// Removes a collection of fileS from the staging, and optionally removes them from the working directory as well.
        /// <para>
        ///   If a file has already been deleted from the working directory, this method will only deal
        ///   with promoting the removal to the staging area.
        /// </para>
        /// <para>
        ///   The default behavior is to remove the files from the working directory as well.
        /// </para>
        /// <para>
        ///   When not passing a <paramref name="explicitPathsOptions"/>, the passed paths will be treated as
        ///   a pathspec. You can for example use it to pass the relative paths to folders inside the working directory,
        ///   so that all files beneath these folders, and the folders themselves, will be removed.
        /// </para>
        /// </summary>
        /// <param name="repository">The repository in which to operate</param>
        /// <param name="paths">The collection of paths of the files within the working directory.</param>
        /// <param name="removeFromWorkingDirectory">True to remove the files from the working directory, False otherwise.</param>
        /// <param name="explicitPathsOptions">
        /// The passed <paramref name="paths"/> will be treated as explicit paths.
        /// Use these options to determine how unmatched explicit paths should be handled.
        /// </param>
        public static void Remove(IRepository repository, IEnumerable<string> paths, bool removeFromWorkingDirectory, ExplicitPathsOptions explicitPathsOptions)
        {
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNullOrEmptyEnumerable<string>(paths, "paths");

            var pathsToDelete = paths.Where(p => Directory.Exists(Path.Combine(repository.Info.WorkingDirectory, p))).ToList();
            var notConflictedPaths = new List<string>();
            var index = repository.Index;

            foreach (var path in paths)
            {
                Ensure.ArgumentNotNullOrEmptyString(path, "path");

                var conflict = index.Conflicts[path];

                if (conflict != null)
                {
                    index.Remove(path);
                    pathsToDelete.Add(path);
                }
                else
                {
                    notConflictedPaths.Add(path);
                }
            }

            // Make sure status will see the changes from before this
            index.Write();

            if (notConflictedPaths.Count > 0)
            {
                pathsToDelete.AddRange(RemoveStagedItems(repository, notConflictedPaths, removeFromWorkingDirectory, explicitPathsOptions));
            }

            if (removeFromWorkingDirectory)
            {
                RemoveFilesAndFolders(repository, pathsToDelete);
            }

            index.Write();
        }

        private static void RemoveFilesAndFolders(IRepository repository, IEnumerable<string> pathsList)
        {
            string wd = repository.Info.WorkingDirectory;

            foreach (string path in pathsList)
            {
                string fileName = Path.Combine(wd, path);

                if (Directory.Exists(fileName))
                {
                    Directory.Delete(fileName, true);
                    continue;
                }

                if (!File.Exists(fileName))
                {
                    continue;
                }

                File.Delete(fileName);
            }
        }

        private static IEnumerable<string> RemoveStagedItems(IRepository repository, IEnumerable<string> paths, bool removeFromWorkingDirectory = true, ExplicitPathsOptions explicitPathsOptions = null)
        {
            var removed = new List<string>();
            using (var changes = repository.Diff.Compare<TreeChanges>(DiffModifiers.IncludeUnmodified | DiffModifiers.IncludeUntracked, paths, explicitPathsOptions))
            {
                var index = repository.Index;

                foreach (var treeEntryChanges in changes)
                {
                    var status = repository.RetrieveStatus(treeEntryChanges.Path);

                    switch (treeEntryChanges.Status)
                    {
                        case ChangeKind.Added:
                        case ChangeKind.Deleted:
                            removed.Add(treeEntryChanges.Path);
                            index.Remove(treeEntryChanges.Path);
                            break;

                        case ChangeKind.Unmodified:
                            if (removeFromWorkingDirectory && (
                                status.HasFlag(FileStatus.ModifiedInIndex) ||
                                status.HasFlag(FileStatus.NewInIndex)))
                            {
                                throw new RemoveFromIndexException("Unable to remove file '{0}', as it has changes staged in the index. You can call the Remove() method with removeFromWorkingDirectory=false if you want to remove it from the index only.",
                                    treeEntryChanges.Path);
                            }
                            removed.Add(treeEntryChanges.Path);
                            index.Remove(treeEntryChanges.Path);
                            continue;

                        case ChangeKind.Modified:
                            if (status.HasFlag(FileStatus.ModifiedInWorkdir) && status.HasFlag(FileStatus.ModifiedInIndex))
                            {
                                throw new RemoveFromIndexException("Unable to remove file '{0}', as it has staged content different from both the working directory and the HEAD.",
                                    treeEntryChanges.Path);
                            }
                            if (removeFromWorkingDirectory)
                            {
                                throw new RemoveFromIndexException("Unable to remove file '{0}', as it has local modifications. You can call the Remove() method with removeFromWorkingDirectory=false if you want to remove it from the index only.",
                                    treeEntryChanges.Path);
                            }
                            removed.Add(treeEntryChanges.Path);
                            index.Remove(treeEntryChanges.Path);
                            continue;

                        default:
                            throw new RemoveFromIndexException("Unable to remove file '{0}'. Its current status is '{1}'.",
                                treeEntryChanges.Path,
                                treeEntryChanges.Status);
                    }
                }

                index.Write();

                return removed;
            }
        }
    }

    public static partial class Commands
    {
        /// <summary>
        /// Promotes to the staging area the latest modifications of a file in the working directory (addition, updation or removal).
        ///
        /// If this path is ignored by configuration then it will not be staged unless <see cref="StageOptions.IncludeIgnored"/> is unset.
        /// </summary>
        /// <param name="repository">The repository in which to act</param>
        /// <param name="path">The path of the file within the working directory.</param>
        public static void Stage(IRepository repository, string path)
        {
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNull(path, "path");

            Stage(repository, new[] { path }, null);
        }

        /// <summary>
        /// Promotes to the staging area the latest modifications of a file in the working directory (addition, updation or removal).
        ///
        /// If this path is ignored by configuration then it will not be staged unless <see cref="StageOptions.IncludeIgnored"/> is unset.
        /// </summary>
        /// <param name="repository">The repository in which to act</param>
        /// <param name="path">The path of the file within the working directory.</param>
        /// <param name="stageOptions">Determines how paths will be staged.</param>
        public static void Stage(IRepository repository, string path, StageOptions stageOptions)
        {
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNull(path, "path");

            Stage(repository, new[] { path }, stageOptions);
        }

        /// <summary>
        /// Promotes to the staging area the latest modifications of a collection of files in the working directory (addition, updation or removal).
        ///
        /// Any paths (even those listed explicitly) that are ignored by configuration will not be staged unless <see cref="StageOptions.IncludeIgnored"/> is unset.
        /// </summary>
        /// <param name="repository">The repository in which to act</param>
        /// <param name="paths">The collection of paths of the files within the working directory.</param>
        public static void Stage(IRepository repository, IEnumerable<string> paths)
        {
            Stage(repository, paths, null);
        }

        /// <summary>
        /// Promotes to the staging area the latest modifications of a collection of files in the working directory (addition, updation or removal).
        ///
        /// Any paths (even those listed explicitly) that are ignored by configuration will not be staged unless <see cref="StageOptions.IncludeIgnored"/> is unset.
        /// </summary>
        /// <param name="repository">The repository in which to act</param>
        /// <param name="paths">The collection of paths of the files within the working directory.</param>
        /// <param name="stageOptions">Determines how paths will be staged.</param>
        public static void Stage(IRepository repository, IEnumerable<string> paths, StageOptions stageOptions)
        {
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNull(paths, "paths");

            DiffModifiers diffModifiers = DiffModifiers.IncludeUntracked;
            ExplicitPathsOptions explicitPathsOptions = stageOptions != null ? stageOptions.ExplicitPathsOptions : null;

            if (stageOptions != null && stageOptions.IncludeIgnored)
            {
                diffModifiers |= DiffModifiers.IncludeIgnored;
            }

            using (var changes = repository.Diff.Compare<TreeChanges>(diffModifiers, paths, explicitPathsOptions,
                new CompareOptions { Similarity = SimilarityOptions.None }))
            {
                var unexpectedTypesOfChanges = changes
                    .Where(
                        tec => tec.Status != ChangeKind.Added &&
                        tec.Status != ChangeKind.Modified &&
                        tec.Status != ChangeKind.Conflicted &&
                        tec.Status != ChangeKind.Unmodified &&
                        tec.Status != ChangeKind.Deleted).ToList();

                if (unexpectedTypesOfChanges.Count > 0)
                {
                    throw new InvalidOperationException(
                        string.Format(CultureInfo.InvariantCulture,
                            "Entry '{0}' bears an unexpected ChangeKind '{1}'",
                            unexpectedTypesOfChanges[0].Path, unexpectedTypesOfChanges[0].Status));
                }

                /* Remove files from the index that don't exist on disk */
                foreach (TreeEntryChanges treeEntryChanges in changes)
                {
                    switch (treeEntryChanges.Status)
                    {
                        case ChangeKind.Conflicted:
                            if (!treeEntryChanges.Exists)
                            {
                                repository.Index.Remove(treeEntryChanges.Path);
                            }
                            break;

                        case ChangeKind.Deleted:
                            repository.Index.Remove(treeEntryChanges.Path);
                            break;

                        default:
                            continue;
                    }
                }

                foreach (TreeEntryChanges treeEntryChanges in changes)
                {
                    switch (treeEntryChanges.Status)
                    {
                        case ChangeKind.Added:
                        case ChangeKind.Modified:
                            repository.Index.Add(treeEntryChanges.Path);
                            break;

                        case ChangeKind.Conflicted:
                            if (treeEntryChanges.Exists)
                            {
                                repository.Index.Add(treeEntryChanges.Path);
                            }
                            break;

                        default:
                            continue;
                    }
                }

                repository.Index.Write();
            }
        }

        /// <summary>
        /// Removes from the staging area all the modifications of a file since the latest commit (addition, updation or removal).
        /// </summary>
        /// <param name="repository">The repository in which to act</param>
        /// <param name="path">The path of the file within the working directory.</param>
        public static void Unstage(IRepository repository, string path)
        {
            Unstage(repository, path, null);
        }

        /// <summary>
        /// Removes from the staging area all the modifications of a file since the latest commit (addition, updation or removal).
        /// </summary>
        /// <param name="repository">The repository in which to act</param>
        /// <param name="path">The path of the file within the working directory.</param>
        /// <param name="explicitPathsOptions">
        /// The passed <paramref name="path"/> will be treated as explicit paths.
        /// Use these options to determine how unmatched explicit paths should be handled.
        /// </param>
        public static void Unstage(IRepository repository, string path, ExplicitPathsOptions explicitPathsOptions)
        {
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNull(path, "path");

            Unstage(repository, new[] { path }, explicitPathsOptions);
        }

        /// <summary>
        /// Removes from the staging area all the modifications of a collection of file since the latest commit (addition, updation or removal).
        /// </summary>
        /// <param name="repository">The repository in which to act</param>
        /// <param name="paths">The collection of paths of the files within the working directory.</param>
        public static void Unstage(IRepository repository, IEnumerable<string> paths)
        {
            Unstage(repository, paths, null);
        }

        /// <summary>
        /// Removes from the staging area all the modifications of a collection of file since the latest commit (addition, updation or removal).
        /// </summary>
        /// <param name="repository">The repository in which to act</param>
        /// <param name="paths">The collection of paths of the files within the working directory.</param>
        /// <param name="explicitPathsOptions">
        /// The passed <paramref name="paths"/> will be treated as explicit paths.
        /// Use these options to determine how unmatched explicit paths should be handled.
        /// </param>
        public static void Unstage(IRepository repository, IEnumerable<string> paths, ExplicitPathsOptions explicitPathsOptions)
        {
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNull(paths, "paths");

            if (repository.Info.IsHeadUnborn)
            {
                using (var changes = repository.Diff.Compare<TreeChanges>(null, DiffTargets.Index, paths, explicitPathsOptions, new CompareOptions { Similarity = SimilarityOptions.None }))
                    repository.Index.Replace(changes);
            }
            else
            {
                repository.Index.Replace(repository.Head.Tip, paths, explicitPathsOptions);
            }

            repository.Index.Write();
        }

        /// <summary>
        /// Moves and/or renames a file in the working directory and promotes the change to the staging area.
        /// </summary>
        /// <param name="repository">The repository to act on</param>
        /// <param name="sourcePath">The path of the file within the working directory which has to be moved/renamed.</param>
        /// <param name="destinationPath">The target path of the file within the working directory.</param>
        public static void Move(IRepository repository, string sourcePath, string destinationPath)
        {
            Move(repository, new[] { sourcePath }, new[] { destinationPath });
        }

        /// <summary>
        /// Moves and/or renames a collection of files in the working directory and promotes the changes to the staging area.
        /// </summary>
        /// <param name="repository">The repository to act on</param>
        /// <param name="sourcePaths">The paths of the files within the working directory which have to be moved/renamed.</param>
        /// <param name="destinationPaths">The target paths of the files within the working directory.</param>
        public static void Move(IRepository repository, IEnumerable<string> sourcePaths, IEnumerable<string> destinationPaths)
        {
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNull(sourcePaths, "sourcePaths");
            Ensure.ArgumentNotNull(destinationPaths, "destinationPaths");

            //TODO: Move() should support following use cases:
            // - Moving a file under a directory ('file' and 'dir' -> 'dir/file')
            // - Moving a directory (and its content) under another directory ('dir1' and 'dir2' -> 'dir2/dir1/*')

            //TODO: Move() should throw when:
            // - Moving a directory under a file

            IDictionary<Tuple<string, FileStatus>, Tuple<string, FileStatus>> batch = PrepareBatch(repository, sourcePaths, destinationPaths);

            if (batch.Count == 0)
            {
                throw new ArgumentNullException("sourcePaths");
            }

            foreach (KeyValuePair<Tuple<string, FileStatus>, Tuple<string, FileStatus>> keyValuePair in batch)
            {
                string sourcePath = keyValuePair.Key.Item1;
                string destPath = keyValuePair.Value.Item1;

                if (Directory.Exists(sourcePath) || Directory.Exists(destPath))
                {
                    throw new NotImplementedException();
                }

                FileStatus sourceStatus = keyValuePair.Key.Item2;
                if (sourceStatus.HasAny(new Enum[] { FileStatus.Nonexistent, FileStatus.DeletedFromIndex, FileStatus.NewInWorkdir, FileStatus.DeletedFromWorkdir }))
                {
                    throw new LibGit2SharpException("Unable to move file '{0}'. Its current status is '{1}'.",
                        sourcePath,
                        sourceStatus);
                }

                FileStatus desStatus = keyValuePair.Value.Item2;
                if (desStatus.HasAny(new Enum[] { FileStatus.Nonexistent, FileStatus.DeletedFromWorkdir }))
                {
                    continue;
                }

                throw new LibGit2SharpException("Unable to overwrite file '{0}'. Its current status is '{1}'.",
                    destPath,
                    desStatus);
            }

            string wd = repository.Info.WorkingDirectory;
            var index = repository.Index;
            foreach (KeyValuePair<Tuple<string, FileStatus>, Tuple<string, FileStatus>> keyValuePair in batch)
            {
                string from = keyValuePair.Key.Item1;
                string to = keyValuePair.Value.Item1;

                index.Remove(from);
                File.Move(Path.Combine(wd, from), Path.Combine(wd, to));
                index.Add(to);
            }

            index.Write();
        }

        private static bool Enumerate(IEnumerator<string> leftEnum, IEnumerator<string> rightEnum)
        {
            bool isLeftEoF = leftEnum.MoveNext();
            bool isRightEoF = rightEnum.MoveNext();

            if (isLeftEoF == isRightEoF)
            {
                return isLeftEoF;
            }

            throw new ArgumentException("The collection of paths are of different lengths.");
        }

        private static IDictionary<Tuple<string, FileStatus>, Tuple<string, FileStatus>> PrepareBatch(IRepository repository, IEnumerable<string> leftPaths, IEnumerable<string> rightPaths)
        {
            IDictionary<Tuple<string, FileStatus>, Tuple<string, FileStatus>> dic = new Dictionary<Tuple<string, FileStatus>, Tuple<string, FileStatus>>();

            IEnumerator<string> leftEnum = leftPaths.GetEnumerator();
            IEnumerator<string> rightEnum = rightPaths.GetEnumerator();

            while (Enumerate(leftEnum, rightEnum))
            {
                Tuple<string, FileStatus> from = BuildFrom(repository, leftEnum.Current);
                Tuple<string, FileStatus> to = BuildFrom(repository, rightEnum.Current);
                dic.Add(from, to);
            }

            return dic;
        }

        private static Tuple<string, FileStatus> BuildFrom(IRepository repository, string path)
        {
            string relativePath = repository.BuildRelativePathFrom(path);
            return new Tuple<string, FileStatus>(relativePath, repository.RetrieveStatus(relativePath));
        }
    }

    /// <summary>
    /// A Commit
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class Commit : GitObject
    {
        private readonly GitObjectLazyGroup group1;
        private readonly GitObjectLazyGroup group2;
        private readonly ILazy<Tree> lazyTree;
        private readonly ILazy<Signature> lazyAuthor;
        private readonly ILazy<Signature> lazyCommitter;
        private readonly ILazy<string> lazyMessage;
        private readonly ILazy<string> lazyMessageShort;
        private readonly ILazy<string> lazyEncoding;

        private readonly ParentsCollection parents;
        private readonly Lazy<IEnumerable<Note>> lazyNotes;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Commit()
        { }

        internal Commit(Repository repo, ObjectId id)
            : base(repo, id)
        {
            lazyTree = GitObjectLazyGroup.Singleton(this.repo, id, obj => new Tree(this.repo, Proxy.git_commit_tree_id(obj), null));

            group1 = new GitObjectLazyGroup(this.repo, id);
            lazyAuthor = group1.AddLazy(Proxy.git_commit_author);
            lazyCommitter = group1.AddLazy(Proxy.git_commit_committer);
            group2 = new GitObjectLazyGroup(this.repo, id);
            lazyMessage = group2.AddLazy(Proxy.git_commit_message);
            lazyMessageShort = group2.AddLazy(Proxy.git_commit_summary);
            lazyEncoding = group2.AddLazy(RetrieveEncodingOf);

            lazyNotes = new Lazy<IEnumerable<Note>>(() => RetrieveNotesOfCommit(id).ToList());

            parents = new ParentsCollection(repo, id);
        }

        /// <summary>
        /// Gets the <see cref="TreeEntry"/> pointed at by the <paramref name="relativePath"/> in the <see cref="Tree"/>.
        /// </summary>
        /// <param name="relativePath">Path to the <see cref="TreeEntry"/> from the tree in this <see cref="Commit"/></param>
        /// <returns><c>null</c> if nothing has been found, the <see cref="TreeEntry"/> otherwise.</returns>
        public virtual TreeEntry this[string relativePath]
        {
            get { return Tree[relativePath]; }
        }

        /// <summary>
        /// Gets the commit message.
        /// </summary>
        public virtual string Message { get { return lazyMessage.Value; } }

        /// <summary>
        /// Gets the short commit message which is usually the first line of the commit.
        /// </summary>
        public virtual string MessageShort { get { return lazyMessageShort.Value; } }

        /// <summary>
        /// Gets the encoding of the message.
        /// </summary>
        public virtual string Encoding { get { return lazyEncoding.Value; } }

        /// <summary>
        /// Gets the author of this commit.
        /// </summary>
        public virtual Signature Author { get { return lazyAuthor.Value; } }

        /// <summary>
        /// Gets the committer.
        /// </summary>
        public virtual Signature Committer { get { return lazyCommitter.Value; } }

        /// <summary>
        /// Gets the Tree associated to this commit.
        /// </summary>
        public virtual Tree Tree { get { return lazyTree.Value; } }

        /// <summary>
        /// Gets the parents of this commit. This property is lazy loaded and can throw an exception if the commit no longer exists in the repo.
        /// </summary>
        public virtual IEnumerable<Commit> Parents { get { return parents; } }

        /// <summary>
        /// Gets the notes of this commit.
        /// </summary>
        public virtual IEnumerable<Note> Notes { get { return lazyNotes.Value; } }

        private IEnumerable<Note> RetrieveNotesOfCommit(ObjectId oid)
        {
            return repo.Notes[oid];
        }

        private static string RetrieveEncodingOf(ObjectHandle obj)
        {
            string encoding = Proxy.git_commit_message_encoding(obj);

            return encoding ?? "UTF-8";
        }

        /// <summary>
        /// Prettify a commit message
        /// <para>
        /// Remove comment lines and trailing lines
        /// </para>
        /// </summary>
        /// <returns>The prettified message</returns>
        /// <param name="message">The message to prettify.</param>
        /// <param name="commentChar">Comment character. Lines starting with it will be removed</param>
        public static string PrettifyMessage(string message, char commentChar)
        {
            return Proxy.git_message_prettify(message, commentChar);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0} {1}",
                                     Id.ToString(7),
                                     MessageShort);
            }
        }

        /// <summary>
        /// Extract the signature data from this commit
        /// </summary>
        /// <returns>The signature and the signed data</returns>
        /// <param name="repo">The repository in which the object lives</param>
        /// <param name="id">The commit to extract the signature from</param>
        /// <param name="field">The header field which contains the signature; use null for the default of "gpgsig"</param>
        public static SignatureInfo ExtractSignature(Repository repo, ObjectId id, string field)
        {
            return Proxy.git_commit_extract_signature(repo.Handle, id, field);
        }

        /// <summary>
        /// Extract the signature data from this commit
        /// <para>
        /// The overload uses the default header field "gpgsig"
        /// </para>
        /// </summary>
        /// <returns>The signature and the signed data</returns>
        /// <param name="repo">The repository in which the object lives</param>
        /// <param name="id">The commit to extract the signature from</param>
        public static SignatureInfo ExtractSignature(Repository repo, ObjectId id)
        {
            return Proxy.git_commit_extract_signature(repo.Handle, id, null);
        }

        /// <summary>
        /// Create a commit in-memory
        /// <para>
        /// Prettifing the message includes:
        /// * Removing empty lines from the beginning and end.
        /// * Removing trailing spaces from every line.
        /// * Turning multiple consecutive empty lines between paragraphs into just one empty line.
        /// * Ensuring the commit message ends with a newline.
        /// * Removing every line starting with the <paramref name="commentChar"/>.
        /// </para>
        /// </summary>
        /// <param name="author">The <see cref="Signature"/> of who made the change.</param>
        /// <param name="committer">The <see cref="Signature"/> of who added the change to the repository.</param>
        /// <param name="message">The description of why a change was made to the repository.</param>
        /// <param name="tree">The <see cref="Tree"/> of the <see cref="Commit"/> to be created.</param>
        /// <param name="parents">The parents of the <see cref="Commit"/> to be created.</param>
        /// <param name="prettifyMessage">True to prettify the message, or false to leave it as is.</param>
        /// <param name="commentChar">When non null, lines starting with this character will be stripped if prettifyMessage is true.</param>
        /// <returns>The contents of the commit object.</returns>
        public static string CreateBuffer(Signature author, Signature committer, string message, Tree tree, IEnumerable<Commit> parents, bool prettifyMessage, char? commentChar)
        {
            Ensure.ArgumentNotNull(message, "message");
            Ensure.ArgumentDoesNotContainZeroByte(message, "message");
            Ensure.ArgumentNotNull(author, "author");
            Ensure.ArgumentNotNull(committer, "committer");
            Ensure.ArgumentNotNull(tree, "tree");
            Ensure.ArgumentNotNull(parents, "parents");

            if (prettifyMessage)
            {
                message = Proxy.git_message_prettify(message, commentChar);
            }

            return Proxy.git_commit_create_buffer(tree.repo.Handle, author, committer, message, tree, parents.ToArray());
        }

        private class ParentsCollection : ICollection<Commit>
        {
            private readonly Lazy<ICollection<Commit>> _parents;
            private readonly Lazy<int> _count;

            public ParentsCollection(Repository repo, ObjectId commitId)
            {
                _count = new Lazy<int>(() => Proxy.git_commit_parentcount(repo.Handle, commitId));
                _parents = new Lazy<ICollection<Commit>>(() => RetrieveParentsOfCommit(repo, commitId));
            }

            private ICollection<Commit> RetrieveParentsOfCommit(Repository repo, ObjectId commitId)
            {
                using (var obj = new ObjectSafeWrapper(commitId, repo.Handle))
                {
                    int parentsCount = _count.Value;
                    var parents = new List<Commit>(parentsCount);

                    for (uint i = 0; i < parentsCount; i++)
                    {
                        ObjectId parentCommitId = Proxy.git_commit_parent_id(obj.ObjectPtr, i);
                        parents.Add(new Commit(repo, parentCommitId));
                    }

                    return parents;
                }
            }

            public IEnumerator<Commit> GetEnumerator()
            {
                return _parents.Value.GetEnumerator();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }

            public void Add(Commit item)
            {
                throw new NotSupportedException();
            }

            public void Clear()
            {
                throw new NotSupportedException();
            }

            public bool Contains(Commit item)
            {
                return _parents.Value.Contains(item);
            }

            public void CopyTo(Commit[] array, int arrayIndex)
            {
                _parents.Value.CopyTo(array, arrayIndex);
            }

            public bool Remove(Commit item)
            {
                throw new NotSupportedException();
            }

            public int Count
            {
                get { return _count.Value; }
            }

            public bool IsReadOnly
            {
                get { return true; }
            }
        }
    }

    /// <summary>
    /// Criteria used to filter out and order the commits of the repository when querying its history.
    /// </summary>
    public sealed class CommitFilter
    {
        /// <summary>
        /// Initializes a new instance of <see cref="CommitFilter"/>.
        /// </summary>
        public CommitFilter()
        {
            SortBy = CommitSortStrategies.Time;
            IncludeReachableFrom = "HEAD";
            FirstParentOnly = false;
        }

        /// <summary>
        /// The ordering strategy to use.
        /// <para>
        ///   By default, the commits are shown in reverse chronological order.
        /// </para>
        /// </summary>
        public CommitSortStrategies SortBy { get; set; }

        /// <summary>
        /// A pointer to a commit object or a list of pointers to consider as starting points.
        /// <para>
        ///   Can be either a <see cref="string"/> containing the sha or reference canonical name to use,
        ///   a <see cref="Branch"/>, a <see cref="Reference"/>, a <see cref="Commit"/>, a <see cref="Tag"/>,
        ///   a <see cref="TagAnnotation"/>, an <see cref="ObjectId"/> or even a mixed collection of all of the above.
        ///   By default, the <see cref="Repository.Head"/> will be used as boundary.
        /// </para>
        /// </summary>
        public object IncludeReachableFrom { get; set; }

        internal IList<object> SinceList
        {
            get { return ToList(IncludeReachableFrom); }
        }

        /// <summary>
        /// A pointer to a commit object or a list of pointers which will be excluded (along with ancestors) from the enumeration.
        /// <para>
        ///   Can be either a <see cref="string"/> containing the sha or reference canonical name to use,
        ///   a <see cref="Branch"/>, a <see cref="Reference"/>, a <see cref="Commit"/>, a <see cref="Tag"/>,
        ///   a <see cref="TagAnnotation"/>, an <see cref="ObjectId"/> or even a mixed collection of all of the above.
        /// </para>
        /// </summary>
        public object ExcludeReachableFrom { get; set; }

        internal IList<object> UntilList
        {
            get { return ToList(ExcludeReachableFrom); }
        }

        /// <summary>
        /// Whether to limit the walk to each commit's first parent, instead of all of them
        /// </summary>
        public bool FirstParentOnly { get; set; }

        private static IList<object> ToList(object obj)
        {
            var list = new List<object>();

            if (obj == null)
            {
                return list;
            }

            var types = new[]
                        {
                            typeof(string), typeof(ObjectId),
                            typeof(Commit), typeof(TagAnnotation),
                            typeof(Tag), typeof(Branch), typeof(DetachedHead),
                            typeof(Reference), typeof(DirectReference), typeof(SymbolicReference)
                        };

            if (types.Contains(obj.GetType()))
            {
                list.Add(obj);
                return list;
            }

            list.AddRange(((IEnumerable)obj).Cast<object>());
            return list;
        }
    }

    /// <summary>
    /// A log of commits in a <see cref="Repository"/>
    /// </summary>
    public sealed class CommitLog : IQueryableCommitLog
    {
        private readonly Repository repo;
        private readonly CommitFilter queryFilter;

        /// <summary>
        /// Initializes a new instance of the <see cref="CommitLog"/> class.
        /// The commits will be enumerated according in reverse chronological order.
        /// </summary>
        /// <param name="repo">The repository.</param>
        internal CommitLog(Repository repo)
            : this(repo, new CommitFilter())
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="CommitLog"/> class.
        /// </summary>
        /// <param name="repo">The repository.</param>
        /// <param name="queryFilter">The filter to use in querying commits</param>
        internal CommitLog(Repository repo, CommitFilter queryFilter)
        {
            this.repo = repo;
            this.queryFilter = queryFilter;
        }

        /// <summary>
        /// Gets the current sorting strategy applied when enumerating the log
        /// </summary>
        public CommitSortStrategies SortedBy
        {
            get { return queryFilter.SortBy; }
        }

        #region IEnumerable<Commit> Members

        /// <summary>
        /// Returns an enumerator that iterates through the log.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the log.</returns>
        public IEnumerator<Commit> GetEnumerator()
        {
            return new CommitEnumerator(repo, queryFilter);
        }

        /// <summary>
        /// Returns an enumerator that iterates through the log.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the log.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        /// <summary>
        /// Returns the list of commits of the repository matching the specified <paramref name="filter"/>.
        /// </summary>
        /// <param name="filter">The options used to control which commits will be returned.</param>
        /// <returns>A list of commits, ready to be enumerated.</returns>
        public ICommitLog QueryBy(CommitFilter filter)
        {
            Ensure.ArgumentNotNull(filter, "filter");
            Ensure.ArgumentNotNull(filter.IncludeReachableFrom, "filter.IncludeReachableFrom");
            Ensure.ArgumentNotNullOrEmptyString(filter.IncludeReachableFrom.ToString(), "filter.IncludeReachableFrom");

            return new CommitLog(repo, filter);
        }

        /// <summary>
        /// Returns the list of commits of the repository representing the history of a file beyond renames.
        /// </summary>
        /// <param name="path">The file's path.</param>
        /// <returns>A list of file history entries, ready to be enumerated.</returns>
        public IEnumerable<LogEntry> QueryBy(string path)
        {
            Ensure.ArgumentNotNull(path, "path");

            return new FileHistory(repo, path);
        }

        /// <summary>
        /// Returns the list of commits of the repository representing the history of a file beyond renames.
        /// </summary>
        /// <param name="path">The file's path.</param>
        /// <param name="filter">The options used to control which commits will be returned.</param>
        /// <returns>A list of file history entries, ready to be enumerated.</returns>
        public IEnumerable<LogEntry> QueryBy(string path, CommitFilter filter)
        {
            Ensure.ArgumentNotNull(path, "path");
            Ensure.ArgumentNotNull(filter, "filter");

            return new FileHistory(repo, path, filter);
        }

        private class CommitEnumerator : IEnumerator<Commit>
        {
            private readonly Repository repo;
            private readonly RevWalkerHandle handle;
            private ObjectId currentOid;

            public CommitEnumerator(Repository repo, CommitFilter filter)
            {
                this.repo = repo;
                handle = Proxy.git_revwalk_new(repo.Handle);
                repo.RegisterForCleanup(handle);

                Sort(filter.SortBy);
                Push(filter.SinceList);
                Hide(filter.UntilList);
                FirstParentOnly(filter.FirstParentOnly);
            }

            #region IEnumerator<Commit> Members

            public Commit Current
            {
                get { return repo.Lookup<Commit>(currentOid); }
            }

            object IEnumerator.Current
            {
                get { return Current; }
            }

            public bool MoveNext()
            {
                ObjectId id = Proxy.git_revwalk_next(handle);

                if (id == null)
                {
                    return false;
                }

                currentOid = id;

                return true;
            }

            public void Reset()
            {
                Proxy.git_revwalk_reset(handle);
            }

            #endregion

            public void Dispose()
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }

            private void Dispose(bool disposing)
            {
                handle.SafeDispose();
            }

            private delegate void HidePushSignature(RevWalkerHandle handle, ObjectId id);

            private void InternalHidePush(IList<object> identifier, HidePushSignature hidePush)
            {
                IEnumerable<ObjectId> oids = repo.Committishes(identifier).TakeWhile(o => o != null);

                foreach (ObjectId actedOn in oids)
                {
                    hidePush(handle, actedOn);
                }
            }

            private void Push(IList<object> identifier)
            {
                InternalHidePush(identifier, Proxy.git_revwalk_push);
            }

            private void Hide(IList<object> identifier)
            {
                if (identifier == null)
                {
                    return;
                }

                InternalHidePush(identifier, Proxy.git_revwalk_hide);
            }

            private void Sort(CommitSortStrategies options)
            {
                Proxy.git_revwalk_sorting(handle, options);
            }

            private void FirstParentOnly(bool firstParent)
            {
                if (firstParent)
                {
                    Proxy.git_revwalk_simplify_first_parent(handle);
                }
            }
        }
    }

    /// <summary>
    /// Determines the finding strategy of merge base.
    /// </summary>
    public enum MergeBaseFindingStrategy
    {
        /// <summary>
        /// Compute the best common ancestor between some commits to use in a three-way merge.
        /// <para>
        /// When more than two commits are provided, the computation is performed between the first commit and a hypothetical merge commit across all the remaining commits.
        /// </para>
        /// </summary>
        Standard,
        /// <summary>
        /// Compute the best common ancestor of all supplied commits, in preparation for an n-way merge.
        /// </summary>
        Octopus,
    }

    /// <summary>
    /// Provides optional additional information to commit creation.
    /// By default, a new commit will be created (instead of amending the
    /// HEAD commit) and an empty commit which is unchanged from the current
    /// HEAD is disallowed.
    /// </summary>
    public sealed class CommitOptions
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CommitOptions"/> class.
        /// <para>
        ///   Default behavior:
        ///     The message is prettified.
        ///     No automatic removal of comments is performed.
        /// </para>
        /// </summary>
        public CommitOptions()
        {
            PrettifyMessage = true;
        }

        /// <summary>
        /// True to amend the current <see cref="Commit"/> pointed at by <see cref="Repository.Head"/>, false otherwise.
        /// </summary>
        public bool AmendPreviousCommit { get; set; }

        /// <summary>
        /// True to allow creation of an empty <see cref="Commit"/>, false otherwise.
        /// </summary>
        public bool AllowEmptyCommit { get; set; }

        /// <summary>
        /// True to prettify the message by stripping leading and trailing empty lines, trailing whitespace, and collapsing consecutive empty lines, false otherwise.
        /// </summary>
        public bool PrettifyMessage { get; set; }

        /// <summary>
        /// The starting line char used to identify commentaries in the Commit message during the prettifying of the Commit message. If set (usually to '#'), all lines starting with this char will be removed from the message before the Commit is done.
        /// This property will only be considered when PrettifyMessage is set to true.
        /// </summary>
        public char? CommentaryChar { get; set; }
    }

    /// <summary>
    /// Commit metadata when rewriting history
    /// </summary>
    public sealed class CommitRewriteInfo
    {
        /// <summary>
        /// The author to be used for the new commit
        /// </summary>
        public Signature Author { get; set; }

        /// <summary>
        /// The committer to be used for the new commit
        /// </summary>
        public Signature Committer { get; set; }

        /// <summary>
        /// The message to be used for the new commit
        /// </summary>
        public string Message { get; set; }

        /// <summary>
        /// Build a <see cref="CommitRewriteInfo"/> from the <see cref="Commit"/> passed in
        /// </summary>
        /// <param name="commit">The <see cref="Commit"/> whose information is to be copied</param>
        /// <returns>A new <see cref="CommitRewriteInfo"/> object that matches the info for the <paramref name="commit"/>.</returns>
        public static CommitRewriteInfo From(Commit commit)
        {
            return new CommitRewriteInfo
            {
                Author = commit.Author,
                Committer = commit.Committer,
                Message = commit.Message
            };
        }

        /// <summary>
        /// Build a <see cref="CommitRewriteInfo"/> from the <see cref="Commit"/> passed in,
        /// optionally overriding some of its properties
        /// </summary>
        /// <param name="commit">The <see cref="Commit"/> whose information is to be copied</param>
        /// <param name="author">Optional override for the author</param>
        /// <returns>A new <see cref="CommitRewriteInfo"/> object that matches the info for the
        /// <paramref name="commit"/> with the optional parameters replaced..</returns>
        public static CommitRewriteInfo From(Commit commit, Signature author)
        {
            return From(commit, author, null, null);
        }

        /// <summary>
        /// Build a <see cref="CommitRewriteInfo"/> from the <see cref="Commit"/> passed in,
        /// optionally overriding some of its properties
        /// </summary>
        /// <param name="commit">The <see cref="Commit"/> whose information is to be copied</param>
        /// <param name="message">Optional override for the message</param>
        /// <returns>A new <see cref="CommitRewriteInfo"/> object that matches the info for the
        /// <paramref name="commit"/> with the optional parameters replaced..</returns>
        public static CommitRewriteInfo From(Commit commit, string message)
        {
            return From(commit, null, null, message);
        }

        /// <summary>
        /// Build a <see cref="CommitRewriteInfo"/> from the <see cref="Commit"/> passed in,
        /// optionally overriding some of its properties
        /// </summary>
        /// <param name="commit">The <see cref="Commit"/> whose information is to be copied</param>
        /// <param name="author">Optional override for the author</param>
        /// <param name="committer">Optional override for the committer</param>
        /// <returns>A new <see cref="CommitRewriteInfo"/> object that matches the info for the
        /// <paramref name="commit"/> with the optional parameters replaced..</returns>
        public static CommitRewriteInfo From(Commit commit, Signature author, Signature committer)
        {
            return From(commit, author, committer, null);
        }

        /// <summary>
        /// Build a <see cref="CommitRewriteInfo"/> from the <see cref="Commit"/> passed in,
        /// optionally overriding some of its properties
        /// </summary>
        /// <param name="commit">The <see cref="Commit"/> whose information is to be copied</param>
        /// <param name="author">Optional override for the author</param>
        /// <param name="committer">Optional override for the committer</param>
        /// <param name="message">Optional override for the message</param>
        /// <returns>A new <see cref="CommitRewriteInfo"/> object that matches the info for the
        /// <paramref name="commit"/> with the optional parameters replaced..</returns>
        public static CommitRewriteInfo From(
            Commit commit,
            Signature author,
            Signature committer,
            string message)
        {
            var cri = From(commit);
            cri.Author = author ?? cri.Author;
            cri.Committer = committer ?? cri.Committer;
            cri.Message = message ?? cri.Message;

            return cri;
        }
    }

    /// <summary>
    /// Determines the sorting strategy when iterating through the commits of the repository
    /// </summary>
    [Flags]
    public enum CommitSortStrategies
    {
        /// <summary>
        /// Sort the commits in no particular ordering;
        /// this sorting is arbitrary, implementation-specific
        /// and subject to change at any time.
        /// </summary>
        None = 0,

        /// <summary>
        /// Sort the commits in topological order
        /// (parents before children); this sorting mode
        /// can be combined with time sorting.
        /// </summary>
        Topological = (1 << 0),

        /// <summary>
        /// Sort the commits by commit time;
        /// this sorting mode can be combined with
        /// topological sorting.
        /// </summary>
        Time = (1 << 1),

        /// <summary>
        /// Iterate through the commits in reverse
        /// order; this sorting mode can be combined with
        /// any of the above.
        /// </summary>
        Reverse = (1 << 2)
    }

    /// <summary>
    /// Options to define file comparison behavior.
    /// </summary>
    public sealed class CompareOptions
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CompareOptions"/> class.
        /// </summary>
        public CompareOptions()
        {
            ContextLines = 3;
            InterhunkLines = 0;
            Algorithm = DiffAlgorithm.Myers;
        }

        /// <summary>
        /// The number of unchanged lines that define the boundary of a hunk (and to display before and after).
        /// (Default = 3)
        /// </summary>
        public int ContextLines { get; set; }

        /// <summary>
        /// The maximum number of unchanged lines between hunk boundaries before the hunks will be merged into a one.
        /// (Default = 0)
        /// </summary>
        public int InterhunkLines { get; set; }

        /// <summary>
        /// Options for rename detection. If null, the `diff.renames` configuration setting is used.
        /// </summary>
        public SimilarityOptions Similarity { get; set; }

        /// <summary>
        /// Include "unmodified" entries in the results.
        /// </summary>
        public bool IncludeUnmodified { get; set; }

        /// <summary>
        /// Algorithm to be used when performing a Diff.
        /// By default, <see cref="DiffAlgorithm.Myers"/> will be used.
        /// </summary>
        public DiffAlgorithm Algorithm { get; set; }

        /// <summary>
        /// Enable --indent-heuristic Diff option, that attempts to produce more aesthetically pleasing diffs.
        /// By default, this option will be false.
        /// </summary>
        public bool IndentHeuristic { get; set; }
    }

    /// <summary>
    /// Provides access to configuration variables for a repository.
    /// </summary>
    public class Configuration : IDisposable,
        IEnumerable<ConfigurationEntry<string>>
    {
        private readonly FilePath repoConfigPath;
        private readonly FilePath globalConfigPath;
        private readonly FilePath xdgConfigPath;
        private readonly FilePath systemConfigPath;
        private readonly FilePath programDataConfigPath;

        private ConfigurationHandle configHandle;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Configuration()
        { }

        internal Configuration(
            Repository repository,
            string repositoryConfigurationFileLocation,
            string globalConfigurationFileLocation,
            string xdgConfigurationFileLocation,
            string systemConfigurationFileLocation)
        {
            if (repositoryConfigurationFileLocation != null)
            {
                repoConfigPath = NormalizeConfigPath(repositoryConfigurationFileLocation);
            }

            globalConfigPath = globalConfigurationFileLocation ?? Proxy.git_config_find_global();
            xdgConfigPath = xdgConfigurationFileLocation ?? Proxy.git_config_find_xdg();
            systemConfigPath = systemConfigurationFileLocation ?? Proxy.git_config_find_system();
            programDataConfigPath = Proxy.git_config_find_programdata();

            Init(repository);
        }

        private void Init(Repository repository)
        {
            configHandle = Proxy.git_config_new();
            RepositoryHandle repoHandle = (repository != null) ? repository.Handle : null;

            if (repoHandle != null)
            {
                //TODO: push back this logic into libgit2.
                // As stated by @carlosmn "having a helper function to load the defaults and then allowing you
                // to modify it before giving it to git_repository_open_ext() would be a good addition, I think."
                //  -- Agreed :)
                string repoConfigLocation = Path.Combine(repository.Info.Path, "config");
                Proxy.git_config_add_file_ondisk(configHandle, repoConfigLocation, ConfigurationLevel.Local, repoHandle);

                Proxy.git_repository_set_config(repoHandle, configHandle);
            }
            else if (repoConfigPath != null)
            {
                Proxy.git_config_add_file_ondisk(configHandle, repoConfigPath, ConfigurationLevel.Local, repoHandle);
            }

            if (globalConfigPath != null)
            {
                Proxy.git_config_add_file_ondisk(configHandle, globalConfigPath, ConfigurationLevel.Global, repoHandle);
            }

            if (xdgConfigPath != null)
            {
                Proxy.git_config_add_file_ondisk(configHandle, xdgConfigPath, ConfigurationLevel.Xdg, repoHandle);
            }

            if (systemConfigPath != null)
            {
                Proxy.git_config_add_file_ondisk(configHandle, systemConfigPath, ConfigurationLevel.System, repoHandle);
            }

            if (programDataConfigPath != null)
            {
                Proxy.git_config_add_file_ondisk(configHandle, programDataConfigPath, ConfigurationLevel.ProgramData, repoHandle);
            }
        }

        private FilePath NormalizeConfigPath(FilePath path)
        {
            if (File.Exists(path.Native))
            {
                return path;
            }

            if (!Directory.Exists(path.Native))
            {
                throw new FileNotFoundException("Cannot find repository configuration file", path.Native);
            }

            var configPath = Path.Combine(path.Native, "config");

            if (File.Exists(configPath))
            {
                return configPath;
            }

            var gitConfigPath = Path.Combine(path.Native, ".git", "config");

            if (File.Exists(gitConfigPath))
            {
                return gitConfigPath;
            }

            throw new FileNotFoundException("Cannot find repository configuration file", path.Native);
        }

        /// <summary>
        /// Access configuration values without a repository.
        /// <para>
        ///   Generally you want to access configuration via an instance of <see cref="Repository"/> instead.
        /// </para>
        /// <para>
        ///   <paramref name="repositoryConfigurationFileLocation"/> can either contains a path to a file or a directory. In the latter case,
        ///   this can be the working directory, the .git directory or the directory containing a bare repository.
        /// </para>
        /// </summary>
        /// <param name="repositoryConfigurationFileLocation">Path to an existing Repository configuration file.</param>
        /// <returns>An instance of <see cref="Configuration"/>.</returns>
        public static Configuration BuildFrom(string repositoryConfigurationFileLocation)
        {
            return BuildFrom(repositoryConfigurationFileLocation, null, null, null);
        }

        /// <summary>
        /// Access configuration values without a repository.
        /// <para>
        ///   Generally you want to access configuration via an instance of <see cref="Repository"/> instead.
        /// </para>
        /// <para>
        ///   <paramref name="repositoryConfigurationFileLocation"/> can either contains a path to a file or a directory. In the latter case,
        ///   this can be the working directory, the .git directory or the directory containing a bare repository.
        /// </para>
        /// </summary>
        /// <param name="repositoryConfigurationFileLocation">Path to an existing Repository configuration file.</param>
        /// <param name="globalConfigurationFileLocation">Path to a Global configuration file. If null, the default path for a Global configuration file will be probed.</param>
        /// <returns>An instance of <see cref="Configuration"/>.</returns>
        public static Configuration BuildFrom(
            string repositoryConfigurationFileLocation,
            string globalConfigurationFileLocation)
        {
            return BuildFrom(repositoryConfigurationFileLocation, globalConfigurationFileLocation, null, null);
        }

        /// <summary>
        /// Access configuration values without a repository.
        /// <para>
        ///   Generally you want to access configuration via an instance of <see cref="Repository"/> instead.
        /// </para>
        /// <para>
        ///   <paramref name="repositoryConfigurationFileLocation"/> can either contains a path to a file or a directory. In the latter case,
        ///   this can be the working directory, the .git directory or the directory containing a bare repository.
        /// </para>
        /// </summary>
        /// <param name="repositoryConfigurationFileLocation">Path to an existing Repository configuration file.</param>
        /// <param name="globalConfigurationFileLocation">Path to a Global configuration file. If null, the default path for a Global configuration file will be probed.</param>
        /// <param name="xdgConfigurationFileLocation">Path to a XDG configuration file. If null, the default path for a XDG configuration file will be probed.</param>
        /// <returns>An instance of <see cref="Configuration"/>.</returns>
        public static Configuration BuildFrom(
            string repositoryConfigurationFileLocation,
            string globalConfigurationFileLocation,
            string xdgConfigurationFileLocation)
        {
            return BuildFrom(repositoryConfigurationFileLocation, globalConfigurationFileLocation, xdgConfigurationFileLocation, null);
        }

        /// <summary>
        /// Access configuration values without a repository.
        /// <para>
        ///   Generally you want to access configuration via an instance of <see cref="Repository"/> instead.
        /// </para>
        /// <para>
        ///   <paramref name="repositoryConfigurationFileLocation"/> can either contains a path to a file or a directory. In the latter case,
        ///   this can be the working directory, the .git directory or the directory containing a bare repository.
        /// </para>
        /// </summary>
        /// <param name="repositoryConfigurationFileLocation">Path to an existing Repository configuration file.</param>
        /// <param name="globalConfigurationFileLocation">Path to a Global configuration file. If null, the default path for a Global configuration file will be probed.</param>
        /// <param name="xdgConfigurationFileLocation">Path to a XDG configuration file. If null, the default path for a XDG configuration file will be probed.</param>
        /// <param name="systemConfigurationFileLocation">Path to a System configuration file. If null, the default path for a System configuration file will be probed.</param>
        /// <returns>An instance of <see cref="Configuration"/>.</returns>
        public static Configuration BuildFrom(
            string repositoryConfigurationFileLocation,
            string globalConfigurationFileLocation,
            string xdgConfigurationFileLocation,
            string systemConfigurationFileLocation)
        {
            return new Configuration(null, repositoryConfigurationFileLocation, globalConfigurationFileLocation, xdgConfigurationFileLocation, systemConfigurationFileLocation);
        }

        /// <summary>
        /// Determines which configuration file has been found.
        /// </summary>
        public virtual bool HasConfig(ConfigurationLevel level)
        {
            using (ConfigurationHandle snapshot = Snapshot())
            using (ConfigurationHandle handle = RetrieveConfigurationHandle(level, false, snapshot))
            {
                return handle != null;
            }
        }

        #region IDisposable Members

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// Saves any open configuration files.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        #endregion

        /// <summary>
        /// Unset a configuration variable (key and value) in the local configuration.
        /// </summary>
        /// <param name="key">The key to unset.</param>
        public virtual bool Unset(string key)
        {
            return Unset(key, ConfigurationLevel.Local);
        }

        /// <summary>
        /// Unset a configuration variable (key and value).
        /// </summary>
        /// <param name="key">The key to unset.</param>
        /// <param name="level">The configuration file which should be considered as the target of this operation</param>
        public virtual bool Unset(string key, ConfigurationLevel level)
        {
            Ensure.ArgumentNotNullOrEmptyString(key, "key");

            using (ConfigurationHandle h = RetrieveConfigurationHandle(level, true, configHandle))
            {
                return Proxy.git_config_delete(h, key);
            }
        }

        /// <summary>
        /// Unset all configuration values in a multivar variable (key and value) in the local configuration.
        /// </summary>
        /// <param name="key">The key to unset.</param>
        public virtual bool UnsetAll(string key)
        {
            return UnsetAll(key, ConfigurationLevel.Local);
        }

        /// <summary>
        /// Unset all configuration values in a multivar variable (key and value).
        /// </summary>
        /// <param name="key">The key to unset.</param>
        /// <param name="level">The configuration file which should be considered as the target of this operation</param>
        public virtual bool UnsetAll(string key, ConfigurationLevel level)
        {
            Ensure.ArgumentNotNullOrEmptyString(key, "key");

            using (ConfigurationHandle h = RetrieveConfigurationHandle(level, true, configHandle))
            {
                return Proxy.git_config_delete_multivar(h, key);
            }
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            configHandle.SafeDispose();
        }

        /// <summary>
        /// Get a configuration value for the given key parts.
        /// <para>
        ///   For example in order to get the value for this in a .git\config file:
        ///
        ///   <code>
        ///   [core]
        ///   bare = true
        ///   </code>
        ///
        ///   You would call:
        ///
        ///   <code>
        ///   bool isBare = repo.Config.Get&lt;bool&gt;(new []{ "core", "bare" }).Value;
        ///   </code>
        /// </para>
        /// </summary>
        /// <typeparam name="T">The configuration value type</typeparam>
        /// <param name="keyParts">The key parts</param>
        /// <returns>The <see cref="ConfigurationEntry{T}"/>, or null if not set</returns>
        public virtual ConfigurationEntry<T> Get<T>(string[] keyParts)
        {
            Ensure.ArgumentNotNull(keyParts, "keyParts");

            return Get<T>(string.Join(".", keyParts));
        }

        /// <summary>
        /// Get a configuration value for the given key parts.
        /// <para>
        ///   For example in order to get the value for this in a .git\config file:
        ///
        ///   <code>
        ///   [difftool "kdiff3"]
        ///     path = c:/Program Files/KDiff3/kdiff3.exe
        ///   </code>
        ///
        ///   You would call:
        ///
        ///   <code>
        ///   string where = repo.Config.Get&lt;string&gt;("difftool", "kdiff3", "path").Value;
        ///   </code>
        /// </para>
        /// </summary>
        /// <typeparam name="T">The configuration value type</typeparam>
        /// <param name="firstKeyPart">The first key part</param>
        /// <param name="secondKeyPart">The second key part</param>
        /// <param name="thirdKeyPart">The third key part</param>
        /// <returns>The <see cref="ConfigurationEntry{T}"/>, or null if not set</returns>
        public virtual ConfigurationEntry<T> Get<T>(string firstKeyPart, string secondKeyPart, string thirdKeyPart)
        {
            Ensure.ArgumentNotNullOrEmptyString(firstKeyPart, "firstKeyPart");
            Ensure.ArgumentNotNullOrEmptyString(secondKeyPart, "secondKeyPart");
            Ensure.ArgumentNotNullOrEmptyString(thirdKeyPart, "thirdKeyPart");

            return Get<T>(new[] { firstKeyPart, secondKeyPart, thirdKeyPart });
        }

        /// <summary>
        /// Get a configuration value for a key. Keys are in the form 'section.name'.
        /// <para>
        ///    The same escalation logic than in git.git will be used when looking for the key in the config files:
        ///       - local: the Git file in the current repository
        ///       - global: the Git file specific to the current interactive user (usually in `$HOME/.gitconfig`)
        ///       - xdg: another Git file specific to the current interactive user (usually in `$HOME/.config/git/config`)
        ///       - system: the system-wide Git file
        ///
        ///   The first occurence of the key will be returned.
        /// </para>
        /// <para>
        ///   For example in order to get the value for this in a .git\config file:
        ///
        ///   <code>
        ///   [core]
        ///   bare = true
        ///   </code>
        ///
        ///   You would call:
        ///
        ///   <code>
        ///   bool isBare = repo.Config.Get&lt;bool&gt;("core.bare").Value;
        ///   </code>
        /// </para>
        /// </summary>
        /// <typeparam name="T">The configuration value type</typeparam>
        /// <param name="key">The key</param>
        /// <returns>The <see cref="ConfigurationEntry{T}"/>, or null if not set</returns>
        public virtual ConfigurationEntry<T> Get<T>(string key)
        {
            Ensure.ArgumentNotNullOrEmptyString(key, "key");

            using (ConfigurationHandle snapshot = Snapshot())
            {
                return Proxy.git_config_get_entry<T>(snapshot, key);
            }
        }

        /// <summary>
        /// Get a configuration value for a key. Keys are in the form 'section.name'.
        /// <para>
        ///   For example in order to get the value for this in a .git\config file:
        ///
        ///   <code>
        ///   [core]
        ///   bare = true
        ///   </code>
        ///
        ///   You would call:
        ///
        ///   <code>
        ///   bool isBare = repo.Config.Get&lt;bool&gt;("core.bare").Value;
        ///   </code>
        /// </para>
        /// </summary>
        /// <typeparam name="T">The configuration value type</typeparam>
        /// <param name="key">The key</param>
        /// <param name="level">The configuration file into which the key should be searched for</param>
        /// <returns>The <see cref="ConfigurationEntry{T}"/>, or null if not set</returns>
        public virtual ConfigurationEntry<T> Get<T>(string key, ConfigurationLevel level)
        {
            Ensure.ArgumentNotNullOrEmptyString(key, "key");

            using (ConfigurationHandle snapshot = Snapshot())
            using (ConfigurationHandle handle = RetrieveConfigurationHandle(level, false, snapshot))
            {
                if (handle == null)
                {
                    return null;
                }

                return Proxy.git_config_get_entry<T>(handle, key);
            }
        }

        /// <summary>
        /// Get a configuration value for the given key.
        /// </summary>
        /// <typeparam name="T">The configuration value type.</typeparam>
        /// <param name="key">The key</param>
        /// <returns>The configuration value, or the default value for the selected <see typeparamref="T"/>if not found</returns>
        public virtual T GetValueOrDefault<T>(string key)
        {
            return ValueOrDefault(Get<T>(key), default(T));
        }

        /// <summary>
        /// Get a configuration value for the given key,
        /// or <paramref name="defaultValue" /> if the key is not set.
        /// </summary>
        /// <typeparam name="T">The configuration value type.</typeparam>
        /// <param name="key">The key</param>
        /// <param name="defaultValue">The default value if the key is not set.</param>
        /// <returns>The configuration value, or the default value</returns>
        public virtual T GetValueOrDefault<T>(string key, T defaultValue)
        {
            return ValueOrDefault(Get<T>(key), defaultValue);
        }

        /// <summary>
        /// Get a configuration value for the given key
        /// </summary>
        /// <typeparam name="T">The configuration value type.</typeparam>
        /// <param name="key">The key.</param>
        /// <param name="level">The configuration file into which the key should be searched for.</param>
        /// <returns>The configuration value, or the default value for <see typeparamref="T"/> if not found</returns>
        public virtual T GetValueOrDefault<T>(string key, ConfigurationLevel level)
        {
            return ValueOrDefault(Get<T>(key, level), default(T));
        }

        /// <summary>
        /// Get a configuration value for the given key,
        /// or <paramref name="defaultValue" /> if the key is not set.
        /// </summary>
        /// <typeparam name="T">The configuration value type.</typeparam>
        /// <param name="key">The key.</param>
        /// <param name="level">The configuration file into which the key should be searched for.</param>
        /// <param name="defaultValue">The selector used to generate a default value if the key is not set.</param>
        /// <returns>The configuration value, or the default value.</returns>
        public virtual T GetValueOrDefault<T>(string key, ConfigurationLevel level, T defaultValue)
        {
            return ValueOrDefault(Get<T>(key, level), defaultValue);
        }

        /// <summary>
        /// Get a configuration value for the given key parts
        /// </summary>
        /// <typeparam name="T">The configuration value type.</typeparam>
        /// <param name="keyParts">The key parts.</param>
        /// <returns>The configuration value, or the default value for<see typeparamref="T"/> if not found</returns>
        public virtual T GetValueOrDefault<T>(string[] keyParts)
        {
            return ValueOrDefault(Get<T>(keyParts), default(T));
        }

        /// <summary>
        /// Get a configuration value for the given key parts,
        /// or <paramref name="defaultValue" /> if the key is not set.
        /// </summary>
        /// <typeparam name="T">The configuration value type.</typeparam>
        /// <param name="keyParts">The key parts.</param>
        /// <param name="defaultValue">The default value if the key is not set.</param>
        /// <returns>The configuration value, or the default value.</returns>
        public virtual T GetValueOrDefault<T>(string[] keyParts, T defaultValue)
        {
            return ValueOrDefault(Get<T>(keyParts), defaultValue);
        }

        /// <summary>
        /// Get a configuration value for the given key parts.
        /// </summary>
        /// <typeparam name="T">The configuration value type.</typeparam>
        /// <param name="firstKeyPart">The first key part.</param>
        /// <param name="secondKeyPart">The second key part.</param>
        /// <param name="thirdKeyPart">The third key part.</param>
        /// <returns>The configuration value, or the default value for the selected <see typeparamref="T"/> if not found</returns>
        public virtual T GetValueOrDefault<T>(string firstKeyPart, string secondKeyPart, string thirdKeyPart)
        {
            return ValueOrDefault(Get<T>(firstKeyPart, secondKeyPart, thirdKeyPart), default(T));
        }

        /// <summary>
        /// Get a configuration value for the given key parts,
        /// or <paramref name="defaultValue" /> if the key is not set.
        /// </summary>
        /// <typeparam name="T">The configuration value type.</typeparam>
        /// <param name="firstKeyPart">The first key part.</param>
        /// <param name="secondKeyPart">The second key part.</param>
        /// <param name="thirdKeyPart">The third key part.</param>
        /// <param name="defaultValue">The default value if the key is not set.</param>
        /// <returns>The configuration value, or the default.</returns>
        public virtual T GetValueOrDefault<T>(string firstKeyPart, string secondKeyPart, string thirdKeyPart, T defaultValue)
        {
            return ValueOrDefault(Get<T>(firstKeyPart, secondKeyPart, thirdKeyPart), defaultValue);
        }

        /// <summary>
        /// Get a configuration value for the given key,
        /// or a value generated by <paramref name="defaultValueSelector" />
        /// if the key is not set.
        /// </summary>
        /// <typeparam name="T">The configuration value type.</typeparam>
        /// <param name="key">The key</param>
        /// <param name="defaultValueSelector">The selector used to generate a default value if the key is not set.</param>
        /// <returns>The configuration value, or a generated default.</returns>
        public virtual T GetValueOrDefault<T>(string key, Func<T> defaultValueSelector)
        {
            return ValueOrDefault(Get<T>(key), defaultValueSelector);
        }

        /// <summary>
        /// Get a configuration value for the given key,
        /// or a value generated by <paramref name="defaultValueSelector" />
        /// if the key is not set.
        /// </summary>
        /// <typeparam name="T">The configuration value type.</typeparam>
        /// <param name="key">The key.</param>
        /// <param name="level">The configuration file into which the key should be searched for.</param>
        /// <param name="defaultValueSelector">The selector used to generate a default value if the key is not set.</param>
        /// <returns>The configuration value, or a generated default.</returns>
        public virtual T GetValueOrDefault<T>(string key, ConfigurationLevel level, Func<T> defaultValueSelector)
        {
            return ValueOrDefault(Get<T>(key, level), defaultValueSelector);
        }

        /// <summary>
        /// Get a configuration value for the given key parts,
        /// or a value generated by <paramref name="defaultValueSelector" />
        /// if the key is not set.
        /// </summary>
        /// <typeparam name="T">The configuration value type.</typeparam>
        /// <param name="keyParts">The key parts.</param>
        /// <param name="defaultValueSelector">The selector used to generate a default value if the key is not set.</param>
        /// <returns>The configuration value, or a generated default.</returns>
        public virtual T GetValueOrDefault<T>(string[] keyParts, Func<T> defaultValueSelector)
        {
            return ValueOrDefault(Get<T>(keyParts), defaultValueSelector);
        }

        /// <summary>
        /// Get a configuration value for the given key parts,
        /// or a value generated by <paramref name="defaultValueSelector" />
        /// if the key is not set.
        /// </summary>
        /// <typeparam name="T">The configuration value type.</typeparam>
        /// <param name="firstKeyPart">The first key part.</param>
        /// <param name="secondKeyPart">The second key part.</param>
        /// <param name="thirdKeyPart">The third key part.</param>
        /// <param name="defaultValueSelector">The selector used to generate a default value if the key is not set.</param>
        /// <returns>The configuration value, or a generated default.</returns>
        public virtual T GetValueOrDefault<T>(string firstKeyPart, string secondKeyPart, string thirdKeyPart, Func<T> defaultValueSelector)
        {
            return ValueOrDefault(Get<T>(firstKeyPart, secondKeyPart, thirdKeyPart), defaultValueSelector);
        }

        private static T ValueOrDefault<T>(ConfigurationEntry<T> value, T defaultValue)
        {
            return value == null ? defaultValue : value.Value;
        }

        private static T ValueOrDefault<T>(ConfigurationEntry<T> value, Func<T> defaultValueSelector)
        {
            Ensure.ArgumentNotNull(defaultValueSelector, "defaultValueSelector");

            return value == null
                       ? defaultValueSelector()
                       : value.Value;
        }

        /// <summary>
        /// Set a configuration value for a key in the local configuration. Keys are in the form 'section.name'.
        /// <para>
        ///   For example in order to set the value for this in a .git\config file:
        ///
        ///   [test]
        ///   boolsetting = true
        ///
        ///   You would call:
        ///
        ///   repo.Config.Set("test.boolsetting", true);
        /// </para>
        /// </summary>
        /// <typeparam name="T">The configuration value type</typeparam>
        /// <param name="key">The key parts</param>
        /// <param name="value">The value</param>
        public virtual void Set<T>(string key, T value)
        {
            Set(key, value, ConfigurationLevel.Local);
        }

        /// <summary>
        /// Set a configuration value for a key. Keys are in the form 'section.name'.
        /// <para>
        ///   For example in order to set the value for this in a .git\config file:
        ///
        ///   [test]
        ///   boolsetting = true
        ///
        ///   You would call:
        ///
        ///   repo.Config.Set("test.boolsetting", true);
        /// </para>
        /// </summary>
        /// <typeparam name="T">The configuration value type</typeparam>
        /// <param name="key">The key parts</param>
        /// <param name="value">The value</param>
        /// <param name="level">The configuration file which should be considered as the target of this operation</param>
        public virtual void Set<T>(string key, T value, ConfigurationLevel level)
        {
            Ensure.ArgumentNotNull(value, "value");
            Ensure.ArgumentNotNullOrEmptyString(key, "key");

            using (ConfigurationHandle h = RetrieveConfigurationHandle(level, true, configHandle))
            {
                if (!configurationTypedUpdater.ContainsKey(typeof(T)))
                {
                    throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "Generic Argument of type '{0}' is not supported.", typeof(T).FullName));
                }

                configurationTypedUpdater[typeof(T)](key, value, h);
            }
        }

        /// <summary>
        /// Adds a configuration value for a multivalue key in the local configuration. Keys are in the form 'section.name'.
        /// <para>
        ///   For example in order to add the value for this in a .git\config file:
        ///
        ///   [test]
        ///   plugin = first
        ///
        ///   You would call:
        ///
        ///   repo.Config.Add("test.plugin", "first");
        /// </para>
        /// </summary>
        /// <param name="key">The key parts</param>
        /// <param name="value">The value</param>
        public virtual void Add(string key, string value)
        {
            Add(key, value, ConfigurationLevel.Local);
        }

        /// <summary>
        /// Adds a configuration value for a multivalue key. Keys are in the form 'section.name'.
        /// <para>
        ///   For example in order to add the value for this in a .git\config file:
        ///
        ///   [test]
        ///   plugin = first
        ///
        ///   You would call:
        ///
        ///   repo.Config.Add("test.plugin", "first");
        /// </para>
        /// </summary>
        /// <param name="key">The key parts</param>
        /// <param name="value">The value</param>
        /// <param name="level">The configuration file which should be considered as the target of this operation</param>
        public virtual void Add(string key, string value, ConfigurationLevel level)
        {
            Ensure.ArgumentNotNull(value, "value");
            Ensure.ArgumentNotNullOrEmptyString(key, "key");

            using (ConfigurationHandle h = RetrieveConfigurationHandle(level, true, configHandle))
            {
                Proxy.git_config_add_string(h, key, value);
            }
        }

        /// <summary>
        /// Find configuration entries matching <paramref name="regexp"/>.
        /// </summary>
        /// <param name="regexp">A regular expression.</param>
        /// <returns>Matching entries.</returns>
        public virtual IEnumerable<ConfigurationEntry<string>> Find(string regexp)
        {
            return Find(regexp, ConfigurationLevel.Local);
        }

        /// <summary>
        /// Find configuration entries matching <paramref name="regexp"/>.
        /// </summary>
        /// <param name="regexp">A regular expression.</param>
        /// <param name="level">The configuration file into which the key should be searched for.</param>
        /// <returns>Matching entries.</returns>
        public virtual IEnumerable<ConfigurationEntry<string>> Find(string regexp, ConfigurationLevel level)
        {
            Ensure.ArgumentNotNullOrEmptyString(regexp, "regexp");

            using (ConfigurationHandle snapshot = Snapshot())
            using (ConfigurationHandle h = RetrieveConfigurationHandle(level, true, snapshot))
            {
                return Proxy.git_config_iterator_glob(h, regexp).ToList();
            }
        }

        private ConfigurationHandle RetrieveConfigurationHandle(ConfigurationLevel level, bool throwIfStoreHasNotBeenFound, ConfigurationHandle fromHandle)
        {
            ConfigurationHandle handle = null;
            if (fromHandle != null)
            {
                handle = Proxy.git_config_open_level(fromHandle, level);
            }

            if (handle == null && throwIfStoreHasNotBeenFound)
            {
                throw new LibGit2SharpException("No {0} configuration file has been found.",
                                                              Enum.GetName(typeof(ConfigurationLevel), level));
            }

            return handle;
        }

        private static Action<string, object, ConfigurationHandle> GetUpdater<T>(Action<ConfigurationHandle, string, T> setter)
        {
            return (key, val, handle) => setter(handle, key, (T)val);
        }

        private readonly static IDictionary<Type, Action<string, object, ConfigurationHandle>> configurationTypedUpdater = new Dictionary<Type, Action<string, object, ConfigurationHandle>>
        {
            { typeof(int), GetUpdater<int>(Proxy.git_config_set_int32) },
            { typeof(long), GetUpdater<long>(Proxy.git_config_set_int64) },
            { typeof(bool), GetUpdater<bool>(Proxy.git_config_set_bool) },
            { typeof(string), GetUpdater<string>(Proxy.git_config_set_string) },
        };

        /// <summary>
        /// Returns an enumerator that iterates through the configuration entries.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the configuration entries.</returns>
        public virtual IEnumerator<ConfigurationEntry<string>> GetEnumerator()
        {
            return BuildConfigEntries().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return ((IEnumerable<ConfigurationEntry<string>>)this).GetEnumerator();
        }

        private IEnumerable<ConfigurationEntry<string>> BuildConfigEntries()
        {
            return Proxy.git_config_foreach(configHandle, BuildConfigEntry);
        }

        internal static unsafe ConfigurationEntry<string> BuildConfigEntry(IntPtr entryPtr)
        {
            var entry = (GitConfigEntry*)entryPtr.ToPointer();
            return new ConfigurationEntry<string>(LaxUtf8Marshaler.FromNative(entry->namePtr),
                                                  LaxUtf8Marshaler.FromNative(entry->valuePtr),
                                                  (ConfigurationLevel)entry->level);
        }

        /// <summary>
        /// Builds a <see cref="Signature"/> based on current configuration. If it is not found or
        /// some configuration is missing, <code>null</code> is returned.
        /// <para>
        ///    The same escalation logic than in git.git will be used when looking for the key in the config files:
        ///       - local: the Git file in the current repository
        ///       - global: the Git file specific to the current interactive user (usually in `$HOME/.gitconfig`)
        ///       - xdg: another Git file specific to the current interactive user (usually in `$HOME/.config/git/config`)
        ///       - system: the system-wide Git file
        /// </para>
        /// </summary>
        /// <param name="now">The timestamp to use for the <see cref="Signature"/>.</param>
        /// <returns>The signature or null if no user identity can be found in the configuration.</returns>
        public virtual Signature BuildSignature(DateTimeOffset now)
        {
            var name = this.GetValueOrDefault<string>("user.name");
            var email = this.GetValueOrDefault<string>("user.email");

            if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(email))
            {
                return null;
            }

            return new Signature(name, email, now);
        }

        internal Signature BuildSignatureOrThrow(DateTimeOffset now)
        {
            var signature = BuildSignature(now);
            if (signature == null)
            {
                throw new LibGit2SharpException("This overload requires 'user.name' and 'user.email' to be set. " +
                                                "Use a different overload or set those variables in the configuation");
            }

            return signature;
        }

        private ConfigurationHandle Snapshot()
        {
            return Proxy.git_config_snapshot(configHandle);
        }

        /// <summary>
        /// Perform a series of actions within a transaction.
        ///
        /// The configuration will be locked during this function and the changes will be committed at the end. These
        /// changes will not be visible in the configuration until the end of this method.
        ///
        /// If the action throws an exception, the changes will be rolled back.
        /// </summary>
        /// <param name="action">The code to run under the transaction</param>
        public virtual unsafe void WithinTransaction(Action action)
        {
            IntPtr txn = IntPtr.Zero;
            try
            {
                txn = Proxy.git_config_lock(configHandle);
                action();
                Proxy.git_transaction_commit(txn);
            }
            finally
            {
                Proxy.git_transaction_free(txn);
            }
        }
    }

    /// <summary>
    /// The full representation of a config option.
    /// </summary>
    /// <typeparam name="T">The configuration value type</typeparam>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class ConfigurationEntry<T>
    {
        /// <summary>
        /// The fully-qualified option name.
        /// </summary>
        public virtual string Key { get; private set; }

        /// <summary>
        /// The option value.
        /// </summary>
        public virtual T Value { get; private set; }

        /// <summary>
        /// The origin store.
        /// </summary>
        public virtual ConfigurationLevel Level { get; private set; }

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected ConfigurationEntry()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConfigurationEntry{T}"/> class with a given key and value
        /// </summary>
        /// <param name="key">The option name</param>
        /// <param name="value">The option value</param>
        /// <param name="level">The origin store</param>
        protected internal ConfigurationEntry(string key, T value, ConfigurationLevel level)
        {
            Key = key;
            Value = value;
            Level = level;
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "{0} = \"{1}\"", Key, Value);
            }
        }
    }

    /// <summary>
    /// Specifies the level of configuration to use.
    /// </summary>
    public enum ConfigurationLevel
    {
        /// <summary>
        /// The local .git/config of the current repository.
        /// </summary>
        Local = 5,

        /// <summary>
        /// The global ~/.gitconfig of the current user.
        /// </summary>
        Global = 4,

        /// <summary>
        /// The global ~/.config/git/config of the current user.
        /// </summary>
        Xdg = 3,

        /// <summary>
        /// The system wide .gitconfig.
        /// </summary>
        System = 2,

        /// <summary>
        /// Another system-wide configuration on Windows.
        /// </summary>
        ProgramData = 1,
    }

    /// <summary>
    ///  Represents a group of index entries that describe a merge conflict
    ///  in the index.  This is typically a set of ancestor, ours and theirs
    ///  entries for a given path.
    ///
    /// Any side may be missing to reflect additions or deletions in the
    /// branches being merged.
    /// </summary>
    public class Conflict : IEquatable<Conflict>
    {
        private readonly IndexEntry ancestor;
        private readonly IndexEntry ours;
        private readonly IndexEntry theirs;

        private static readonly LambdaEqualityHelper<Conflict> equalityHelper =
            new LambdaEqualityHelper<Conflict>(x => x.Ancestor, x => x.Ours, x => x.Theirs);

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Conflict()
        { }

        internal Conflict(IndexEntry ancestor, IndexEntry ours, IndexEntry theirs)
        {
            this.ancestor = ancestor;
            this.ours = ours;
            this.theirs = theirs;
        }

        /// <summary>
        ///  The index entry of the ancestor side of the conflict (the stage
        ///  1 index entry.)
        /// </summary>
        public virtual IndexEntry Ancestor
        {
            get { return ancestor; }
        }

        /// <summary>
        ///  The index entry of the "ours" (ORIG_HEAD or merge target) side
        ///  of the conflict (the stage 2 index entry.)
        /// </summary>
        public virtual IndexEntry Ours
        {
            get { return ours; }
        }

        /// <summary>
        ///  The index entry of the "theirs" (merge source) side of the
        ///  conflict (the stage 3 index entry.)
        /// </summary>
        public virtual IndexEntry Theirs
        {
            get { return theirs; }
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is
        /// equal to the current <see cref="Conflict"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with
        /// the current <see cref="Conflict"/>.</param>
        /// <returns>true if the specified <see cref="Object"/> is equal
        /// to the current <see cref="Conflict"/>; otherwise,
        /// false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as Conflict);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Conflict"/>
        /// is equal to the current <see cref="Conflict"/>.
        /// </summary>
        /// <param name="other">The <see cref="Conflict"/> to compare
        /// with the current <see cref="Conflict"/>.</param>
        /// <returns>true if the specified <see cref="Conflict"/> is equal
        /// to the current <see cref="Conflict"/>; otherwise,
        /// false.</returns>
        public bool Equals(Conflict other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="Conflict"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="Conflict"/> to compare.</param>
        /// <param name="right">Second <see cref="Conflict"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(Conflict left, Conflict right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="Conflict"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="Conflict"/> to compare.</param>
        /// <param name="right">Second <see cref="Conflict"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(Conflict left, Conflict right)
        {
            return !Equals(left, right);
        }
    }

    /// <summary>
    ///  The collection of <see cref="LibGit2Sharp.Conflict"/>s in a
    ///  <see cref="LibGit2Sharp.Repository"/> index due to a
    ///  previously performed merge operation.
    /// </summary>
    public class ConflictCollection : IEnumerable<Conflict>
    {
        private readonly Index index;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected ConflictCollection()
        { }

        internal ConflictCollection(Index index)
        {
            this.index = index;
        }

        /// <summary>
        ///  Gets the <see cref="LibGit2Sharp.Conflict"/> for the
        ///  specified relative path.
        /// </summary>
        /// <param name="path">The relative path to query</param>
        /// <returns>A <see cref="Conflict"/> that represents the conflict for this file.</returns>
        public virtual Conflict this[string path]
        {
            get
            {
                return Proxy.git_index_conflict_get(index.Handle, path);
            }
        }

        /// <summary>
        /// Get the <see cref="IndexReucEntryCollection"/> that contains
        /// the list of conflicts that have been resolved.
        /// </summary>
        public virtual IndexReucEntryCollection ResolvedConflicts
        {
            get
            {
                return new IndexReucEntryCollection(index);
            }
        }

        /// <summary>
        /// Get the <see cref="IndexNameEntryCollection"/> that contains
        /// the list of paths involved in rename conflicts.
        /// </summary>
        public virtual IndexNameEntryCollection Names
        {
            get
            {
                return new IndexNameEntryCollection(index);
            }
        }

        #region IEnumerable<Conflict> Members

        private List<Conflict> AllConflicts()
        {
            var list = new List<Conflict>();
            IndexEntry ancestor = null, ours = null, theirs = null;
            string currentPath = null;

            foreach (IndexEntry entry in index)
            {
                if (entry.StageLevel == StageLevel.Staged)
                {
                    continue;
                }

                if (currentPath != null && !entry.Path.Equals(currentPath, StringComparison.Ordinal))
                {
                    list.Add(new Conflict(ancestor, ours, theirs));

                    ancestor = null;
                    ours = null;
                    theirs = null;
                }

                currentPath = entry.Path;

                switch (entry.StageLevel)
                {
                    case StageLevel.Ancestor:
                        ancestor = entry;
                        break;
                    case StageLevel.Ours:
                        ours = entry;
                        break;
                    case StageLevel.Theirs:
                        theirs = entry;
                        break;
                    default:
                        throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture,
                                                                          "Entry '{0}' bears an unexpected StageLevel '{1}'",
                                                                          entry.Path,
                                                                          entry.StageLevel));
                }
            }

            if (currentPath != null)
            {
                list.Add(new Conflict(ancestor, ours, theirs));
            }

            return list;
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<Conflict> GetEnumerator()
        {
            return AllConflicts().GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion
    }

    /// <summary>
    /// Holds the changes between two <see cref="Blob"/>s.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class ContentChanges
    {
        private readonly StringBuilder patchBuilder = new StringBuilder();

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected ContentChanges()
        { }

        internal unsafe ContentChanges(Repository repo, Blob oldBlob, Blob newBlob, GitDiffOptions options)
        {
            Proxy.git_diff_blobs(repo.Handle,
                                 oldBlob != null ? oldBlob.Id : null,
                                 newBlob != null ? newBlob.Id : null,
                                 options,
                                 FileCallback,
                                 HunkCallback,
                                 LineCallback);
        }

        internal ContentChanges(bool isBinaryComparison)
        {
            this.IsBinaryComparison = isBinaryComparison;
        }

        internal void AppendToPatch(string patch)
        {
            patchBuilder.Append(patch);
        }

        /// <summary>
        /// The number of lines added.
        /// </summary>
        public virtual int LinesAdded { get; internal set; }

        /// <summary>
        /// The number of lines deleted.
        /// </summary>
        public virtual int LinesDeleted { get; internal set; }

        /// <summary>
        /// The list of added lines.
        /// </summary>
        public List<Line> AddedLines = new List<Line>();

        /// <summary>
        /// The list of deleted lines.
        /// </summary>
        public List<Line> DeletedLines = new List<Line>();

        /// <summary>
        /// The patch corresponding to these changes.
        /// </summary>
        public virtual string Patch
        {
            get { return patchBuilder.ToString(); }
        }

        /// <summary>
        /// Determines if at least one side of the comparison holds binary content.
        /// </summary>
        public virtual bool IsBinaryComparison { get; private set; }

        private unsafe int FileCallback(git_diff_delta* delta, float progress, IntPtr payload)
        {
            IsBinaryComparison = delta->flags.HasFlag(GitDiffFlags.GIT_DIFF_FLAG_BINARY);

            if (!IsBinaryComparison)
            {
                return 0;
            }

            AppendToPatch("Binary content differ\n");

            return 0;
        }

        private unsafe int HunkCallback(git_diff_delta* delta, GitDiffHunk hunk, IntPtr payload)
        {
            string decodedContent = LaxUtf8Marshaler.FromBuffer(hunk.Header, (int)hunk.HeaderLen);

            AppendToPatch(decodedContent);
            return 0;
        }

        private unsafe int LineCallback(git_diff_delta* delta, GitDiffHunk hunk, GitDiffLine line, IntPtr payload)
        {
            string decodedContent = LaxUtf8Marshaler.FromNative(line.content, (int)line.contentLen);

            string prefix;

            switch (line.lineOrigin)
            {
                case GitDiffLineOrigin.GIT_DIFF_LINE_ADDITION:
                    AddedLines.Add(new Line(line.NewLineNo, decodedContent));
                    LinesAdded++;
                    prefix = Encoding.ASCII.GetString(new[] { (byte)line.lineOrigin });
                    break;

                case GitDiffLineOrigin.GIT_DIFF_LINE_DELETION:
                    DeletedLines.Add(new Line(line.OldLineNo, decodedContent));
                    LinesDeleted++;
                    prefix = Encoding.ASCII.GetString(new[] { (byte)line.lineOrigin });
                    break;

                case GitDiffLineOrigin.GIT_DIFF_LINE_CONTEXT:
                    prefix = Encoding.ASCII.GetString(new[] { (byte)line.lineOrigin });
                    break;

                default:
                    prefix = string.Empty;
                    break;
            }

            AppendToPatch(prefix);
            AppendToPatch(decodedContent);
            return 0;
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     @"{{+{0}, -{1}}}",
                                     LinesAdded,
                                     LinesDeleted);
            }
        }
    }

    /// <summary>
    /// Holds a summary of a change to a single file.
    /// </summary>
    public class ContentChangeStats
    {
        /// <summary>
        /// The number of lines added in the diff.
        /// </summary>
        public virtual int LinesAdded { get; private set; }

        /// <summary>
        /// The number of lines deleted in the diff.
        /// </summary>
        public virtual int LinesDeleted { get; private set; }

        /// <summary>
        /// For mocking.
        /// </summary>
        protected ContentChangeStats()
        { }

        internal ContentChangeStats(int added, int deleted)
        {
            LinesAdded = added;
            LinesDeleted = deleted;
        }
    }

    /// <summary>
    /// Class that holds credentials for remote repository access.
    /// </summary>
    public abstract class Credentials
    {
        /// <summary>
        /// Callback to acquire a credential object.
        /// </summary>
        /// <param name="cred">The newly created credential object.</param>
        /// <returns>0 for success, &lt; 0 to indicate an error, &gt; 0 to indicate no credential was acquired.</returns>
        protected internal abstract int GitCredentialHandler(out IntPtr cred);
    }

    /// <summary>
    /// Determines the pending operation of a git repository - ie, whether
    /// an operation (merge, cherry-pick, etc) is in progress.
    /// </summary>
    public enum CurrentOperation
    {
        /// <summary>
        /// No operation is in progress.
        /// </summary>
        None = 0,

        /// <summary>
        /// A merge is in progress.
        /// </summary>
        Merge = 1,

        /// <summary>
        /// A revert is in progress.
        /// </summary>
        Revert = 2,

        /// <summary>
        /// A sequencer revert is in progress.
        /// </summary>
        RevertSequence = 3,

        /// <summary>
        /// A cherry-pick is in progress.
        /// </summary>
        CherryPick = 4,

        /// <summary>
        /// A sequencer cherry-pick is in progress.
        /// </summary>
        CherryPickSequence = 5,

        /// <summary>
        /// A bisect is in progress.
        /// </summary>
        Bisect = 6,

        /// <summary>
        /// A rebase is in progress.
        /// </summary>
        Rebase = 7,

        /// <summary>
        /// A rebase --interactive is in progress.
        /// </summary>
        RebaseInteractive = 8,

        /// <summary>
        /// A rebase --merge is in progress.
        /// </summary>
        RebaseMerge = 9,

        /// <summary>
        /// A mailbox application (am) is in progress.
        /// </summary>
        ApplyMailbox = 10,

        /// <summary>
        /// A mailbox application (am) or rebase is in progress.
        /// </summary>
        ApplyMailboxOrRebase = 11,
    }

    /// <summary>
    /// A credential object that will provide the "default" credentials
    /// (logged-in user information) via NTLM or SPNEGO authentication.
    /// </summary>
    public sealed class DefaultCredentials : Credentials
    {
        /// <summary>
        /// Callback to acquire a credential object.
        /// </summary>
        /// <param name="cred">The newly created credential object.</param>
        /// <returns>0 for success, &lt; 0 to indicate an error, &gt; 0 to indicate no credential was acquired.</returns>
        protected internal override int GitCredentialHandler(out IntPtr cred)
        {
            return NativeMethods.git_credential_default_new(out cred);
        }
    }

    /// <summary>
    /// Options to define describe behaviour
    /// </summary>
    public sealed class DescribeOptions
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DescribeOptions"/> class.
        /// <para>
        ///   By default:
        ///    - Only annotated tags will be considered as reference points
        ///    - The commit id won't be used as a fallback strategy
        ///    - Only the 10 most recent tags will be considered as candidates to describe the commit
        ///    - All ancestor lines will be followed upon seeing a merge commit
        ///    - 7 hexacidemal digits will be used as a minimum commid abbreviated size
        ///    - Long format will only be used when no direct match has been found
        /// </para>
        /// </summary>
        public DescribeOptions()
        {
            Strategy = DescribeStrategy.Default;
            MinimumCommitIdAbbreviatedSize = 7;
            OnlyFollowFirstParent = false;
        }

        /// <summary>
        /// The kind of references that will be eligible as reference points.
        /// </summary>
        public DescribeStrategy Strategy { get; set; }

        /// <summary>
        /// Rather than throwing, should <see cref="IRepository.Describe"/> return
        /// the abbreviated commit id when the selected <see cref="Strategy"/>
        /// didn't identify a proper reference to describe the commit.
        /// </summary>
        public bool UseCommitIdAsFallback { get; set; }

        /// <summary>
        /// Number of minimum hexadecimal digits used to render a uniquely
        /// abbreviated commit id.
        /// </summary>
        public int MinimumCommitIdAbbreviatedSize { get; set; }

        /// <summary>
        /// Always output the long format (the tag, the number of commits
        /// and the abbreviated commit name) even when a direct match has been
        /// found.
        /// <para>
        ///   This is useful when one wants to see parts of the commit object
        ///   name in "describe" output, even when the commit in question happens
        ///   to be a tagged version. Instead of just emitting the tag name, it
        ///   will describe such a commit as v1.2-0-gdeadbee (0th commit since
        ///   tag v1.2 that points at object deadbee...).
        /// </para>
        /// </summary>
        public bool AlwaysRenderLongFormat { get; set; }

        /// <summary>
        /// Follow only the first parent commit upon seeing a merge commit.
        /// <para>
        ///   This is useful when you wish to not match tags on branches merged in
        ///   the history of the target commit.
        /// </para>
        /// </summary>
        public bool OnlyFollowFirstParent { get; set; }
    }

    /// <summary>
    /// Specify the kind of committish which will be considered
    /// when trying to identify the closest reference to the described commit.
    /// </summary>
    public enum DescribeStrategy
    {
        /// <summary>
        /// Only consider annotated tags.
        /// </summary>
        Default = 0,

        /// <summary>
        /// Consider both annotated and lightweight tags.
        /// <para>
        ///   This will match every reference under the <code>refs/tags/</code> namespace.
        /// </para>
        /// </summary>
        Tags,

        /// <summary>
        /// Consider annotated and lightweight tags, local and remote tracking branches.
        /// <para>
        ///   This will match every reference under the <code>refs/</code> namespace.
        /// </para>
        /// </summary>
        All,
    }

    internal class DetachedHead : Branch
    {
        internal DetachedHead(Repository repo, Reference reference)
            : base(repo, reference, "(no branch)")
        { }

        protected override string Shorten()
        {
            return CanonicalName;
        }

        /// <summary>
        /// Gets the remote branch which is connected to this local one, or null if there is none.
        /// </summary>
        public override Branch TrackedBranch
        {
            get { return null; }
        }
    }

    /// <summary>
    /// Show changes between the working tree and the index or a tree, changes between the index and a tree, changes between two trees, or changes between two files on disk.
    /// <para>
    ///   Copied and renamed files currently cannot be detected, as the feature is not supported by libgit2 yet.
    ///   These files will be shown as a pair of Deleted/Added files.</para>
    /// </summary>
    public class Diff
    {
        private readonly Repository repo;

        private static GitDiffOptions BuildOptions(DiffModifiers diffOptions, FilePath[] filePaths = null, MatchedPathsAggregator matchedPathsAggregator = null, CompareOptions compareOptions = null)
        {
            var options = new GitDiffOptions();

            options.Flags |= GitDiffOptionFlags.GIT_DIFF_INCLUDE_TYPECHANGE;

            compareOptions = compareOptions ?? new CompareOptions();
            options.ContextLines = (ushort)compareOptions.ContextLines;
            options.InterhunkLines = (ushort)compareOptions.InterhunkLines;

            if (diffOptions.HasFlag(DiffModifiers.IncludeUntracked))
            {
                options.Flags |= GitDiffOptionFlags.GIT_DIFF_INCLUDE_UNTRACKED |
                GitDiffOptionFlags.GIT_DIFF_RECURSE_UNTRACKED_DIRS |
                GitDiffOptionFlags.GIT_DIFF_SHOW_UNTRACKED_CONTENT;
            }

            if (diffOptions.HasFlag(DiffModifiers.IncludeIgnored))
            {
                options.Flags |= GitDiffOptionFlags.GIT_DIFF_INCLUDE_IGNORED |
                GitDiffOptionFlags.GIT_DIFF_RECURSE_IGNORED_DIRS;
            }

            if (diffOptions.HasFlag(DiffModifiers.IncludeUnmodified) || compareOptions.IncludeUnmodified ||
                (compareOptions.Similarity != null &&
                 (compareOptions.Similarity.RenameDetectionMode == RenameDetectionMode.CopiesHarder ||
                  compareOptions.Similarity.RenameDetectionMode == RenameDetectionMode.Exact)))
            {
                options.Flags |= GitDiffOptionFlags.GIT_DIFF_INCLUDE_UNMODIFIED;
            }

            if (compareOptions.Algorithm == DiffAlgorithm.Patience)
            {
                options.Flags |= GitDiffOptionFlags.GIT_DIFF_PATIENCE;
            }
            else if (compareOptions.Algorithm == DiffAlgorithm.Minimal)
            {
                options.Flags |= GitDiffOptionFlags.GIT_DIFF_MINIMAL;
            }

            if (diffOptions.HasFlag(DiffModifiers.DisablePathspecMatch))
            {
                options.Flags |= GitDiffOptionFlags.GIT_DIFF_DISABLE_PATHSPEC_MATCH;
            }

            if (compareOptions.IndentHeuristic)
            {
                options.Flags |= GitDiffOptionFlags.GIT_DIFF_INDENT_HEURISTIC;
            }

            if (matchedPathsAggregator != null)
            {
                options.NotifyCallback = matchedPathsAggregator.OnGitDiffNotify;
            }

            if (filePaths != null)
            {
                options.PathSpec = GitStrArrayManaged.BuildFrom(filePaths);
            }

            return options;
        }

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Diff()
        { }

        internal Diff(Repository repo)
        {
            this.repo = repo;
        }

        private static readonly IDictionary<DiffTargets, Func<Repository, TreeComparisonHandleRetriever>> HandleRetrieverDispatcher = BuildHandleRetrieverDispatcher();

        private static IDictionary<DiffTargets, Func<Repository, TreeComparisonHandleRetriever>> BuildHandleRetrieverDispatcher()
        {
            return new Dictionary<DiffTargets, Func<Repository, TreeComparisonHandleRetriever>>
                       {
                           { DiffTargets.Index, IndexToTree },
                           { DiffTargets.WorkingDirectory, WorkdirToTree },
                           { DiffTargets.Index | DiffTargets.WorkingDirectory, WorkdirAndIndexToTree },
                       };
        }

        private static readonly IDictionary<Type, Func<DiffHandle, object>> ChangesBuilders = new Dictionary<Type, Func<DiffHandle, object>>
        {
            { typeof(Patch), diff => new Patch(diff) },
            { typeof(TreeChanges), diff => new TreeChanges(diff) },
            { typeof(PatchStats), diff => new PatchStats(diff) },
        };

        private static T BuildDiffResult<T>(DiffHandle diff) where T : class, IDiffResult
        {
            Func<DiffHandle, object> builder;

            if (!ChangesBuilders.TryGetValue(typeof(T), out builder))
            {
                throw new LibGit2SharpException("User-defined types passed to Compare are not supported. Supported values are: {0}",
                    string.Join(", ", ChangesBuilders.Keys.Select(x => x.Name)));
            }

            return (T)builder(diff);
        }

        /// <summary>
        /// Show changes between two <see cref="Blob"/>s.
        /// </summary>
        /// <param name="oldBlob">The <see cref="Blob"/> you want to compare from.</param>
        /// <param name="newBlob">The <see cref="Blob"/> you want to compare to.</param>
        /// <returns>A <see cref="ContentChanges"/> containing the changes between the <paramref name="oldBlob"/> and the <paramref name="newBlob"/>.</returns>
        public virtual ContentChanges Compare(Blob oldBlob, Blob newBlob)
        {
            return Compare(oldBlob, newBlob, null);
        }

        /// <summary>
        /// Show changes between two <see cref="Blob"/>s.
        /// </summary>
        /// <param name="oldBlob">The <see cref="Blob"/> you want to compare from.</param>
        /// <param name="newBlob">The <see cref="Blob"/> you want to compare to.</param>
        /// <param name="compareOptions">Additional options to define comparison behavior.</param>
        /// <returns>A <see cref="ContentChanges"/> containing the changes between the <paramref name="oldBlob"/> and the <paramref name="newBlob"/>.</returns>
        public virtual ContentChanges Compare(Blob oldBlob, Blob newBlob, CompareOptions compareOptions)
        {
            using (GitDiffOptions options = BuildOptions(DiffModifiers.None, compareOptions: compareOptions))
            {
                return new ContentChanges(repo, oldBlob, newBlob, options);
            }
        }

        /// <summary>
        /// Show changes between two <see cref="Tree"/>s.
        /// </summary>
        /// <param name="oldTree">The <see cref="Tree"/> you want to compare from.</param>
        /// <param name="newTree">The <see cref="Tree"/> you want to compare to.</param>
        /// <returns>A <see cref="TreeChanges"/> containing the changes between the <paramref name="oldTree"/> and the <paramref name="newTree"/>.</returns>
        public virtual T Compare<T>(Tree oldTree, Tree newTree) where T : class, IDiffResult
        {
            return Compare<T>(oldTree, newTree, null, null, null);
        }

        /// <summary>
        /// Show changes between two <see cref="Tree"/>s.
        /// </summary>
        /// <param name="oldTree">The <see cref="Tree"/> you want to compare from.</param>
        /// <param name="newTree">The <see cref="Tree"/> you want to compare to.</param>
        /// <param name="paths">The list of paths (either files or directories) that should be compared.</param>
        /// <returns>A <see cref="TreeChanges"/> containing the changes between the <paramref name="oldTree"/> and the <paramref name="newTree"/>.</returns>
        public virtual T Compare<T>(Tree oldTree, Tree newTree, IEnumerable<string> paths) where T : class, IDiffResult
        {
            return Compare<T>(oldTree, newTree, paths, null, null);
        }

        /// <summary>
        /// Show changes between two <see cref="Tree"/>s.
        /// </summary>
        /// <param name="oldTree">The <see cref="Tree"/> you want to compare from.</param>
        /// <param name="newTree">The <see cref="Tree"/> you want to compare to.</param>
        /// <param name="paths">The list of paths (either files or directories) that should be compared.</param>
        /// <param name="explicitPathsOptions">
        /// If set, the passed <paramref name="paths"/> will be treated as explicit paths.
        /// Use these options to determine how unmatched explicit paths should be handled.
        /// </param>
        /// <returns>A <see cref="TreeChanges"/> containing the changes between the <paramref name="oldTree"/> and the <paramref name="newTree"/>.</returns>
        public virtual T Compare<T>(Tree oldTree, Tree newTree, IEnumerable<string> paths,
            ExplicitPathsOptions explicitPathsOptions) where T : class, IDiffResult
        {
            return Compare<T>(oldTree, newTree, paths, explicitPathsOptions, null);
        }

        /// <summary>
        /// Show changes between two <see cref="Tree"/>s.
        /// </summary>
        /// <param name="oldTree">The <see cref="Tree"/> you want to compare from.</param>
        /// <param name="newTree">The <see cref="Tree"/> you want to compare to.</param>
        /// <param name="paths">The list of paths (either files or directories) that should be compared.</param>
        /// <param name="compareOptions">Additional options to define patch generation behavior.</param>
        /// <returns>A <see cref="TreeChanges"/> containing the changes between the <paramref name="oldTree"/> and the <paramref name="newTree"/>.</returns>
        public virtual T Compare<T>(Tree oldTree, Tree newTree, IEnumerable<string> paths, CompareOptions compareOptions) where T : class, IDiffResult
        {
            return Compare<T>(oldTree, newTree, paths, null, compareOptions);
        }

        /// <summary>
        /// Show changes between two <see cref="Tree"/>s.
        /// </summary>
        /// <param name="oldTree">The <see cref="Tree"/> you want to compare from.</param>
        /// <param name="newTree">The <see cref="Tree"/> you want to compare to.</param>
        /// <param name="compareOptions">Additional options to define patch generation behavior.</param>
        /// <returns>A <see cref="TreeChanges"/> containing the changes between the <paramref name="oldTree"/> and the <paramref name="newTree"/>.</returns>
        public virtual T Compare<T>(Tree oldTree, Tree newTree, CompareOptions compareOptions) where T : class, IDiffResult
        {
            return Compare<T>(oldTree, newTree, null, null, compareOptions);
        }

        /// <summary>
        /// Show changes between two <see cref="Tree"/>s.
        /// </summary>
        /// <param name="oldTree">The <see cref="Tree"/> you want to compare from.</param>
        /// <param name="newTree">The <see cref="Tree"/> you want to compare to.</param>
        /// <param name="paths">The list of paths (either files or directories) that should be compared.</param>
        /// <param name="explicitPathsOptions">
        /// If set, the passed <paramref name="paths"/> will be treated as explicit paths.
        /// Use these options to determine how unmatched explicit paths should be handled.
        /// </param>
        /// <param name="compareOptions">Additional options to define patch generation behavior.</param>
        /// <returns>A <see cref="TreeChanges"/> containing the changes between the <paramref name="oldTree"/> and the <paramref name="newTree"/>.</returns>
        public virtual T Compare<T>(Tree oldTree, Tree newTree, IEnumerable<string> paths, ExplicitPathsOptions explicitPathsOptions,
                               CompareOptions compareOptions) where T : class, IDiffResult
        {
            var comparer = TreeToTree(repo);
            ObjectId oldTreeId = oldTree != null ? oldTree.Id : null;
            ObjectId newTreeId = newTree != null ? newTree.Id : null;
            var diffOptions = DiffModifiers.None;

            if (explicitPathsOptions != null)
            {
                diffOptions |= DiffModifiers.DisablePathspecMatch;

                if (explicitPathsOptions.ShouldFailOnUnmatchedPath || explicitPathsOptions.OnUnmatchedPath != null)
                {
                    diffOptions |= DiffModifiers.IncludeUnmodified;
                }
            }

            DiffHandle diff = BuildDiffList(oldTreeId, newTreeId, comparer, diffOptions, paths, explicitPathsOptions, compareOptions);

            try
            {
                return BuildDiffResult<T>(diff);
            }
            catch
            {
                diff.SafeDispose();
                throw;
            }
        }

        /// <summary>
        /// Show changes between a <see cref="Tree"/> and the Index, the Working Directory, or both.
        /// <para>
        /// The level of diff performed can be specified by passing either a <see cref="TreeChanges"/>
        /// or <see cref="Patch"/> type as the generic parameter.
        /// </para>
        /// </summary>
        /// <param name="oldTree">The <see cref="Tree"/> to compare from.</param>
        /// <param name="diffTargets">The targets to compare to.</param>
        /// <typeparam name="T">Can be either a <see cref="TreeChanges"/> if you are only interested in the list of files modified, added, ..., or
        /// a <see cref="Patch"/> if you want the actual patch content for the whole diff and for individual files.</typeparam>
        /// <returns>A <typeparamref name="T"/> containing the changes between the <see cref="Tree"/> and the selected target.</returns>
        public virtual T Compare<T>(Tree oldTree, DiffTargets diffTargets) where T : class, IDiffResult
        {
            return Compare<T>(oldTree, diffTargets, null, null, null);
        }

        /// <summary>
        /// Show changes between a <see cref="Tree"/> and the Index, the Working Directory, or both.
        /// <para>
        /// The level of diff performed can be specified by passing either a <see cref="TreeChanges"/>
        /// or <see cref="Patch"/> type as the generic parameter.
        /// </para>
        /// </summary>
        /// <param name="oldTree">The <see cref="Tree"/> to compare from.</param>
        /// <param name="diffTargets">The targets to compare to.</param>
        /// <param name="paths">The list of paths (either files or directories) that should be compared.</param>
        /// <typeparam name="T">Can be either a <see cref="TreeChanges"/> if you are only interested in the list of files modified, added, ..., or
        /// a <see cref="Patch"/> if you want the actual patch content for the whole diff and for individual files.</typeparam>
        /// <returns>A <typeparamref name="T"/> containing the changes between the <see cref="Tree"/> and the selected target.</returns>
        public virtual T Compare<T>(Tree oldTree, DiffTargets diffTargets, IEnumerable<string> paths) where T : class, IDiffResult
        {
            return Compare<T>(oldTree, diffTargets, paths, null, null);
        }

        /// <summary>
        /// Show changes between a <see cref="Tree"/> and the Index, the Working Directory, or both.
        /// <para>
        /// The level of diff performed can be specified by passing either a <see cref="TreeChanges"/>
        /// or <see cref="Patch"/> type as the generic parameter.
        /// </para>
        /// </summary>
        /// <param name="oldTree">The <see cref="Tree"/> to compare from.</param>
        /// <param name="diffTargets">The targets to compare to.</param>
        /// <param name="paths">The list of paths (either files or directories) that should be compared.</param>
        /// <param name="explicitPathsOptions">
        /// If set, the passed <paramref name="paths"/> will be treated as explicit paths.
        /// Use these options to determine how unmatched explicit paths should be handled.
        /// </param>
        /// <typeparam name="T">Can be either a <see cref="TreeChanges"/> if you are only interested in the list of files modified, added, ..., or
        /// a <see cref="Patch"/> if you want the actual patch content for the whole diff and for individual files.</typeparam>
        /// <returns>A <typeparamref name="T"/> containing the changes between the <see cref="Tree"/> and the selected target.</returns>
        public virtual T Compare<T>(Tree oldTree, DiffTargets diffTargets, IEnumerable<string> paths,
            ExplicitPathsOptions explicitPathsOptions) where T : class, IDiffResult
        {
            return Compare<T>(oldTree, diffTargets, paths, explicitPathsOptions, null);
        }

        /// <summary>
        /// Show changes between a <see cref="Tree"/> and the Index, the Working Directory, or both.
        /// <para>
        /// The level of diff performed can be specified by passing either a <see cref="TreeChanges"/>
        /// or <see cref="Patch"/> type as the generic parameter.
        /// </para>
        /// </summary>
        /// <param name="oldTree">The <see cref="Tree"/> to compare from.</param>
        /// <param name="diffTargets">The targets to compare to.</param>
        /// <param name="paths">The list of paths (either files or directories) that should be compared.</param>
        /// <param name="explicitPathsOptions">
        /// If set, the passed <paramref name="paths"/> will be treated as explicit paths.
        /// Use these options to determine how unmatched explicit paths should be handled.
        /// </param>
        /// <param name="compareOptions">Additional options to define patch generation behavior.</param>
        /// <typeparam name="T">Can be either a <see cref="TreeChanges"/> if you are only interested in the list of files modified, added, ..., or
        /// a <see cref="Patch"/> if you want the actual patch content for the whole diff and for individual files.</typeparam>
        /// <returns>A <typeparamref name="T"/> containing the changes between the <see cref="Tree"/> and the selected target.</returns>
        public virtual T Compare<T>(Tree oldTree, DiffTargets diffTargets, IEnumerable<string> paths,
            ExplicitPathsOptions explicitPathsOptions, CompareOptions compareOptions) where T : class, IDiffResult
        {
            var comparer = HandleRetrieverDispatcher[diffTargets](repo);
            ObjectId oldTreeId = oldTree != null ? oldTree.Id : null;

            DiffModifiers diffOptions = diffTargets.HasFlag(DiffTargets.WorkingDirectory)
                ? DiffModifiers.IncludeUntracked
                : DiffModifiers.None;

            if (explicitPathsOptions != null)
            {
                diffOptions |= DiffModifiers.DisablePathspecMatch;

                if (explicitPathsOptions.ShouldFailOnUnmatchedPath || explicitPathsOptions.OnUnmatchedPath != null)
                {
                    diffOptions |= DiffModifiers.IncludeUnmodified;
                }
            }

            DiffHandle diff = BuildDiffList(oldTreeId, null, comparer, diffOptions, paths, explicitPathsOptions, compareOptions);

            try
            {
                return BuildDiffResult<T>(diff);
            }
            catch
            {
                diff.SafeDispose();
                throw;
            }
        }

        /// <summary>
        /// Show changes between the working directory and the index.
        /// <para>
        /// The level of diff performed can be specified by passing either a <see cref="TreeChanges"/>
        /// or <see cref="Patch"/> type as the generic parameter.
        /// </para>
        /// </summary>
        /// <typeparam name="T">Can be either a <see cref="TreeChanges"/> if you are only interested in the list of files modified, added, ..., or
        /// a <see cref="Patch"/> if you want the actual patch content for the whole diff and for individual files.</typeparam>
        /// <returns>A <typeparamref name="T"/> containing the changes between the working directory and the index.</returns>
        public virtual T Compare<T>() where T : class, IDiffResult
        {
            return Compare<T>(DiffModifiers.None);
        }

        /// <summary>
        /// Show changes between the working directory and the index.
        /// <para>
        /// The level of diff performed can be specified by passing either a <see cref="TreeChanges"/>
        /// or <see cref="Patch"/> type as the generic parameter.
        /// </para>
        /// </summary>
        /// <param name="paths">The list of paths (either files or directories) that should be compared.</param>
        /// <typeparam name="T">Can be either a <see cref="TreeChanges"/> if you are only interested in the list of files modified, added, ..., or
        /// a <see cref="Patch"/> if you want the actual patch content for the whole diff and for individual files.</typeparam>
        /// <returns>A <typeparamref name="T"/> containing the changes between the working directory and the index.</returns>
        public virtual T Compare<T>(IEnumerable<string> paths) where T : class, IDiffResult
        {
            return Compare<T>(DiffModifiers.None, paths);
        }

        /// <summary>
        /// Show changes between the working directory and the index.
        /// <para>
        /// The level of diff performed can be specified by passing either a <see cref="TreeChanges"/>
        /// or <see cref="Patch"/> type as the generic parameter.
        /// </para>
        /// </summary>
        /// <param name="paths">The list of paths (either files or directories) that should be compared.</param>
        /// <param name="includeUntracked">If true, include untracked files from the working dir as additions. Otherwise ignore them.</param>
        /// <typeparam name="T">Can be either a <see cref="TreeChanges"/> if you are only interested in the list of files modified, added, ..., or
        /// a <see cref="Patch"/> if you want the actual patch content for the whole diff and for individual files.</typeparam>
        /// <returns>A <typeparamref name="T"/> containing the changes between the working directory and the index.</returns>
        public virtual T Compare<T>(IEnumerable<string> paths, bool includeUntracked) where T : class, IDiffResult
        {
            return Compare<T>(includeUntracked ? DiffModifiers.IncludeUntracked : DiffModifiers.None, paths);
        }

        /// <summary>
        /// Show changes between the working directory and the index.
        /// <para>
        /// The level of diff performed can be specified by passing either a <see cref="TreeChanges"/>
        /// or <see cref="Patch"/> type as the generic parameter.
        /// </para>
        /// </summary>
        /// <param name="paths">The list of paths (either files or directories) that should be compared.</param>
        /// <param name="includeUntracked">If true, include untracked files from the working dir as additions. Otherwise ignore them.</param>
        /// <param name="explicitPathsOptions">
        /// If set, the passed <paramref name="paths"/> will be treated as explicit paths.
        /// Use these options to determine how unmatched explicit paths should be handled.
        /// </param>
        /// <typeparam name="T">Can be either a <see cref="TreeChanges"/> if you are only interested in the list of files modified, added, ..., or
        /// a <see cref="Patch"/> if you want the actual patch content for the whole diff and for individual files.</typeparam>
        /// <returns>A <typeparamref name="T"/> containing the changes between the working directory and the index.</returns>
        public virtual T Compare<T>(IEnumerable<string> paths, bool includeUntracked, ExplicitPathsOptions explicitPathsOptions) where T : class, IDiffResult
        {
            return Compare<T>(includeUntracked ? DiffModifiers.IncludeUntracked : DiffModifiers.None, paths, explicitPathsOptions);
        }

        /// <summary>
        /// Show changes between the working directory and the index.
        /// <para>
        /// The level of diff performed can be specified by passing either a <see cref="TreeChanges"/>
        /// or <see cref="Patch"/> type as the generic parameter.
        /// </para>
        /// </summary>
        /// <param name="paths">The list of paths (either files or directories) that should be compared.</param>
        /// <param name="includeUntracked">If true, include untracked files from the working dir as additions. Otherwise ignore them.</param>
        /// <param name="explicitPathsOptions">
        /// If set, the passed <paramref name="paths"/> will be treated as explicit paths.
        /// Use these options to determine how unmatched explicit paths should be handled.
        /// </param>
        /// <param name="compareOptions">Additional options to define patch generation behavior.</param>
        /// <typeparam name="T">Can be either a <see cref="TreeChanges"/> if you are only interested in the list of files modified, added, ..., or
        /// a <see cref="Patch"/> if you want the actual patch content for the whole diff and for individual files.</typeparam>
        /// <returns>A <typeparamref name="T"/> containing the changes between the working directory and the index.</returns>
        public virtual T Compare<T>(
            IEnumerable<string> paths,
            bool includeUntracked,
            ExplicitPathsOptions explicitPathsOptions,
            CompareOptions compareOptions) where T : class, IDiffResult
        {
            return Compare<T>(includeUntracked ? DiffModifiers.IncludeUntracked : DiffModifiers.None, paths, explicitPathsOptions, compareOptions);
        }

        internal virtual T Compare<T>(
            DiffModifiers diffOptions,
            IEnumerable<string> paths = null,
            ExplicitPathsOptions explicitPathsOptions = null,
            CompareOptions compareOptions = null) where T : class, IDiffResult
        {
            var comparer = WorkdirToIndex(repo);

            if (explicitPathsOptions != null)
            {
                diffOptions |= DiffModifiers.DisablePathspecMatch;

                if (explicitPathsOptions.ShouldFailOnUnmatchedPath || explicitPathsOptions.OnUnmatchedPath != null)
                {
                    diffOptions |= DiffModifiers.IncludeUnmodified;
                }
            }

            DiffHandle diff = BuildDiffList(null, null, comparer, diffOptions, paths, explicitPathsOptions, compareOptions);

            try
            {
                return BuildDiffResult<T>(diff);
            }
            catch
            {
                diff.SafeDispose();
                throw;
            }
        }

        internal delegate DiffHandle TreeComparisonHandleRetriever(ObjectId oldTreeId, ObjectId newTreeId, GitDiffOptions options);

        private static TreeComparisonHandleRetriever TreeToTree(Repository repo)
        {
            return (oh, nh, o) => Proxy.git_diff_tree_to_tree(repo.Handle, oh, nh, o);
        }

        private static TreeComparisonHandleRetriever WorkdirToIndex(Repository repo)
        {
            return (oh, nh, o) => Proxy.git_diff_index_to_workdir(repo.Handle, repo.Index.Handle, o);
        }

        private static TreeComparisonHandleRetriever WorkdirToTree(Repository repo)
        {
            return (oh, nh, o) => Proxy.git_diff_tree_to_workdir(repo.Handle, oh, o);
        }

        private static TreeComparisonHandleRetriever WorkdirAndIndexToTree(Repository repo)
        {
            TreeComparisonHandleRetriever comparisonHandleRetriever = (oh, nh, o) =>
            {
                DiffHandle diff = Proxy.git_diff_tree_to_index(repo.Handle, repo.Index.Handle, oh, o);

                using (DiffHandle diff2 = Proxy.git_diff_index_to_workdir(repo.Handle, repo.Index.Handle, o))
                {
                    Proxy.git_diff_merge(diff, diff2);
                }

                return diff;
            };

            return comparisonHandleRetriever;
        }

        private static TreeComparisonHandleRetriever IndexToTree(Repository repo)
        {
            return (oh, nh, o) => Proxy.git_diff_tree_to_index(repo.Handle, repo.Index.Handle, oh, o);
        }

        private DiffHandle BuildDiffList(
            ObjectId oldTreeId,
            ObjectId newTreeId,
            TreeComparisonHandleRetriever comparisonHandleRetriever,
            DiffModifiers diffOptions,
            IEnumerable<string> paths,
            ExplicitPathsOptions explicitPathsOptions,
            CompareOptions compareOptions)
        {
            var filePaths = repo.ToFilePaths(paths);

            MatchedPathsAggregator matchedPaths = null;

            // We can't match paths unless we've got something to match
            // against and we're told to do so.
            if (filePaths != null && explicitPathsOptions != null)
            {
                if (explicitPathsOptions.OnUnmatchedPath != null || explicitPathsOptions.ShouldFailOnUnmatchedPath)
                {
                    matchedPaths = new MatchedPathsAggregator();
                }
            }

            using (GitDiffOptions options = BuildOptions(diffOptions, filePaths, matchedPaths, compareOptions))
            {
                var diffList = comparisonHandleRetriever(oldTreeId, newTreeId, options);

                if (matchedPaths != null)
                {
                    try
                    {
                        DispatchUnmatchedPaths(explicitPathsOptions, filePaths, matchedPaths);
                    }
                    catch
                    {
                        diffList.Dispose();
                        throw;
                    }
                }

                DetectRenames(diffList, compareOptions);

                return diffList;
            }
        }

        private static void DetectRenames(DiffHandle diffList, CompareOptions compareOptions)
        {
            var similarityOptions = (compareOptions == null) ? null : compareOptions.Similarity;
            if (similarityOptions == null || similarityOptions.RenameDetectionMode == RenameDetectionMode.Default)
            {
                Proxy.git_diff_find_similar(diffList, null);
                return;
            }

            if (similarityOptions.RenameDetectionMode == RenameDetectionMode.None)
            {
                return;
            }

            var opts = new GitDiffFindOptions
            {
                RenameThreshold = (ushort)similarityOptions.RenameThreshold,
                RenameFromRewriteThreshold = (ushort)similarityOptions.RenameFromRewriteThreshold,
                CopyThreshold = (ushort)similarityOptions.CopyThreshold,
                BreakRewriteThreshold = (ushort)similarityOptions.BreakRewriteThreshold,
                RenameLimit = (UIntPtr)similarityOptions.RenameLimit,
            };

            switch (similarityOptions.RenameDetectionMode)
            {
                case RenameDetectionMode.Exact:
                    opts.Flags = GitDiffFindFlags.GIT_DIFF_FIND_EXACT_MATCH_ONLY |
                                 GitDiffFindFlags.GIT_DIFF_FIND_RENAMES |
                                 GitDiffFindFlags.GIT_DIFF_FIND_COPIES |
                                 GitDiffFindFlags.GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED;
                    break;
                case RenameDetectionMode.Renames:
                    opts.Flags = GitDiffFindFlags.GIT_DIFF_FIND_RENAMES;
                    break;
                case RenameDetectionMode.Copies:
                    opts.Flags = GitDiffFindFlags.GIT_DIFF_FIND_RENAMES |
                                 GitDiffFindFlags.GIT_DIFF_FIND_COPIES;
                    break;
                case RenameDetectionMode.CopiesHarder:
                    opts.Flags = GitDiffFindFlags.GIT_DIFF_FIND_RENAMES |
                                 GitDiffFindFlags.GIT_DIFF_FIND_COPIES |
                                 GitDiffFindFlags.GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED;
                    break;
            }

            if (!compareOptions.IncludeUnmodified)
            {
                opts.Flags |= GitDiffFindFlags.GIT_DIFF_FIND_REMOVE_UNMODIFIED;
            }

            switch (similarityOptions.WhitespaceMode)
            {
                case WhitespaceMode.DontIgnoreWhitespace:
                    opts.Flags |= GitDiffFindFlags.GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE;
                    break;
                case WhitespaceMode.IgnoreLeadingWhitespace:
                    opts.Flags |= GitDiffFindFlags.GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE;
                    break;
                case WhitespaceMode.IgnoreAllWhitespace:
                    opts.Flags |= GitDiffFindFlags.GIT_DIFF_FIND_IGNORE_WHITESPACE;
                    break;
            }

            Proxy.git_diff_find_similar(diffList, opts);
        }

        private static void DispatchUnmatchedPaths(
            ExplicitPathsOptions explicitPathsOptions,
            IEnumerable<FilePath> filePaths,
            IEnumerable<FilePath> matchedPaths)
        {
            List<FilePath> unmatchedPaths = (filePaths != null ?
                filePaths.Except(matchedPaths) : Enumerable.Empty<FilePath>()).ToList();

            if (!unmatchedPaths.Any())
            {
                return;
            }

            if (explicitPathsOptions.OnUnmatchedPath != null)
            {
                unmatchedPaths.ForEach(filePath => explicitPathsOptions.OnUnmatchedPath(filePath.Native));
            }

            if (explicitPathsOptions.ShouldFailOnUnmatchedPath)
            {
                throw new UnmatchedPathException(BuildUnmatchedPathsMessage(unmatchedPaths));
            }
        }

        private static string BuildUnmatchedPathsMessage(List<FilePath> unmatchedPaths)
        {
            var message = new StringBuilder("There were some unmatched paths:" + Environment.NewLine);
            unmatchedPaths.ForEach(filePath => message.AppendFormat("- {0}{1}", filePath.Native, Environment.NewLine));

            return message.ToString();
        }
    }

    /// <summary>
    /// Algorithm used when performing a Diff.
    /// </summary>
    public enum DiffAlgorithm
    {
        /// <summary>
        /// The basic greedy diff algorithm.
        /// </summary>
        Myers = 0,

        /// <summary>
        /// Use "minimal diff" algorithm when generating patches.
        /// </summary>
        Minimal = 1,

        /// <summary>
        /// Use "patience diff" algorithm when generating patches.
        /// </summary>
        Patience = 2,
    }

    /// <summary>
    /// Additional behaviors the diffing should take into account
    /// when performing the comparison.
    /// </summary>
    [Flags]
    internal enum DiffModifiers
    {
        /// <summary>
        /// No special behavior.
        /// </summary>
        None = 0,

        /// <summary>
        /// Include untracked files among the files to be processed, when
        /// diffing against the working directory.
        /// </summary>
        IncludeUntracked = (1 << 1),

        /// <summary>
        /// Include unmodified files among the files to be processed, when
        /// diffing against the working directory.
        /// </summary>
        IncludeUnmodified = (1 << 2),

        /// <summary>
        /// Treats the passed pathspecs as explicit paths (no pathspec match).
        /// </summary>
        DisablePathspecMatch = (1 << 3),

        /// <summary>
        /// Include ignored files among the files to be processed, when
        /// diffing against the working directory.
        /// </summary>
        IncludeIgnored = (1 << 4),
    }

    /// <summary>
    /// The targets of a Tree based diff comparison.
    /// </summary>
    [Flags]
    public enum DiffTargets
    {
        /// <summary>
        /// The repository index.
        /// </summary>
        Index = 1,

        /// <summary>
        /// The working directory.
        /// </summary>
        WorkingDirectory = 2,
    }

    /// <summary>
    /// A DirectReference points directly to a <see cref="GitObject"/>
    /// </summary>
    public class DirectReference : Reference
    {
        private readonly Lazy<GitObject> targetBuilder;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected DirectReference()
        { }

        internal DirectReference(string canonicalName, IRepository repo, ObjectId targetId)
            : base(repo, canonicalName, targetId.Sha)
        {
            targetBuilder = new Lazy<GitObject>(() =>
            {
                if (repo == null)
                {
                    throw new InvalidOperationException("Target requires a local repository");
                }

                return repo.Lookup(targetId);
            });
        }

        /// <summary>
        /// Gets the target of this <see cref="DirectReference"/>
        /// </summary>
        /// <exception cref="InvalidOperationException">Throws if Local Repository is not set.</exception>
        public virtual GitObject Target
        {
            get { return targetBuilder.Value; }
        }

        /// <summary>
        /// As a <see cref="DirectReference"/> is already peeled, invoking this will return the same <see cref="DirectReference"/>.
        /// </summary>
        /// <returns>This instance.</returns>
        public override DirectReference ResolveToDirectReference()
        {
            return this;
        }
    }

    /// <summary>
    /// The exception that is thrown when a commit would create an "empty"
    /// commit that is treesame to its parent without an explicit override.
    /// </summary>
    [Serializable]
    public class EmptyCommitException : LibGit2SharpException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EmptyCommitException"/> class.
        /// </summary>
        public EmptyCommitException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="EmptyCommitException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public EmptyCommitException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="EmptyCommitException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public EmptyCommitException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="EmptyCommitException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public EmptyCommitException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="EmptyCommitException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected EmptyCommitException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }
    }

    /// <summary>
    /// The exception that is thrown attempting to create a resource that already exists.
    /// </summary>
    [Serializable]
    public class EntryExistsException : LibGit2SharpException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.EntryExistsException"/> class.
        /// </summary>
        public EntryExistsException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.EntryExistsException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public EntryExistsException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.EntryExistsException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public EntryExistsException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.EntryExistsException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public EntryExistsException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.EntryExistsException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected EntryExistsException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal EntryExistsException(string message, GitErrorCode code, GitErrorCategory category)
            : base(message, code, category)
        { }
    }

    /// <summary>
    /// Allows callers to specify how unmatched paths should be handled
    /// by operations such as Reset(), Compare(), Unstage(), ...
    /// <para>
    ///   By passing these options, the passed paths will be treated as
    ///   explicit paths, and NOT pathspecs containing globs.
    /// </para>
    /// </summary>
    public sealed class ExplicitPathsOptions
    {
        /// <summary>
        /// Associated paths will be treated as explicit paths.
        /// </summary>
        public ExplicitPathsOptions()
        {
            ShouldFailOnUnmatchedPath = true;
        }

        /// <summary>
        /// When set to true, the called operation will throw a <see cref="UnmatchedPathException"/> when an unmatched
        /// path is encountered.
        /// <para>
        ///   Set to true by default.
        /// </para>
        /// </summary>
        public bool ShouldFailOnUnmatchedPath { get; set; }

        /// <summary>
        /// Sets a callback that will be called once for each unmatched path.
        /// </summary>
        public UnmatchedPathHandler OnUnmatchedPath { get; set; }
    }

    /// <summary>
    /// Represents a local reference data from a remote repository which
    /// has been retreived through a Fetch process.
    /// </summary>
    internal class FetchHead : ReferenceWrapper<GitObject>
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected FetchHead()
        { }

        internal FetchHead(
            Repository repo,
            string remoteCanonicalName,
            string url,
            ObjectId targetId,
            bool forMerge,
            int index)
            : base(repo,
                   new DirectReference(string.Format(CultureInfo.InvariantCulture,
                                                     "FETCH_HEAD[{0}]",
                                                     index),
                                       repo,
                                       targetId),
                   r => r.CanonicalName)
        {
            Url = url;
            ForMerge = forMerge;
            RemoteCanonicalName = remoteCanonicalName;
        }

        /// <summary>
        /// Returns "FETCH_HEAD[i]", where i is the index of this fetch head.
        /// </summary>
        protected override string Shorten()
        {
            return CanonicalName;
        }

        /// <summary>
        /// Gets the canonical name of the reference this <see cref="FetchHead"/>
        /// points to in the remote repository it's been fetched from.
        /// </summary>
        public virtual string RemoteCanonicalName { get; private set; }

        /// <summary>
        /// Gets the <see cref="GitObject"/> that this fetch head points to.
        /// </summary>
        public virtual GitObject Target
        {
            get { return TargetObject; }
        }

        /// <summary>
        /// The URL of the remote repository this <see cref="FetchHead"/>
        /// has been built from.
        /// </summary>
        public virtual String Url { get; private set; }

        /// <summary>
        /// Determines if this fetch head entry has been explicitly fetched.
        /// </summary>
        public virtual bool ForMerge { get; private set; }
    }

    /// <summary>
    /// Collection of parameters controlling Fetch behavior.
    /// </summary>
    public sealed class FetchOptions : FetchOptionsBase
    {
        /// <summary>
        /// Specifies the tag-following behavior of the fetch operation.
        /// <para>
        /// If not set, the fetch operation will follow the default behavior for the <see cref="Remote"/>
        /// based on the remote's <see cref="Remote.TagFetchMode"/> configuration.
        /// </para>
        /// <para>If neither this property nor the remote `tagopt` configuration is set,
        /// this will default to <see cref="F:TagFetchMode.Auto"/> (i.e. tags that point to objects
        /// retrieved during this fetch will be retrieved as well).</para>
        /// </summary>
        public TagFetchMode? TagFetchMode { get; set; }

        /// <summary>
        /// Specifies the pruning behaviour for the fetch operation
        /// <para>
        /// If not set, the configuration's setting will take effect. If true, the branches which no longer
        /// exist on the remote will be removed from the remote-tracking branches.
        /// </para>
        /// </summary>
        public bool? Prune { get; set; }

        /// <summary>
        /// Get/Set the custom headers.
        ///
        /// <para>
        /// This allows you to set custom headers (e.g. X-Forwarded-For,
        /// X-Request-Id, etc),
        /// </para>
        /// </summary>
        /// <remarks>
        /// Libgit2 sets some headers for HTTP requests (User-Agent, Host,
        /// Accept, Content-Type, Transfer-Encoding, Content-Length, Accept) that
        /// cannot be overriden.
        /// </remarks>
        /// <example>
        /// var fetchOptions - new FetchOptions() {
        ///     CustomHeaders = new String[] {"X-Request-Id: 12345"}
        /// };
        /// </example>
        /// <value>The custom headers string array</value>
        public string[] CustomHeaders { get; set; }
    }

    /// <summary>
    /// Base collection of parameters controlling Fetch behavior.
    /// </summary>
    public abstract class FetchOptionsBase
    {
        internal FetchOptionsBase()
        { }

        /// <summary>
        /// Handler for network transfer and indexing progress information.
        /// </summary>
        public ProgressHandler OnProgress { get; set; }

        /// <summary>
        /// Handler for updates to remote tracking branches.
        /// </summary>
        public UpdateTipsHandler OnUpdateTips { get; set; }

        /// <summary>
        /// Handler for data transfer progress.
        /// <para>
        /// Reports the client's state regarding the received and processed (bytes, objects) from the server.
        /// </para>
        /// </summary>
        public TransferProgressHandler OnTransferProgress { get; set; }

        /// <summary>
        /// Handler to generate <see cref="LibGit2Sharp.Credentials"/> for authentication.
        /// </summary>
        public CredentialsHandler CredentialsProvider { get; set; }

        /// <summary>
        /// This handler will be called to let the user make a decision on whether to allow
        /// the connection to proceed based on the certificate presented by the server.
        /// </summary>
        public CertificateCheckHandler CertificateCheck { get; set; }

        /// <summary>
        /// Starting to operate on a new repository.
        /// </summary>
        public RepositoryOperationStarting RepositoryOperationStarting { get; set; }

        /// <summary>
        /// Completed operating on the current repository.
        /// </summary>
        public RepositoryOperationCompleted RepositoryOperationCompleted { get; set; }

        /// <summary>
        /// Options for connecting through a proxy.
        /// </summary>
        public ProxyOptions ProxyOptions = new ProxyOptions();
    }

    /// <summary>
    /// Calculated status of a filepath in the working directory considering the current <see cref="Repository.Index"/> and the <see cref="Repository.Head"/>.
    /// </summary>
    [Flags]
    public enum FileStatus
    {
        /// <summary>
        /// The file doesn't exist.
        /// </summary>
        Nonexistent = (1 << 31),

        /// <summary>
        /// The file hasn't been modified.
        /// </summary>
        Unaltered = 0, /* GIT_STATUS_CURRENT */

        /// <summary>
        /// New file has been added to the Index. It's unknown from the Head.
        /// </summary>
        NewInIndex = (1 << 0), /* GIT_STATUS_INDEX_NEW */

        /// <summary>
        /// New version of a file has been added to the Index. A previous version exists in the Head.
        /// </summary>
        ModifiedInIndex = (1 << 1), /* GIT_STATUS_INDEX_MODIFIED */

        /// <summary>
        /// The deletion of a file has been promoted from the working directory to the Index. A previous version exists in the Head.
        /// </summary>
        DeletedFromIndex = (1 << 2), /* GIT_STATUS_INDEX_DELETED */

        /// <summary>
        /// The renaming of a file has been promoted from the working directory to the Index. A previous version exists in the Head.
        /// </summary>
        RenamedInIndex = (1 << 3), /* GIT_STATUS_INDEX_RENAMED */

        /// <summary>
        /// A change in type for a file has been promoted from the working directory to the Index. A previous version exists in the Head.
        /// </summary>
        TypeChangeInIndex = (1 << 4), /* GIT_STATUS_INDEX_TYPECHANGE */

        /// <summary>
        /// New file in the working directory, unknown from the Index and the Head.
        /// </summary>
        NewInWorkdir = (1 << 7), /* GIT_STATUS_WT_NEW */

        /// <summary>
        /// The file has been updated in the working directory. A previous version exists in the Index.
        /// </summary>
        ModifiedInWorkdir = (1 << 8), /* GIT_STATUS_WT_MODIFIED */

        /// <summary>
        /// The file has been deleted from the working directory. A previous version exists in the Index.
        /// </summary>
        DeletedFromWorkdir = (1 << 9), /* GIT_STATUS_WT_DELETED */

        /// <summary>
        /// The file type has been changed in the working directory. A previous version exists in the Index.
        /// </summary>
        TypeChangeInWorkdir = (1 << 10), /* GIT_STATUS_WT_TYPECHANGE */

        /// <summary>
        /// The file has been renamed in the working directory.  The previous version at the previous name exists in the Index.
        /// </summary>
        RenamedInWorkdir = (1 << 11), /* GIT_STATUS_WT_RENAMED */

        /// <summary>
        /// The file is unreadable in the working directory.
        /// </summary>
        Unreadable = (1 << 12), /* GIT_STATUS_WT_UNREADABLE */

        /// <summary>
        /// The file is <see cref="NewInWorkdir"/> but its name and/or path matches an exclude pattern in a <c>gitignore</c> file.
        /// </summary>
        Ignored = (1 << 14), /* GIT_STATUS_IGNORED */

        /// <summary>
        /// The file is <see cref="Conflicted"/> due to a merge.
        /// </summary>
        Conflicted = (1 << 15), /* GIT_STATUS_CONFLICTED */
    }

    /// <summary>
    /// A filter is a way to execute code against a file as it moves to and from the git
    /// repository and into the working directory.
    /// </summary>
    public abstract class Filter : IEquatable<Filter>
    {
        private static readonly LambdaEqualityHelper<Filter> equalityHelper =
            new LambdaEqualityHelper<Filter>(x => x.Name, x => x.Attributes);
        // 64K is optimal buffer size per https://technet.microsoft.com/en-us/library/cc938632.aspx
        private const int BufferSize = 64 * 1024;

        /// <summary>
        /// Initializes a new instance of the <see cref="Filter"/> class.
        /// And allocates the filter natively.
        /// <param name="name">The unique name with which this filtered is registered with</param>
        /// <param name="attributes">A list of attributes which this filter applies to</param>
        /// </summary>
        protected Filter(string name, IEnumerable<FilterAttributeEntry> attributes)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");
            Ensure.ArgumentNotNull(attributes, "attributes");

            this.name = name;
            this.attributes = attributes;
            var attributesAsString = string.Join(",", this.attributes.Select(attr => attr.FilterDefinition));

            gitFilter = new GitFilter
            {
                attributes = EncodingMarshaler.FromManaged(Encoding.UTF8, attributesAsString),
                init = InitializeCallback,
                stream = StreamCreateCallback,
            };
        }
        /// <summary>
        /// Finalizer called by the <see cref="GC"/>, deregisters and frees native memory associated with the registered filter in libgit2.
        /// </summary>
        ~Filter()
        {
            GlobalSettings.DeregisterFilter(this);

#if LEAKS_IDENTIFYING
            int activeStreamCount = activeStreams.Count;
            if (activeStreamCount > 0)
            {
                Trace.WriteLine(string.Format(CultureInfo.InvariantCulture, "{0} leaked {1} stream handles at finalization", GetType().Name, activeStreamCount));
            }
#endif
        }

        private readonly string name;
        private readonly IEnumerable<FilterAttributeEntry> attributes;
        private readonly GitFilter gitFilter;
        private readonly ConcurrentDictionary<IntPtr, StreamState> activeStreams = new ConcurrentDictionary<IntPtr, StreamState>();

        /// <summary>
        /// State bag used to keep necessary reference from being
        /// garbage collected during filter processing.
        /// </summary>
        private class StreamState
        {
            public GitWriteStream thisStream;
            public GitWriteStream nextStream;
            public IntPtr thisPtr;
            public IntPtr nextPtr;
            public FilterSource filterSource;
            public Stream output;
        }

        /// <summary>
        /// The name that this filter was registered with
        /// </summary>
        public string Name
        {
            get { return name; }
        }

        /// <summary>
        /// The filter filterForAttributes.
        /// </summary>
        public IEnumerable<FilterAttributeEntry> Attributes
        {
            get { return attributes; }
        }

        /// <summary>
        /// The marshalled filter
        /// </summary>
        internal GitFilter GitFilter
        {
            get { return gitFilter; }
        }

        /// <summary>
        /// Complete callback on filter
        ///
        /// This optional callback will be invoked when the upstream filter is
        /// closed. Gives the filter a chance to perform any final actions or
        /// necissary clean up.
        /// </summary>
        /// <param name="path">The path of the file being filtered</param>
        /// <param name="root">The path of the working directory for the owning repository</param>
        /// <param name="output">Output to the downstream filter or output writer</param>
        protected virtual void Complete(string path, string root, Stream output)
        { }

        /// <summary>
        /// Initialize callback on filter
        ///
        /// Specified as `filter.initialize`, this is an optional callback invoked
        /// before a filter is first used.  It will be called once at most.
        ///
        /// If non-NULL, the filter's `initialize` callback will be invoked right
        /// before the first use of the filter, so you can defer expensive
        /// initialization operations (in case the library is being used in a way
        /// that doesn't need the filter.
        /// </summary>
        protected virtual void Initialize()
        { }

        /// <summary>
        /// Indicates that a filter is going to be applied for the given file for
        /// the given mode.
        /// </summary>
        /// <param name="path">The path of the file being filtered</param>
        /// <param name="root">The path of the working directory for the owning repository</param>
        /// <param name="mode">The filter mode</param>
        protected virtual void Create(string path, string root, FilterMode mode)
        { }

        /// <summary>
        /// Clean the input stream and write to the output stream.
        /// </summary>
        /// <param name="path">The path of the file being filtered</param>
        /// <param name="root">The path of the working directory for the owning repository</param>
        /// <param name="input">Input from the upstream filter or input reader</param>
        /// <param name="output">Output to the downstream filter or output writer</param>
        protected virtual void Clean(string path, string root, Stream input, Stream output)
        {
            input.CopyTo(output);
        }

        /// <summary>
        /// Smudge the input stream and write to the output stream.
        /// </summary>
        /// <param name="path">The path of the file being filtered</param>
        /// <param name="root">The path of the working directory for the owning repository</param>
        /// <param name="input">Input from the upstream filter or input reader</param>
        /// <param name="output">Output to the downstream filter or output writer</param>
        protected virtual void Smudge(string path, string root, Stream input, Stream output)
        {
            input.CopyTo(output);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="Filter"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="Filter"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="Filter"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as Filter);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Filter"/> is equal to the current <see cref="Filter"/>.
        /// </summary>
        /// <param name="other">The <see cref="Filter"/> to compare with the current <see cref="Filter"/>.</param>
        /// <returns>True if the specified <see cref="Filter"/> is equal to the current <see cref="Filter"/>; otherwise, false.</returns>
        public bool Equals(Filter other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="Filter"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="Filter"/> to compare.</param>
        /// <param name="right">Second <see cref="Filter"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(Filter left, Filter right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="Filter"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="Filter"/> to compare.</param>
        /// <param name="right">Second <see cref="Filter"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(Filter left, Filter right)
        {
            return !Equals(left, right);
        }

        /// <summary>
        /// Initialize callback on filter
        ///
        /// Specified as `filter.initialize`, this is an optional callback invoked
        /// before a filter is first used.  It will be called once at most.
        ///
        /// If non-NULL, the filter's `initialize` callback will be invoked right
        /// before the first use of the filter, so you can defer expensive
        /// initialization operations (in case libgit2 is being used in a way that doesn't need the filter).
        /// </summary>
        int InitializeCallback(IntPtr filterPointer)
        {
            int result = 0;
            try
            {
                Initialize();
            }
            catch (Exception exception)
            {
                Log.Write(LogLevel.Error, "Filter.InitializeCallback exception");
                Log.Write(LogLevel.Error, exception.ToString());
                Proxy.git_error_set_str(GitErrorCategory.Filter, exception);
                result = (int)GitErrorCode.Error;
            }
            return result;
        }

        int StreamCreateCallback(out IntPtr git_writestream_out, GitFilter self, IntPtr payload, IntPtr filterSourcePtr, IntPtr git_writestream_next)
        {
            int result = 0;
            var state = new StreamState();

            try
            {
                Ensure.ArgumentNotZeroIntPtr(filterSourcePtr, "filterSourcePtr");
                Ensure.ArgumentNotZeroIntPtr(git_writestream_next, "git_writestream_next");

                state.thisStream = new GitWriteStream();
                state.thisStream.close = StreamCloseCallback;
                state.thisStream.write = StreamWriteCallback;
                state.thisStream.free = StreamFreeCallback;

                state.thisPtr = Marshal.AllocHGlobal(Marshal.SizeOf(state.thisStream));
                Marshal.StructureToPtr(state.thisStream, state.thisPtr, false);

                state.nextPtr = git_writestream_next;
                state.nextStream = (GitWriteStream)Marshal.PtrToStructure(state.nextPtr, typeof(GitWriteStream));

                state.filterSource = FilterSource.FromNativePtr(filterSourcePtr);
                state.output = new WriteStream(state.nextStream, state.nextPtr);

                Create(state.filterSource.Path, state.filterSource.Root, state.filterSource.SourceMode);

                if (!activeStreams.TryAdd(state.thisPtr, state))
                {
                    // AFAICT this is a theoretical error that could only happen if we manage
                    // to free the stream pointer but fail to remove the dictionary entry.
                    throw new InvalidOperationException("Overlapping stream pointers");
                }
            }
            catch (Exception exception)
            {
                // unexpected failures means memory clean up required
                if (state.thisPtr != IntPtr.Zero)
                {
                    Marshal.FreeHGlobal(state.thisPtr);
                    state.thisPtr = IntPtr.Zero;
                }

                Log.Write(LogLevel.Error, "Filter.StreamCreateCallback exception");
                Log.Write(LogLevel.Error, exception.ToString());
                Proxy.git_error_set_str(GitErrorCategory.Filter, exception);
                result = (int)GitErrorCode.Error;
            }

            git_writestream_out = state.thisPtr;

            return result;
        }

        int StreamCloseCallback(IntPtr stream)
        {
            int result = 0;
            StreamState state;

            try
            {
                Ensure.ArgumentNotZeroIntPtr(stream, "stream");

                if(!activeStreams.TryGetValue(stream, out state))
                {
                    throw new ArgumentException("Unknown stream pointer", "stream");
                }

                Ensure.ArgumentIsExpectedIntPtr(stream, state.thisPtr, "stream");

                using (BufferedStream outputBuffer = new BufferedStream(state.output, BufferSize))
                {
                    Complete(state.filterSource.Path, state.filterSource.Root, outputBuffer);
                }

                result = state.nextStream.close(state.nextPtr);
            }
            catch (Exception exception)
            {
                Log.Write(LogLevel.Error, "Filter.StreamCloseCallback exception");
                Log.Write(LogLevel.Error, exception.ToString());
                Proxy.git_error_set_str(GitErrorCategory.Filter, exception);
                result = (int)GitErrorCode.Error;
            }

            return result;
        }

        void StreamFreeCallback(IntPtr stream)
        {
            StreamState state;

            try
            {
                Ensure.ArgumentNotZeroIntPtr(stream, "stream");

                if (!activeStreams.TryRemove(stream, out state))
                {
                    throw new ArgumentException("Double free or invalid stream pointer", "stream");
                }

                Ensure.ArgumentIsExpectedIntPtr(stream, state.thisPtr, "stream");

                Marshal.FreeHGlobal(state.thisPtr);
            }
            catch (Exception exception)
            {
                Log.Write(LogLevel.Error, "Filter.StreamFreeCallback exception");
                Log.Write(LogLevel.Error, exception.ToString());
            }
        }

        unsafe int StreamWriteCallback(IntPtr stream, IntPtr buffer, UIntPtr len)
        {
            int result = 0;
            StreamState state;

            try
            {
                Ensure.ArgumentNotZeroIntPtr(stream, "stream");
                Ensure.ArgumentNotZeroIntPtr(buffer, "buffer");

                if (!activeStreams.TryGetValue(stream, out state))
                {
                    throw new ArgumentException("Invalid or already freed stream pointer", "stream");
                }

                Ensure.ArgumentIsExpectedIntPtr(stream, state.thisPtr, "stream");

                using (UnmanagedMemoryStream input = new UnmanagedMemoryStream((byte*)buffer.ToPointer(), (long)len))
                using (BufferedStream outputBuffer = new BufferedStream(state.output, BufferSize))
                {
                    switch (state.filterSource.SourceMode)
                    {
                        case FilterMode.Clean:
                            Clean(state.filterSource.Path, state.filterSource.Root, input, outputBuffer);
                            break;

                        case FilterMode.Smudge:
                            Smudge(state.filterSource.Path, state.filterSource.Root, input, outputBuffer);
                            break;

                        default:
                            Proxy.git_error_set_str(GitErrorCategory.Filter, "Unexpected filter mode.");
                            return (int)GitErrorCode.Ambiguous;
                    }
                }
            }
            catch (Exception exception)
            {
                Log.Write(LogLevel.Error, "Filter.StreamWriteCallback exception");
                Log.Write(LogLevel.Error, exception.ToString());
                Proxy.git_error_set_str(GitErrorCategory.Filter, exception);
                result = (int)GitErrorCode.Error;
            }

            return result;
        }
    }

    /// <summary>
    /// The definition for a given filter found in the .gitattributes file.
    /// The filter definition will result as 'filter=filterName'
    ///
    /// In the .gitattributes file a filter will be matched to a pathspec like so
    /// '*.txt filter=filterName'
    /// </summary>
    public class FilterAttributeEntry
    {
        private const string AttributeFilterDefinition = "filter=";

        private readonly string filterDefinition;

        /// <summary>
        /// For testing purposes
        /// </summary>
        protected FilterAttributeEntry() { }

        /// <summary>
        /// The name of the filter found in a .gitattributes file.
        /// </summary>
        /// <param name="filterName">The name of the filter as found in the .gitattributes file without the "filter=" prefix</param>
        /// <remarks>
        /// "filter=" will be prepended to the filterDefinition, therefore the "filter=" portion of the filter
        /// name shouldbe omitted on declaration. Inclusion of the "filter=" prefix will cause the FilterDefinition to
        /// fail to match the .gitattributes entry and thefore no be invoked correctly.
        /// </remarks>
        public FilterAttributeEntry(string filterName)
        {
            Ensure.ArgumentNotNullOrEmptyString(filterName, "filterName");
            if (filterName.StartsWith("filter=", StringComparison.OrdinalIgnoreCase))
            {
                throw new ArgumentException("The filterName parameter should not begin with \"filter=\"", filterName);
            }

            filterName = AttributeFilterDefinition + filterName;
            this.filterDefinition = filterName;
        }

        /// <summary>
        /// The filter name in the form of 'filter=filterName'
        /// </summary>
        public virtual string FilterDefinition
        {
            get { return filterDefinition; }
        }
    }

    /// <summary>
    /// Allows callers to specify how blob content filters will be applied.
    /// </summary>
    public sealed class FilteringOptions
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FilteringOptions"/> class.
        /// </summary>
        /// <param name="hintPath">The path that a file would be checked out as</param>
        public FilteringOptions(string hintPath)
        {
            Ensure.ArgumentNotNull(hintPath, "hintPath");

            this.HintPath = hintPath;
        }

        /// <summary>
        /// The path to "hint" to the filters will be used to apply
        /// attributes.
        /// </summary>
        public string HintPath { get; private set; }
    }

    /// <summary>
    /// These values control which direction of change is with which which a filter is being applied.
    /// </summary>
    /// <remarks>
    /// These enum values must be identical to the values in Libgit2 filter_mode_t found in filter.h
    /// </remarks>
    public enum FilterMode
    {
        /// <summary>
        /// Smudge occurs when exporting a file from the Git object database to the working directory.
        /// For example, a file would be smudged during a checkout operation.
        /// </summary>
        Smudge = 0,

        /// <summary>
        /// Clean occurs when importing a file from the working directory to the Git object database.
        /// For example, a file would be cleaned when staging a file.
        /// </summary>
        Clean = 1,
    }

    /// <summary>
    /// An object representing the registration of a Filter type with libgit2
    /// </summary>
    public sealed class FilterRegistration
    {
        /// <summary>
        /// Maximum priority value a filter can have. A value of 200 will be run last on checkout and first on checkin.
        /// </summary>
        public const int FilterPriorityMax = 200;
        /// <summary>
        /// Minimum priority value a filter can have. A value of 0 will be run first on checkout and last on checkin.
        /// </summary>
        public const int FilterPriorityMin = 0;

        /// <summary>
        ///
        /// </summary>
        /// <param name="filter"></param>
        /// <param name="priority"></param>
        internal FilterRegistration(Filter filter, int priority)
        {
            System.Diagnostics.Debug.Assert(filter != null);
            System.Diagnostics.Debug.Assert(priority >= FilterPriorityMin && priority <= FilterPriorityMax);

            Filter = filter;
            Priority = priority;

            // marshal the git_filter strucutre into native memory
            FilterPointer = Marshal.AllocHGlobal(Marshal.SizeOf(filter.GitFilter));
            Marshal.StructureToPtr(filter.GitFilter, FilterPointer, false);

            // register the filter with the native libary
            Proxy.git_filter_register(filter.Name, FilterPointer, priority);
        }
        /// <summary>
        /// Finalizer called by the <see cref="GC"/>, deregisters and frees native memory associated with the registered filter in libgit2.
        /// </summary>
        ~FilterRegistration()
        {
            // deregister the filter
            GlobalSettings.DeregisterFilter(this);
            // clean up native allocations
            Free();
        }

        /// <summary>
        /// Gets if the registration and underlying filter are valid.
        /// </summary>
        public bool IsValid { get { return !freed; } }
        /// <summary>
        /// The registerd filters
        /// </summary>
        public readonly Filter Filter;
        /// <summary>
        /// The name of the filter in the libgit2 registry
        /// </summary>
        public string Name { get { return Filter.Name; } }
        /// <summary>
        /// The priority of the registered filter
        /// </summary>
        public readonly int Priority;

        private readonly IntPtr FilterPointer;

        private bool freed;

        internal void Free()
        {
            if (!freed)
            {
                // unregister the filter with the native libary
                Proxy.git_filter_unregister(Filter.Name);
                // release native memory
                Marshal.FreeHGlobal(FilterPointer);
                // remember to not do this twice
                freed = true;
            }
        }
    }

    /// <summary>
    /// A filter source - describes the direction of filtering and the file being filtered.
    /// </summary>
    public class FilterSource
    {
        /// <summary>
        /// Needed for mocking purposes
        /// </summary>
        protected FilterSource() { }

        internal unsafe FilterSource(FilePath path, FilterMode mode, git_filter_source* source)
        {
            SourceMode = mode;
            ObjectId = ObjectId.BuildFromPtr(&source->oid);
            Path = path.Native;
            Root = Proxy.git_repository_workdir(new IntPtr(source->repository)).Native;
        }

        /// <summary>
        /// Take an unmanaged pointer and convert it to filter source callback paramater
        /// </summary>
        /// <param name="ptr"></param>
        /// <returns></returns>
        internal static unsafe FilterSource FromNativePtr(IntPtr ptr)
        {
            return FromNativePtr((git_filter_source*) ptr.ToPointer());
        }

        /// <summary>
        /// Take an unmanaged pointer and convert it to filter source callback paramater
        /// </summary>
        /// <param name="ptr"></param>
        /// <returns></returns>
        internal static unsafe FilterSource FromNativePtr(git_filter_source* ptr)
        {
            FilePath path = LaxFilePathMarshaler.FromNative(ptr->path) ?? FilePath.Empty;
            FilterMode gitFilterSourceMode = Proxy.git_filter_source_mode(ptr);
            return new FilterSource(path, gitFilterSourceMode, ptr);
        }

        /// <summary>
        /// The filter mode for current file being filtered
        /// </summary>
        public virtual FilterMode SourceMode { get; private set; }

        /// <summary>
        /// The relative path to the file
        /// </summary>
        public virtual string Path { get; private set; }

        /// <summary>
        /// The blob id
        /// </summary>
        public virtual ObjectId ObjectId { get; private set; }

        /// <summary>
        /// The working directory
        /// </summary>
        public virtual string Root { get; private set; }
    }

    /// <summary>
    /// Represents a gitlink (a reference to a commit in another Git repository)
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class GitLink : GitObject
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected GitLink()
        { }

        internal GitLink(Repository repo, ObjectId id)
            : base(repo, id)
        { }

        private string DebuggerDisplay
        {
            get { return Id.ToString(); }
        }
    }

    /// <summary>
    /// A GitObject
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public abstract class GitObject : IEquatable<GitObject>, IBelongToARepository
    {
        internal static IDictionary<Type, ObjectType> TypeToKindMap =
            new Dictionary<Type, ObjectType>
            {
                { typeof(Commit), ObjectType.Commit },
                { typeof(Tree), ObjectType.Tree },
                { typeof(Blob), ObjectType.Blob },
                { typeof(TagAnnotation), ObjectType.Tag },
            };
        internal static IDictionary<Type, GitObjectType> TypeToGitKindMap =
            new Dictionary<Type, GitObjectType>
            {
                { typeof(Commit), GitObjectType.Commit },
                { typeof(Tree), GitObjectType.Tree },
                { typeof(Blob), GitObjectType.Blob },
                { typeof(TagAnnotation), GitObjectType.Tag },
            };

        private static readonly LambdaEqualityHelper<GitObject> equalityHelper =
            new LambdaEqualityHelper<GitObject>(x => x.Id);

        private readonly ILazy<bool> lazyIsMissing;

        /// <summary>
        /// The <see cref="Repository"/> containing the object.
        /// </summary>
        internal readonly Repository repo;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected GitObject()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="GitObject"/> class.
        /// </summary>
        /// <param name="repo">The <see cref="Repository"/> containing the object.</param>
        /// <param name="id">The <see cref="ObjectId"/> it should be identified by.</param>
        protected GitObject(Repository repo, ObjectId id)
        {
            this.repo = repo;
            Id = id;
            lazyIsMissing = GitObjectLazyGroup.Singleton(repo, id, handle => handle == null, throwIfMissing: false);
        }

        /// <summary>
        /// Gets the id of this object
        /// </summary>
        public virtual ObjectId Id { get; private set; }

        /// <summary>
        ///  Determine if the object is missing
        /// </summary>
        /// <remarks>
        /// This is common when dealing with partially cloned repositories as blobs or trees could be missing
        /// </remarks>
        public virtual bool IsMissing { get { return lazyIsMissing.Value; } }

        /// <summary>
        /// Gets the 40 character sha1 of this object.
        /// </summary>
        public virtual string Sha { get { return Id.Sha; } }

        internal static GitObject BuildFrom(Repository repo, ObjectId id, GitObjectType type, string path)
        {
            switch (type)
            {
                case GitObjectType.Commit:
                    return new Commit(repo, id);

                case GitObjectType.Tree:
                    return new Tree(repo, id, path);

                case GitObjectType.Tag:
                    return new TagAnnotation(repo, id);

                case GitObjectType.Blob:
                    return new Blob(repo, id);

                default:
                    throw new LibGit2SharpException("Unexpected type '{0}' for object '{1}'.",
                                                    type,
                                                    id);
            }
        }

        internal T Peel<T>(bool throwOnError) where T : GitObject
        {
            GitObjectType kind;
            if (!TypeToGitKindMap.TryGetValue(typeof(T), out kind))
            {
                throw new ArgumentException("Invalid type passed to peel");
            }

            using (var handle = Proxy.git_object_peel(repo.Handle, Id, kind, throwOnError))
            {
                if (handle == null)
                {
                    return null;
                }

                return (T)BuildFrom(this.repo, Proxy.git_object_id(handle), kind, null);
            }
        }

        /// <summary>
        /// Peel this object to the specified type
        ///
        /// It will throw if the object cannot be peeled to the type.
        /// </summary>
        /// <typeparam name="T">The kind of <see cref="GitObject"/> to peel to.</typeparam>
        /// <returns>The peeled object</returns>
        public virtual T Peel<T>() where T : GitObject
        {
            return Peel<T>(true);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="GitObject"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="GitObject"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="GitObject"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as GitObject);
        }

        /// <summary>
        /// Determines whether the specified <see cref="GitObject"/> is equal to the current <see cref="GitObject"/>.
        /// </summary>
        /// <param name="other">The <see cref="GitObject"/> to compare with the current <see cref="GitObject"/>.</param>
        /// <returns>True if the specified <see cref="GitObject"/> is equal to the current <see cref="GitObject"/>; otherwise, false.</returns>
        public bool Equals(GitObject other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="GitObject"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="GitObject"/> to compare.</param>
        /// <param name="right">Second <see cref="GitObject"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(GitObject left, GitObject right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="GitObject"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="GitObject"/> to compare.</param>
        /// <param name="right">Second <see cref="GitObject"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(GitObject left, GitObject right)
        {
            return !Equals(left, right);
        }

        /// <summary>
        /// Returns the <see cref="Id"/>, a <see cref="String"/> representation of the current <see cref="GitObject"/>.
        /// </summary>
        /// <returns>The <see cref="Id"/> that represents the current <see cref="GitObject"/>.</returns>
        public override string ToString()
        {
            return Id.ToString();
        }

        private string DebuggerDisplay
        {
            get { return Id.ToString(7); }
        }

        IRepository IBelongToARepository.Repository { get { return repo; } }
    }

    /// <summary>
    /// Exposes low level Git object metadata
    /// </summary>
    public sealed class GitObjectMetadata
    {
        private readonly GitObjectType type;

        /// <summary>
        /// Size of the Object
        /// </summary>
        public long Size { get; private set; }

        /// <summary>
        /// Object Type
        /// </summary>
        public ObjectType Type
        {
            get
            {
                return type.ToObjectType();
            }
        }

        internal GitObjectMetadata(long size, GitObjectType type)
        {
            this.Size = size;
            this.type = type;
        }
    }

    /// <summary>
    /// Global settings for libgit2 and LibGit2Sharp.
    /// </summary>
    public static class GlobalSettings
    {
        //private static readonly Lazy<Version> version = new Lazy<Version>(Version.Build);
        private static readonly Dictionary<Filter, FilterRegistration> registeredFilters;
#if !LIBGIT2_USE_INTERNAL_DLL && LIBGIT2_ORIGINAL_DLL_LOADING
        private static readonly bool nativeLibraryPathAllowed;
#endif

        private static LogConfiguration logConfiguration = LogConfiguration.None;

#if !LIBGIT2_USE_INTERNAL_DLL && LIBGIT2_ORIGINAL_DLL_LOADING
        private static string nativeLibraryPath;
        private static bool nativeLibraryPathLocked;
        private static readonly string nativeLibraryDefaultPath = null;
#endif

        static GlobalSettings()
        {
#if !LIBGIT2_USE_INTERNAL_DLL && LIBGIT2_ORIGINAL_DLL_LOADING
            bool netFX = Platform.IsRunningOnNetFramework();
            bool netCore = Platform.IsRunningOnNetCore();

            nativeLibraryPathAllowed = netFX || netCore;
#endif

#if NETFRAMEWORK
            if (netFX)
            {
                // For .NET Framework apps the dependencies are deployed to lib/win32/{architecture} directory
                nativeLibraryDefaultPath = Path.Combine(GetExecutingAssemblyDirectory(), "lib", "win32", Platform.ProcessorArchitecture);
            }
#endif

            registeredFilters = new Dictionary<Filter, FilterRegistration>();
        }

#if NETFRAMEWORK
        private static string GetExecutingAssemblyDirectory()
        {
            // Assembly.CodeBase is not actually a correctly formatted
            // URI.  It's merely prefixed with `file:///` and has its
            // backslashes flipped.  This is superior to EscapedCodeBase,
            // which does not correctly escape things, and ambiguates a
            // space (%20) with a literal `%20` in the path.  Sigh.
            var managedPath = Assembly.GetExecutingAssembly().CodeBase;
            if (managedPath == null)
            {
                managedPath = Assembly.GetExecutingAssembly().Location;
            }
            else if (managedPath.StartsWith("file:///"))
            {
                managedPath = managedPath.Substring(8).Replace('/', '\\');
            }
            else if (managedPath.StartsWith("file://"))
            {
                managedPath = @"\\" + managedPath.Substring(7).Replace('/', '\\');
            }

            managedPath = Path.GetDirectoryName(managedPath);
            return managedPath;
        }
#endif

        /// <summary>
        /// Returns information related to the current LibGit2Sharp
        /// library.
        /// </summary>
        //public static Version Version { get { return version.Value; } }

        /// <summary>
        /// Registers a new <see cref="SmartSubtransport"/> as a custom
        /// smart-protocol transport with libgit2. Any Git remote with
        /// the scheme registered will delegate to the given transport
        /// for all communication with the server. This is not commonly
        /// used: some callers may want to re-use an existing connection to
        /// perform fetch / push operations to a remote.
        ///
        /// Note that this configuration is global to an entire process
        /// and does not honor application domains.
        /// </summary>
        /// <typeparam name="T">The type of SmartSubtransport to register</typeparam>
        /// <param name="scheme">The scheme (eg "http" or "gopher") to register</param>
        public static SmartSubtransportRegistration<T> RegisterSmartSubtransport<T>(string scheme)
            where T : SmartSubtransport, new()
        {
            Ensure.ArgumentNotNull(scheme, "scheme");

            var registration = new SmartSubtransportRegistration<T>(scheme);

            try
            {
                Proxy.git_transport_register(registration.Scheme,
                                             registration.FunctionPointer,
                                             registration.RegistrationPointer);
            }
            catch (Exception)
            {
                registration.Free();
                throw;
            }

            return registration;
        }

        /// <summary>
        /// Unregisters a previously registered <see cref="SmartSubtransport"/>
        /// as a custom smart-protocol transport with libgit2.
        /// </summary>
        /// <typeparam name="T">The type of SmartSubtransport to register</typeparam>
        /// <param name="registration">The previous registration</param>
        public static void UnregisterSmartSubtransport<T>(SmartSubtransportRegistration<T> registration)
            where T : SmartSubtransport, new()
        {
            Ensure.ArgumentNotNull(registration, "registration");

            Proxy.git_transport_unregister(registration.Scheme);
            registration.Free();
        }

        /// <summary>
        /// Registers a new <see cref="LogConfiguration"/> to receive
        /// information logging information from libgit2 and LibGit2Sharp.
        ///
        /// Note that this configuration is global to an entire process
        /// and does not honor application domains.
        /// </summary>
        public static LogConfiguration LogConfiguration
        {
            set
            {
                Ensure.ArgumentNotNull(value, "value");

                logConfiguration = value;

                if (logConfiguration.Level == LogLevel.None)
                {
                    Proxy.git_trace_set(0, null);
                }
                else
                {
                    Proxy.git_trace_set(value.Level, value.GitTraceCallback);

                    Log.Write(LogLevel.Info, "Logging enabled at level {0}", value.Level);
                }
            }

            get
            {
                return logConfiguration;
            }
        }

#if !LIBGIT2_USE_INTERNAL_DLL && LIBGIT2_ORIGINAL_DLL_LOADING
        /// <summary>
        /// Sets a path for loading native binaries on .NET Framework or .NET Core.
        /// When specified, native library will first be searched under the given path.
        ///
        /// If the library is not found it will be searched in standard search paths:
        /// <see cref="DllImportSearchPath.AssemblyDirectory"/>,
        /// <see cref="DllImportSearchPath.ApplicationDirectory"/> and
        /// <see cref="DllImportSearchPath.SafeDirectories"/>.
        /// <para>
        /// This must be set before any other calls to the library,
        /// and is not available on other platforms than .NET Framework and .NET Core.
        /// </para>
        /// </summary>
        public static string NativeLibraryPath
        {
            get
            {
                if (!nativeLibraryPathAllowed)
                {
                    throw new LibGit2SharpException("Querying the native hint path is only supported on .NET Framework and .NET Core platforms");
                }

                return nativeLibraryPath ?? nativeLibraryDefaultPath;
            }

            set
            {
                if (!nativeLibraryPathAllowed)
                {
                    throw new LibGit2SharpException("Setting the native hint path is only supported on .NET Framework and .NET Core platforms");
                }

                if (nativeLibraryPathLocked)
                {
                    throw new LibGit2SharpException("You cannot set the native library path after it has been loaded");
                }

                try
                {
                    nativeLibraryPath = Path.GetFullPath(value);
                }
                catch (Exception e)
                {
                    throw new LibGit2SharpException(e.Message);
                }
            }
        }

        internal static string GetAndLockNativeLibraryPath()
        {
            nativeLibraryPathLocked = true;
            return nativeLibraryPath ?? nativeLibraryDefaultPath;
        }
#endif

        /// <summary>
        /// Takes a snapshot of the currently registered filters.
        /// </summary>
        /// <returns>An array of <see cref="FilterRegistration"/>.</returns>
        public static IEnumerable<FilterRegistration> GetRegisteredFilters()
        {
            lock (registeredFilters)
            {
                FilterRegistration[] array = new FilterRegistration[registeredFilters.Count];
                registeredFilters.Values.CopyTo(array, 0);
                return array;
            }
        }

        /// <summary>
        /// Register a filter globally with a default priority of 200 allowing the custom filter
        /// to imitate a core Git filter driver. It will be run last on checkout and first on checkin.
        /// </summary>
        public static FilterRegistration RegisterFilter(Filter filter)
        {
            return RegisterFilter(filter, 200);
        }

        /// <summary>
        /// Registers a <see cref="Filter"/> to be invoked when <see cref="Filter.Name"/> matches .gitattributes 'filter=name'
        /// </summary>
        /// <param name="filter">The filter to be invoked at run time.</param>
        /// <param name="priority">The priroty of the filter to invoked.
        /// A value of 0 (<see cref="FilterRegistration.FilterPriorityMin"/>) will be run first on checkout and last on checkin.
        /// A value of 200 (<see cref="FilterRegistration.FilterPriorityMax"/>) will be run last on checkout and first on checkin.
        /// </param>
        /// <returns>A <see cref="FilterRegistration"/> object used to manage the lifetime of the registration.</returns>
        public static FilterRegistration RegisterFilter(Filter filter, int priority)
        {
            Ensure.ArgumentNotNull(filter, "filter");
            if (priority < FilterRegistration.FilterPriorityMin || priority > FilterRegistration.FilterPriorityMax)
            {
                throw new ArgumentOutOfRangeException("priority",
                                                      priority,
                                                      String.Format(System.Globalization.CultureInfo.InvariantCulture,
                                                                    "Filter priorities must be within the inclusive range of [{0}, {1}].",
                                                                    FilterRegistration.FilterPriorityMin,
                                                                    FilterRegistration.FilterPriorityMax));
            }

            FilterRegistration registration = null;

            lock (registeredFilters)
            {
                // if the filter has already been registered
                if (registeredFilters.ContainsKey(filter))
                {
                    throw new EntryExistsException("The filter has already been registered.", GitErrorCode.Exists, GitErrorCategory.Filter);
                }

                // allocate the registration object
                registration = new FilterRegistration(filter, priority);
                // add the filter and registration object to the global tracking list
                registeredFilters.Add(filter, registration);
            }

            return registration;
        }

        /// <summary>
        /// Unregisters the associated filter.
        /// </summary>
        /// <param name="registration">Registration object with an associated filter.</param>
        public static void DeregisterFilter(FilterRegistration registration)
        {
            Ensure.ArgumentNotNull(registration, "registration");

            lock (registeredFilters)
            {
                var filter = registration.Filter;

                // do nothing if the filter isn't registered
                if (registeredFilters.ContainsKey(filter))
                {
                    // remove the register from the global tracking list
                    registeredFilters.Remove(filter);
                    // clean up native allocations
                    registration.Free();
                }
            }
        }

        internal static void DeregisterFilter(Filter filter)
        {
            System.Diagnostics.Debug.Assert(filter != null);

            // do nothing if the filter isn't registered
            if (registeredFilters.ContainsKey(filter))
            {
                var registration = registeredFilters[filter];
                // unregister the filter
                DeregisterFilter(registration);
            }
        }

        /// <summary>
        /// Get the paths under which libgit2 searches for the configuration file of a given level.
        /// </summary>
        /// <param name="level">The level (global/system/XDG) of the config.</param>
        /// <returns>The paths that are searched</returns>
        public static IEnumerable<string> GetConfigSearchPaths(ConfigurationLevel level)
        {
            return Proxy.git_libgit2_opts_get_search_path(level).Split(Path.PathSeparator);
        }

        /// <summary>
        /// Set the paths under which libgit2 searches for the configuration file of a given level.
        ///
        /// <seealso cref="RepositoryOptions"/>.
        /// </summary>
        /// <param name="level">The level (global/system/XDG) of the config.</param>
        /// <param name="paths">
        ///     The new search paths to set.
        ///     Pass null to reset to the default.
        ///     The special string "$PATH" will be substituted with the current search path.
        /// </param>
        public static void SetConfigSearchPaths(ConfigurationLevel level, params string[] paths)
        {
            var pathString = (paths == null) ? null : string.Join(Path.PathSeparator.ToString(), paths);
            Proxy.git_libgit2_opts_set_search_path(level, pathString);
        }

        /// <summary>
        /// Enable or disable strict hash verification.
        /// </summary>
        /// <param name="enabled">true to enable strict hash verification; false otherwise.</param>
        public static void SetStrictHashVerification(bool enabled)
        {
            Proxy.git_libgit2_opts_enable_strict_hash_verification(enabled);
        }

        /// <summary>
        /// Enable or disable the libgit2 cache
        /// </summary>
        /// <param name="enabled">true to enable the cache, false otherwise</param>
        public static void SetEnableCaching(bool enabled)
        {
            Proxy.git_libgit2_opts_set_enable_caching(enabled);
        }

        /// <summary>
        /// Enable or disable the ofs_delta capability
        /// </summary>
        /// <param name="enabled">true to enable the ofs_delta capability, false otherwise</param>
        public static void SetEnableOfsDelta(bool enabled)
        {
            Proxy.git_libgit2_opts_set_enable_ofsdelta(enabled);
        }

        /// <summary>
        /// Enable or disable the libgit2 strict_object_creation capability
        /// </summary>
        /// <param name="enabled">true to enable the strict_object_creation capability, false otherwise</param>
        public static void SetEnableStrictObjectCreation(bool enabled)
        {
            Proxy.git_libgit2_opts_set_enable_strictobjectcreation(enabled);
        }

        /// <summary>
        /// Sets the user-agent string to be used by the HTTP(S) transport.
        /// Note that "git/2.0" will be prepended for compatibility.
        /// </summary>
        /// <param name="userAgent">The user-agent string to use</param>
        public static void SetUserAgent(string userAgent)
        {
            Proxy.git_libgit2_opts_set_user_agent(userAgent);
        }

        /// <summary>
        /// Set that the given git extensions are supported by the caller.
        /// </summary>
        /// <remarks>
        /// Extensions supported by libgit2 may be negated by prefixing them with a `!`.  For example: setting extensions to { "!noop", "newext" } indicates that the caller does not want
        /// to support repositories with the `noop` extension but does want to support repositories with the `newext` extension.
        /// </remarks>
        /// <param name="extensions">Supported extensions</param>
        public static void SetExtensions(params string[] extensions)
        {
            Proxy.git_libgit2_opts_set_extensions(extensions);
        }

        /// <summary>
        /// Returns the list of git extensions that are supported.
        /// </summary>
        /// <remarks>
        /// This is the list of built-in extensions supported by libgit2 and custom extensions that have been added with `SetExtensions`. Extensions that have been negated will not be returned.
        /// </remarks>
        public static string[] GetExtensions()
        {
            return Proxy.git_libgit2_opts_get_extensions();
        }

        /// <summary>
        /// Gets the user-agent string used by libgit2.
        /// <returns>
        /// The user-agent string.
        /// </returns>
        /// </summary>
        public static string GetUserAgent()
        {
            return Proxy.git_libgit2_opts_get_user_agent();
        }
    }

    /// <summary>
    /// Holds information about the potential ancestor
    /// and distance from it and two specified <see cref="Commit"/>s.
    /// </summary>
    public class HistoryDivergence
    {
        private readonly Lazy<Commit> commonAncestor;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected HistoryDivergence()
        { }

        internal HistoryDivergence(Repository repo, Commit one, Commit another)
        {
            commonAncestor = new Lazy<Commit>(() => repo.ObjectDatabase.FindMergeBase(one, another));
            Tuple<int?, int?> div = Proxy.git_graph_ahead_behind(repo.Handle, one, another);

            One = one;
            Another = another;
            AheadBy = div.Item1;
            BehindBy = div.Item2;
        }

        /// <summary>
        /// Gets the <see cref="Commit"/> being used as a reference.
        /// </summary>
        public virtual Commit One { get; private set; }

        /// <summary>
        /// Gets the <see cref="Commit"/> being compared against <see cref="HistoryDivergence.One"/>.
        /// </summary>
        public virtual Commit Another { get; private set; }

        /// <summary>
        /// Gets the number of commits that are reachable from <see cref="HistoryDivergence.One"/>,
        /// but not from <see cref="HistoryDivergence.Another"/>.
        /// <para>
        ///   This property will return <c>null</c> when <see cref="HistoryDivergence.One"/>
        ///   and <see cref="HistoryDivergence.Another"/> do not share a common ancestor.
        /// </para>
        /// </summary>
        public virtual int? AheadBy { get; private set; }

        /// <summary>
        /// Gets the number of commits that are reachable from <see cref="HistoryDivergence.Another"/>,
        /// but not from <see cref="HistoryDivergence.One"/>.
        /// <para>
        ///   This property will return <c>null</c> when <see cref="HistoryDivergence.One"/>
        ///   and <see cref="HistoryDivergence.Another"/> do not share a common ancestor.
        /// </para>
        /// </summary>
        public virtual int? BehindBy { get; private set; }

        /// <summary>
        /// Returns the best possible common ancestor <see cref="Commit"/> of <see cref="HistoryDivergence.One"/>
        /// and <see cref="HistoryDivergence.Another"/> or null if none found.
        /// </summary>
        public virtual Commit CommonAncestor
        {
            get { return commonAncestor.Value; }
        }
    }

    internal class NullHistoryDivergence : HistoryDivergence
    {
        public override Commit CommonAncestor
        {
            get { return null; }
        }
    }

    /// <summary>
    /// Can be used to reference the <see cref="IRepository" /> from which
    /// an instance was created.
    /// <para>
    /// While convenient in some situations (e.g. Checkout branch bound to UI element),
    /// it is important to ensure instances created from an <see cref="IRepository" />
    /// are not used after it is disposed.
    /// </para>
    /// <para>
    /// It's generally better to create <see cref="IRepository" /> and dependant instances
    /// on demand, with a short lifespan.
    /// </para>
    /// </summary>
    public interface IBelongToARepository
    {
        /// <summary>
        /// The <see cref="IRepository" /> from which this instance was created.
        /// <para>
        /// The returned value should not be disposed.
        /// </para>
        /// </summary>
        IRepository Repository { get; }
    }

    /// <summary>
    /// A log of commits in a <see cref="Repository"/>.
    /// </summary>
    public interface ICommitLog : IEnumerable<Commit>
    {
        /// <summary>
        /// Gets the current sorting strategy applied when enumerating the log.
        /// </summary>
        CommitSortStrategies SortedBy { get; }
    }

    /// <summary>
    /// Represents the identity used when writing reflog entries.
    /// </summary>
    public sealed class Identity
    {
        private readonly string _name;
        private readonly string _email;

        /// <summary>
        /// Initializes a new instance of the <see cref="Identity"/> class.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="email">The email.</param>
        public Identity(string name, string email)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");
            Ensure.ArgumentNotNullOrEmptyString(email, "email");
            Ensure.ArgumentDoesNotContainZeroByte(name, "name");
            Ensure.ArgumentDoesNotContainZeroByte(email, "email");

            _name = name;
            _email = email;
        }

        /// <summary>
        /// Gets the email.
        /// </summary>
        public string Email
        {
            get { return _email; }
        }

        /// <summary>
        /// Gets the name.
        /// </summary>
        public string Name
        {
            get { return _name; }
        }

        internal SignatureHandle BuildNowSignatureHandle()
        {
            return Proxy.git_signature_now(Name, Email);
        }
    }

    internal static class IdentityHelpers
    {
        /// <summary>
        /// Build the handle for the Indentity with the current time, or return a handle
        /// to an empty signature.
        /// </summary>
        /// <param name="identity"></param>
        /// <returns></returns>
        public static unsafe SignatureHandle SafeBuildNowSignatureHandle(this Identity identity)
        {
            if (identity == null)
            {
                return new SignatureHandle(null, false);
            }

            return identity.BuildNowSignatureHandle();
        }
    }

    /// <summary>
    ///   Marker interface to identify Diff results.
    /// </summary>
    public interface IDiffResult: IDisposable
    { }

    /// <summary>
    /// Provides methods to manage the rules ensuring that some specific
    /// untracked files are ignored.
    /// </summary>
    public class Ignore
    {
        private readonly Repository repo;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Ignore()
        { }

        internal Ignore(Repository repo)
        {
            this.repo = repo;
        }

        /// <summary>
        /// Adds a custom .gitignore rule that will be applied to futher operations to the Index. This is in addition
        /// to the standard .gitignore rules that would apply as a result of the system/user/repo .gitignore
        /// </summary>
        /// <param name="rules">The content of a .gitignore file that will be applied.</param>
        public virtual void AddTemporaryRules(IEnumerable<string> rules)
        {
            Ensure.ArgumentNotNull(rules, "rules");

            var allRules = rules.Aggregate(new StringBuilder(), (acc, x) =>
            {
                acc.Append(x);
                acc.Append("\n");
                return acc;
            });

            Proxy.git_ignore_add_rule(repo.Handle, allRules.ToString());
        }

        /// <summary>
        /// Resets all custom rules that were applied via calls to
        /// <see cref="AddTemporaryRules"/> - note that this will not affect
        /// the application of the user/repo .gitignores.
        /// </summary>
        public virtual void ResetAllTemporaryRules()
        {
            Proxy.git_ignore_clear_internal_rules(repo.Handle);
        }

        /// <summary>
        ///  Given a relative path, this method determines whether a path should be ignored, checking
        ///  both the custom ignore rules as well as the "normal" .gitignores.
        /// </summary>
        /// <param name="relativePath">A path relative to the repository</param>
        /// <returns>true if the path should be ignored.</returns>
        public virtual bool IsPathIgnored(string relativePath)
        {
            Ensure.ArgumentNotNullOrEmptyString(relativePath, "relativePath");

            return Proxy.git_ignore_path_is_ignored(repo.Handle, relativePath);
        }
    }

    /// <summary>
    /// The Index is a staging area between the Working directory and the Repository.
    /// It's used to prepare and aggregate the changes that will be part of the next commit.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class Index : IEnumerable<IndexEntry>
    {
        private readonly IndexHandle handle;
        private readonly Repository repo;
        private readonly ConflictCollection conflicts;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Index()
        { }

        internal Index(IndexHandle handle, Repository repo)
        {
            this.repo = repo;
            this.handle = handle;
            conflicts = new ConflictCollection(this);
        }

        internal Index(Repository repo)
            : this(Proxy.git_repository_index(repo.Handle), repo)
        {
            repo.RegisterForCleanup(handle);
        }

        internal Index(Repository repo, string indexPath)
        {
            this.repo = repo;

            handle = Proxy.git_index_open(indexPath);
            Proxy.git_repository_set_index(repo.Handle, handle);
            conflicts = new ConflictCollection(this);

            repo.RegisterForCleanup(handle);
        }

        internal IndexHandle Handle
        {
            get { return handle; }
        }

        /// <summary>
        /// Gets the number of <see cref="IndexEntry"/> in the <see cref="Index"/>.
        /// </summary>
        public virtual int Count
        {
            get { return Proxy.git_index_entrycount(handle); }
        }

        /// <summary>
        /// Determines if the <see cref="Index"/> is free from conflicts.
        /// </summary>
        public virtual bool IsFullyMerged
        {
            get { return !Proxy.git_index_has_conflicts(handle); }
        }

        /// <summary>
        /// Gets the <see cref="IndexEntry"/> with the specified relative path.
        /// </summary>
        public virtual unsafe IndexEntry this[string path]
        {
            get
            {
                Ensure.ArgumentNotNullOrEmptyString(path, "path");

                git_index_entry* entry = Proxy.git_index_get_bypath(handle, path, 0);
                return IndexEntry.BuildFromPtr(entry);
            }
        }

        private unsafe IndexEntry this[int index]
        {
            get
            {
                git_index_entry* entryHandle = Proxy.git_index_get_byindex(handle, (UIntPtr)index);
                return IndexEntry.BuildFromPtr(entryHandle);
            }
        }

        #region IEnumerable<IndexEntry> Members

        private List<IndexEntry> AllIndexEntries()
        {
            var entryCount = Count;
            var list = new List<IndexEntry>(entryCount);

            for (int i = 0; i < entryCount; i++)
            {
                list.Add(this[i]);
            }

            return list;
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<IndexEntry> GetEnumerator()
        {
            return AllIndexEntries().GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        /// <summary>
        /// Replaces entries in the <see cref="Index"/> with entries from the specified <see cref="Tree"/>.
        /// <para>
        ///   This overwrites all existing state in the <see cref="Index"/>.
        /// </para>
        /// </summary>
        /// <param name="source">The <see cref="Tree"/> to read the entries from.</param>
        public virtual void Replace(Tree source)
        {
            using (var obj = new ObjectSafeWrapper(source.Id, repo.Handle))
            {
                Proxy.git_index_read_fromtree(this, obj.ObjectPtr);
            }
        }

        /// <summary>
        /// Clears all entries the <see cref="Index"/>. This is semantically equivalent to
        /// creating an empty <see cref="Tree"/> object and resetting the <see cref="Index"/> to that <see cref="Tree"/>.
        /// <para>
        ///   This overwrites all existing state in the <see cref="Index"/>.
        /// </para>
        /// </summary>
        public virtual void Clear()
        {
            Proxy.git_index_clear(this);
        }

        private void RemoveFromIndex(string relativePath)
        {
            Proxy.git_index_remove_bypath(handle, relativePath);
        }

        /// <summary>
        /// Removes a specified entry from the <see cref="Index"/>.
        /// </summary>
        /// <param name="indexEntryPath">The path of the <see cref="Index"/> entry to be removed.</param>
        public virtual void Remove(string indexEntryPath)
        {
            Ensure.ArgumentNotNull(indexEntryPath, "indexEntryPath");
            RemoveFromIndex(indexEntryPath);
        }

        /// <summary>
        /// Adds a file from the working directory in the <see cref="Index"/>.
        /// <para>
        ///   If an entry with the same path already exists in the <see cref="Index"/>,
        ///   the newly added one will overwrite it.
        /// </para>
        /// </summary>
        /// <param name="pathInTheWorkdir">The path, in the working directory, of the file to be added.</param>
        public virtual void Add(string pathInTheWorkdir)
        {
            Ensure.ArgumentNotNull(pathInTheWorkdir, "pathInTheWorkdir");
            Proxy.git_index_add_bypath(handle, pathInTheWorkdir);
        }

        /// <summary>
        /// Adds an entry in the <see cref="Index"/> from a <see cref="Blob"/>.
        /// <para>
        ///   If an entry with the same path already exists in the <see cref="Index"/>,
        ///   the newly added one will overwrite it.
        /// </para>
        /// </summary>
        /// <param name="blob">The <see cref="Blob"/> which content should be added to the <see cref="Index"/>.</param>
        /// <param name="indexEntryPath">The path to be used in the <see cref="Index"/>.</param>
        /// <param name="indexEntryMode">Either <see cref="Mode.NonExecutableFile"/>, <see cref="Mode.ExecutableFile"/>
        /// or <see cref="Mode.SymbolicLink"/>.</param>
        public virtual void Add(Blob blob, string indexEntryPath, Mode indexEntryMode)
        {
            Ensure.ArgumentConformsTo(indexEntryMode, m => m.HasAny(TreeEntryDefinition.BlobModes), "indexEntryMode");
            Ensure.ArgumentNotNull(blob, "blob");
            Ensure.ArgumentNotNull(indexEntryPath, "indexEntryPath");
            AddEntryToTheIndex(indexEntryPath, blob.Id, indexEntryMode);
        }

        internal void Replace(TreeChanges changes)
        {
            foreach (TreeEntryChanges treeEntryChanges in changes)
            {
                switch (treeEntryChanges.Status)
                {
                    case ChangeKind.Unmodified:
                        continue;

                    case ChangeKind.Added:
                        RemoveFromIndex(treeEntryChanges.Path);
                        continue;

                    case ChangeKind.Deleted:
                    case ChangeKind.Modified:
                        AddEntryToTheIndex(treeEntryChanges.OldPath,
                                           treeEntryChanges.OldOid,
                                           treeEntryChanges.OldMode);
                        continue;

                    default:
                        throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture,
                                                                          "Entry '{0}' bears an unexpected ChangeKind '{1}'",
                                                                          treeEntryChanges.Path,
                                                                          treeEntryChanges.Status));
                }
            }
        }

        /// <summary>
        ///  Gets the conflicts that exist.
        /// </summary>
        public virtual ConflictCollection Conflicts
        {
            get { return conflicts; }
        }

        private unsafe void AddEntryToTheIndex(string path, ObjectId id, Mode mode)
        {
            IntPtr pathPtr = StrictFilePathMarshaler.FromManaged(path);
            var indexEntry = new git_index_entry
            {
                mode = (uint)mode,
                path = (char*) pathPtr,
            };
            Marshal.Copy(id.RawId, 0, new IntPtr(indexEntry.id.Id), GitOid.Size);

            Proxy.git_index_add(handle, &indexEntry);
            EncodingMarshaler.Cleanup(pathPtr);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "Count = {0}", Count);
            }
        }

        /// <summary>
        /// Replaces entries in the <see cref="Index"/> with entries from the specified <see cref="Commit"/>.
        /// </summary>
        /// <param name="commit">The target <see cref="Commit"/> object.</param>
        public virtual void Replace(Commit commit)
        {
            Replace(commit, null, null);
        }

        /// <summary>
        /// Replaces entries in the <see cref="Index"/> with entries from the specified <see cref="Commit"/>.
        /// </summary>
        /// <param name="commit">The target <see cref="Commit"/> object.</param>
        /// <param name="paths">The list of paths (either files or directories) that should be considered.</param>
        public virtual void Replace(Commit commit, IEnumerable<string> paths)
        {
            Replace(commit, paths, null);
        }

        /// <summary>
        /// Replaces entries in the <see cref="Index"/> with entries from the specified <see cref="Commit"/>.
        /// </summary>
        /// <param name="commit">The target <see cref="Commit"/> object.</param>
        /// <param name="paths">The list of paths (either files or directories) that should be considered.</param>
        /// <param name="explicitPathsOptions">
        /// If set, the passed <paramref name="paths"/> will be treated as explicit paths.
        /// Use these options to determine how unmatched explicit paths should be handled.
        /// </param>
        public virtual void Replace(Commit commit, IEnumerable<string> paths, ExplicitPathsOptions explicitPathsOptions)
        {
            Ensure.ArgumentNotNull(commit, "commit");

            using (var changes = repo.Diff.Compare<TreeChanges>(commit.Tree, DiffTargets.Index, paths, explicitPathsOptions, new CompareOptions { Similarity = SimilarityOptions.None }))
            {
                Replace(changes);
            }
        }

        /// <summary>
        /// Write the contents of this <see cref="Index"/> to disk
        /// </summary>
        public virtual void Write()
        {
            Proxy.git_index_write(handle);
        }

        /// <summary>
        /// Write the contents of this <see cref="Index"/> to a tree
        /// </summary>
        /// <returns></returns>
        public virtual Tree WriteToTree()
        {
            var treeId = Proxy.git_index_write_tree_to(this.handle, this.repo.Handle);
            var result = this.repo.Lookup<Tree>(treeId);
            return result;
        }
    }

    /// <summary>
    /// A reference to a <see cref="Blob"/> known by the <see cref="Index"/>.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class IndexEntry : IEquatable<IndexEntry>
    {
        private static readonly LambdaEqualityHelper<IndexEntry> equalityHelper =
            new LambdaEqualityHelper<IndexEntry>(x => x.Path, x => x.Id, x => x.Mode, x => x.StageLevel);

        /// <summary>
        /// Gets the relative path to the file within the working directory.
        /// </summary>
        public virtual string Path { get; private set; }

        /// <summary>
        /// Gets the file mode.
        /// </summary>
        public virtual Mode Mode { get; private set; }

        /// <summary>
        /// Gets the stage number.
        /// </summary>
        public virtual StageLevel StageLevel { get; private set; }

        /// <summary>
        /// Whether the file is marked as assume-unchanged
        /// </summary>
        public virtual bool AssumeUnchanged { get; private set; }

        /// <summary>
        /// Gets the id of the <see cref="Blob"/> pointed at by this index entry.
        /// </summary>
        public virtual ObjectId Id { get; private set; }

        internal static unsafe IndexEntry BuildFromPtr(git_index_entry* entry)
        {
            if (entry == null)
            {
                return null;
            }

            string path = LaxUtf8Marshaler.FromNative(entry->path);

            return new IndexEntry
            {
                Path = path,
                Id = new ObjectId(entry->id.Id),
                StageLevel = Proxy.git_index_entry_stage(entry),
                Mode = (Mode)entry->mode,
                AssumeUnchanged = (git_index_entry.GIT_IDXENTRY_VALID & entry->flags) == git_index_entry.GIT_IDXENTRY_VALID
            };
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="IndexEntry"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="IndexEntry"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="IndexEntry"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as IndexEntry);
        }

        /// <summary>
        /// Determines whether the specified <see cref="IndexEntry"/> is equal to the current <see cref="IndexEntry"/>.
        /// </summary>
        /// <param name="other">The <see cref="IndexEntry"/> to compare with the current <see cref="IndexEntry"/>.</param>
        /// <returns>True if the specified <see cref="IndexEntry"/> is equal to the current <see cref="IndexEntry"/>; otherwise, false.</returns>
        public bool Equals(IndexEntry other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="IndexEntry"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="IndexEntry"/> to compare.</param>
        /// <param name="right">Second <see cref="IndexEntry"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(IndexEntry left, IndexEntry right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="IndexEntry"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="IndexEntry"/> to compare.</param>
        /// <param name="right">Second <see cref="IndexEntry"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(IndexEntry left, IndexEntry right)
        {
            return !Equals(left, right);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0} ({1}) => \"{2}\"",
                                     Path,
                                     StageLevel,
                                     Id.ToString(7));
            }
        }
    }

    /// <summary>
    /// A reference to the paths involved in a rename <see cref="Conflict"/>,
    /// known by the <see cref="Index"/>.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class IndexNameEntry : IEquatable<IndexNameEntry>
    {
        private static readonly LambdaEqualityHelper<IndexNameEntry> equalityHelper =
            new LambdaEqualityHelper<IndexNameEntry>(x => x.Ancestor, x => x.Ours, x => x.Theirs);

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected IndexNameEntry()
        { }

        internal static unsafe IndexNameEntry BuildFromPtr(git_index_name_entry* entry)
        {
            if (entry == null)
            {
                return null;
            }

            string ancestor = entry->ancestor != null
                ? LaxFilePathMarshaler.FromNative(entry->ancestor).Native
                : null;
            string ours = entry->ours != null
                ? LaxFilePathMarshaler.FromNative(entry->ours).Native
                : null;
            string theirs = entry->theirs != null
                ? LaxFilePathMarshaler.FromNative(entry->theirs).Native
                : null;

            return new IndexNameEntry
            {
                Ancestor = ancestor,
                Ours = ours,
                Theirs = theirs,
            };
        }

        /// <summary>
        /// Gets the path of the ancestor side of the conflict.
        /// </summary>
        public virtual string Ancestor { get; private set; }

        /// <summary>
        /// Gets the path of the "ours" side of the conflict.
        /// </summary>
        public virtual string Ours { get; private set; }

        /// <summary>
        /// Gets the path of the "theirs" side of the conflict.
        /// </summary>
        public virtual string Theirs { get; private set; }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="IndexNameEntry"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="IndexNameEntry"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="IndexNameEntry"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as IndexNameEntry);
        }

        /// <summary>
        /// Determines whether the specified <see cref="IndexNameEntry"/> is equal to the current <see cref="IndexNameEntry"/>.
        /// </summary>
        /// <param name="other">The <see cref="IndexNameEntry"/> to compare with the current <see cref="IndexNameEntry"/>.</param>
        /// <returns>True if the specified <see cref="IndexNameEntry"/> is equal to the current <see cref="IndexNameEntry"/>; otherwise, false.</returns>
        public bool Equals(IndexNameEntry other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="IndexNameEntry"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="IndexNameEntry"/> to compare.</param>
        /// <param name="right">Second <see cref="IndexNameEntry"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(IndexNameEntry left, IndexNameEntry right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="IndexNameEntry"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="IndexNameEntry"/> to compare.</param>
        /// <param name="right">Second <see cref="IndexNameEntry"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(IndexNameEntry left, IndexNameEntry right)
        {
            return !Equals(left, right);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0} {1} {2}",
                                     Ancestor,
                                     Ours,
                                     Theirs);
            }
        }
    }

    /// <summary>
    /// The collection of <see cref="LibGit2Sharp.IndexNameEntry"/>s in a
    /// <see cref="LibGit2Sharp.Repository"/> index that reflect the
    /// original paths of any rename conflicts that exist in the index.
    /// </summary>
    public class IndexNameEntryCollection : IEnumerable<IndexNameEntry>
    {
        private readonly Index index;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected IndexNameEntryCollection()
        { }

        internal IndexNameEntryCollection(Index index)
        {
            this.index = index;
        }

        private unsafe IndexNameEntry this[int idx]
        {
            get
            {
                git_index_name_entry* entryHandle = Proxy.git_index_name_get_byindex(index.Handle, (UIntPtr)idx);
                return IndexNameEntry.BuildFromPtr(entryHandle);
            }
        }

        #region IEnumerable<IndexNameEntry> Members

        private List<IndexNameEntry> AllIndexNames()
        {
            var list = new List<IndexNameEntry>();

            int count = Proxy.git_index_name_entrycount(index.Handle);

            for (int i = 0; i < count; i++)
            {
                list.Add(this[i]);
            }

            return list;
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<IndexNameEntry> GetEnumerator()
        {
            return AllIndexNames().GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion
    }

    /// <summary>
    /// A reference to a resolved <see cref="Conflict"/>,
    /// known by the <see cref="Index"/>.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class IndexReucEntry : IEquatable<IndexReucEntry>
    {
        private static readonly LambdaEqualityHelper<IndexReucEntry> equalityHelper =
            new LambdaEqualityHelper<IndexReucEntry>(x => x.Path,
                                                     x => x.AncestorId, x => x.AncestorMode,
                                                     x => x.OurId, x => x.OurMode,
                                                     x => x.TheirId, x => x.TheirMode);

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected IndexReucEntry()
        { }

        internal static unsafe IndexReucEntry BuildFromPtr(git_index_reuc_entry* entry)
        {
            if (entry == null)
            {
                return null;
            }

            FilePath path = LaxUtf8Marshaler.FromNative(entry->Path);

            return new IndexReucEntry
            {
                Path = path.Native,
                AncestorId = ObjectId.BuildFromPtr(&entry->AncestorId),
                AncestorMode = (Mode)entry->AncestorMode,
                OurId = ObjectId.BuildFromPtr(&entry->OurId),
                OurMode = (Mode)entry->OurMode,
                TheirId = ObjectId.BuildFromPtr(&entry->TheirId),
                TheirMode = (Mode)entry->TheirMode,
            };
        }

        /// <summary>
        /// Gets the path of this conflict.
        /// </summary>
        public virtual string Path { get; private set; }

        /// <summary>
        /// Gets the <see cref="ObjectId"/> that was the ancestor of this
        /// conflict.
        /// </summary>
        public virtual ObjectId AncestorId { get; private set; }

        /// <summary>
        /// Gets the <see cref="Mode"/> of the file that was the ancestor of
        /// conflict.
        /// </summary>
        public virtual Mode AncestorMode { get; private set; }

        /// <summary>
        /// Gets the <see cref="ObjectId"/> that was "our" side of this
        /// conflict.
        /// </summary>
        public virtual ObjectId OurId { get; private set; }

        /// <summary>
        /// Gets the <see cref="Mode"/> of the file that was "our" side of
        /// the conflict.
        /// </summary>
        public virtual Mode OurMode { get; private set; }

        /// <summary>
        /// Gets the <see cref="ObjectId"/> that was "their" side of this
        /// conflict.
        /// </summary>
        public virtual ObjectId TheirId { get; private set; }

        /// <summary>
        /// Gets the <see cref="Mode"/> of the file that was "their" side of
        /// the conflict.
        /// </summary>
        public virtual Mode TheirMode { get; private set; }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="IndexReucEntry"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="IndexReucEntry"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="IndexReucEntry"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as IndexReucEntry);
        }

        /// <summary>
        /// Determines whether the specified <see cref="IndexReucEntry"/> is equal to the current <see cref="IndexReucEntry"/>.
        /// </summary>
        /// <param name="other">The <see cref="IndexReucEntry"/> to compare with the current <see cref="IndexReucEntry"/>.</param>
        /// <returns>True if the specified <see cref="IndexReucEntry"/> is equal to the current <see cref="IndexReucEntry"/>; otherwise, false.</returns>
        public bool Equals(IndexReucEntry other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="IndexReucEntry"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="IndexReucEntry"/> to compare.</param>
        /// <param name="right">Second <see cref="IndexReucEntry"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(IndexReucEntry left, IndexReucEntry right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="IndexReucEntry"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="IndexReucEntry"/> to compare.</param>
        /// <param name="right">Second <see cref="IndexReucEntry"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(IndexReucEntry left, IndexReucEntry right)
        {
            return !Equals(left, right);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0}: {1} {2} {3}",
                                     Path,
                                     AncestorId,
                                     OurId,
                                     TheirId);
            }
        }
    }

    /// <summary>
    /// The collection of <see cref="LibGit2Sharp.IndexReucEntry"/>s in a
    /// <see cref="LibGit2Sharp.Repository"/> index that reflect the
    /// resolved conflicts.
    /// </summary>
    public class IndexReucEntryCollection : IEnumerable<IndexReucEntry>
    {
        private readonly Index index;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected IndexReucEntryCollection()
        { }

        internal IndexReucEntryCollection(Index index)
        {
            this.index = index;
        }

        /// <summary>
        /// Gets the <see cref="IndexReucEntry"/> with the specified relative path.
        /// </summary>
        public virtual unsafe IndexReucEntry this[string path]
        {
            get
            {
                Ensure.ArgumentNotNullOrEmptyString(path, "path");

                git_index_reuc_entry* entryHandle = Proxy.git_index_reuc_get_bypath(index.Handle, path);
                return IndexReucEntry.BuildFromPtr(entryHandle);
            }
        }

        private  unsafe IndexReucEntry this[int idx]
        {
            get
            {
                git_index_reuc_entry* entryHandle = Proxy.git_index_reuc_get_byindex(index.Handle, (UIntPtr)idx);
                return IndexReucEntry.BuildFromPtr(entryHandle);
            }
        }

        #region IEnumerable<IndexReucEntry> Members

        private List<IndexReucEntry> AllIndexReucs()
        {
            var list = new List<IndexReucEntry>();

            int count = Proxy.git_index_reuc_entrycount(index.Handle);

            for (int i = 0; i < count; i++)
            {
                list.Add(this[i]);
            }

            return list;
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<IndexReucEntry> GetEnumerator()
        {
            return AllIndexReucs().GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion
    }

    /// <summary>
    /// The exception that is thrown when a provided specification is bad. This
    /// can happen if the provided specification is syntactically incorrect, or
    /// if the spec refers to an object of an incorrect type (e.g. asking to
    /// create a branch from a blob, or peeling a blob to a commit).
    /// </summary>
    [Serializable]
    public class InvalidSpecificationException : NativeException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidSpecificationException"/> class.
        /// </summary>
        public InvalidSpecificationException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidSpecificationException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public InvalidSpecificationException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidSpecificationException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public InvalidSpecificationException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidSpecificationException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public InvalidSpecificationException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidSpecificationException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected InvalidSpecificationException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal InvalidSpecificationException(string message, GitErrorCategory category)
            : base(message, category)
        { }

        internal override GitErrorCode ErrorCode
        {
            get
            {
                return GitErrorCode.InvalidSpecification;
            }
        }
    }

    /// <summary>
    /// A log of commits in a <see cref="Repository"/> that can be filtered with queries.
    /// </summary>
    public interface IQueryableCommitLog : ICommitLog
    {
        /// <summary>
        /// Returns the list of commits of the repository matching the specified <paramref name="filter"/>.
        /// </summary>
        /// <param name="filter">The options used to control which commits will be returned.</param>
        /// <returns>A list of commits, ready to be enumerated.</returns>
        ICommitLog QueryBy(CommitFilter filter);

        /// <summary>
        /// Returns the list of commits of the repository representing the history of a file beyond renames.
        /// </summary>
        /// <param name="path">The file's path.</param>
        /// <returns>A list of file history entries, ready to be enumerated.</returns>
        IEnumerable<LogEntry> QueryBy(string path);

        /// <summary>
        /// Returns the list of commits of the repository representing the history of a file beyond renames.
        /// </summary>
        /// <param name="path">The file's path.</param>
        /// <param name="filter">The options used to control which commits will be returned.</param>
        /// <returns>A list of file history entries, ready to be enumerated.</returns>
        IEnumerable<LogEntry> QueryBy(string path, CommitFilter filter);

    }

    /// <summary>
    /// A Repository is the primary interface into a git repository
    /// </summary>
    public interface IRepository : IDisposable
    {
        /// <summary>
        /// Shortcut to return the branch pointed to by HEAD
        /// </summary>
        Branch Head { get; }

        /// <summary>
        /// Provides access to the configuration settings for this repository.
        /// </summary>
        Configuration Config { get; }

        /// <summary>
        /// Gets the index.
        /// </summary>
        Index Index { get; }

        /// <summary>
        /// Lookup and enumerate references in the repository.
        /// </summary>
        ReferenceCollection Refs { get; }

        /// <summary>
        /// Lookup and enumerate commits in the repository.
        /// Iterating this collection directly starts walking from the HEAD.
        /// </summary>
        IQueryableCommitLog Commits { get; }

        /// <summary>
        /// Lookup and enumerate branches in the repository.
        /// </summary>
        BranchCollection Branches { get; }

        /// <summary>
        /// Lookup and enumerate tags in the repository.
        /// </summary>
        TagCollection Tags { get; }

        /// <summary>
        /// Provides high level information about this repository.
        /// </summary>
        RepositoryInformation Info { get; }

        /// <summary>
        /// Provides access to diffing functionalities to show changes between the working tree and the index or a tree, changes between the index and a tree, changes between two trees, or changes between two files on disk.
        /// </summary>
        Diff Diff { get; }

        /// <summary>
        /// Gets the database.
        /// </summary>
        ObjectDatabase ObjectDatabase { get; }

        /// <summary>
        /// Lookup notes in the repository.
        /// </summary>
        NoteCollection Notes { get; }

        /// <summary>
        /// Submodules in the repository.
        /// </summary>
        SubmoduleCollection Submodules { get; }

        /// <summary>
        /// Worktrees in the repository.
        /// </summary>
        WorktreeCollection Worktrees { get; }

        /// <summary>
        /// Checkout the specified tree.
        /// </summary>
        /// <param name="tree">The <see cref="Tree"/> to checkout.</param>
        /// <param name="paths">The paths to checkout.</param>
        /// <param name="opts">Collection of parameters controlling checkout behavior.</param>
        void Checkout(Tree tree, IEnumerable<string> paths, CheckoutOptions opts);

        /// <summary>
        /// Updates specifed paths in the index and working directory with the versions from the specified branch, reference, or SHA.
        /// <para>
        /// This method does not switch branches or update the current repository HEAD.
        /// </para>
        /// </summary>
        /// <param name = "committishOrBranchSpec">A revparse spec for the commit or branch to checkout paths from.</param>
        /// <param name="paths">The paths to checkout.</param>
        /// <param name="checkoutOptions">Collection of parameters controlling checkout behavior.</param>
        void CheckoutPaths(string committishOrBranchSpec, IEnumerable<string> paths, CheckoutOptions checkoutOptions);

        /// <summary>
        /// Try to lookup an object by its <see cref="ObjectId"/>. If no matching object is found, null will be returned.
        /// </summary>
        /// <param name="id">The id to lookup.</param>
        /// <returns>The <see cref="GitObject"/> or null if it was not found.</returns>
        GitObject Lookup(ObjectId id);

        /// <summary>
        /// Try to lookup an object by its sha or a reference canonical name. If no matching object is found, null will be returned.
        /// </summary>
        /// <param name="objectish">A revparse spec for the object to lookup.</param>
        /// <returns>The <see cref="GitObject"/> or null if it was not found.</returns>
        GitObject Lookup(string objectish);

        /// <summary>
        /// Try to lookup an object by its <see cref="ObjectId"/> and <see cref="ObjectType"/>. If no matching object is found, null will be returned.
        /// </summary>
        /// <param name="id">The id to lookup.</param>
        /// <param name="type">The kind of GitObject being looked up</param>
        /// <returns>The <see cref="GitObject"/> or null if it was not found.</returns>
        GitObject Lookup(ObjectId id, ObjectType type);

        /// <summary>
        /// Try to lookup an object by its sha or a reference canonical name and <see cref="ObjectType"/>. If no matching object is found, null will be returned.
        /// </summary>
        /// <param name="objectish">A revparse spec for the object to lookup.</param>
        /// <param name="type">The kind of <see cref="GitObject"/> being looked up</param>
        /// <returns>The <see cref="GitObject"/> or null if it was not found.</returns>
        GitObject Lookup(string objectish, ObjectType type);

        /// <summary>
        /// Stores the content of the <see cref="Repository.Index"/> as a new <see cref="LibGit2Sharp.Commit"/> into the repository.
        /// The tip of the <see cref="Repository.Head"/> will be used as the parent of this new Commit.
        /// Once the commit is created, the <see cref="Repository.Head"/> will move forward to point at it.
        /// </summary>
        /// <param name="message">The description of why a change was made to the repository.</param>
        /// <param name="author">The <see cref="Signature"/> of who made the change.</param>
        /// <param name="committer">The <see cref="Signature"/> of who added the change to the repository.</param>
        /// <param name="options">The <see cref="CommitOptions"/> that specify the commit behavior.</param>
        /// <returns>The generated <see cref="LibGit2Sharp.Commit"/>.</returns>
        Commit Commit(string message, Signature author, Signature committer, CommitOptions options);

        /// <summary>
        /// Sets the current <see cref="Head"/> to the specified commit and optionally resets the <see cref="Index"/> and
        /// the content of the working tree to match.
        /// </summary>
        /// <param name="resetMode">Flavor of reset operation to perform.</param>
        /// <param name="commit">The target commit object.</param>
        void Reset(ResetMode resetMode, Commit commit);

        /// <summary>
        /// Sets <see cref="Head"/> to the specified commit and optionally resets the <see cref="Index"/> and
        /// the content of the working tree to match.
        /// </summary>
        /// <param name="resetMode">Flavor of reset operation to perform.</param>
        /// <param name="commit">The target commit object.</param>
        /// <param name="options">Collection of parameters controlling checkout behavior.</param>
        void Reset(ResetMode resetMode, Commit commit, CheckoutOptions options);

        /// <summary>
        /// Clean the working tree by removing files that are not under version control.
        /// </summary>
        void RemoveUntrackedFiles();

        /// <summary>
        /// Revert the specified commit.
        /// </summary>
        /// <param name="commit">The <see cref="Commit"/> to revert.</param>
        /// <param name="reverter">The <see cref="Signature"/> of who is performing the reverte.</param>
        /// <param name="options"><see cref="RevertOptions"/> controlling revert behavior.</param>
        /// <returns>The result of the revert.</returns>
        RevertResult Revert(Commit commit, Signature reverter, RevertOptions options);

        /// <summary>
        /// Merge changes from commit into the branch pointed at by HEAD..
        /// </summary>
        /// <param name="commit">The commit to merge into the branch pointed at by HEAD.</param>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <param name="options">Specifies optional parameters controlling merge behavior; if null, the defaults are used.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        MergeResult Merge(Commit commit, Signature merger, MergeOptions options);

        /// <summary>
        /// Merges changes from branch into the branch pointed at by HEAD..
        /// </summary>
        /// <param name="branch">The branch to merge into the branch pointed at by HEAD.</param>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <param name="options">Specifies optional parameters controlling merge behavior; if null, the defaults are used.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        MergeResult Merge(Branch branch, Signature merger, MergeOptions options);

        /// <summary>
        /// Merges changes from the commit into the branch pointed at by HEAD.
        /// </summary>
        /// <param name="committish">The commit to merge into branch pointed at by HEAD.</param>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <param name="options">Specifies optional parameters controlling merge behavior; if null, the defaults are used.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        MergeResult Merge(string committish, Signature merger, MergeOptions options);

        /// <summary>
        /// Access to Rebase functionality.
        /// </summary>
        Rebase Rebase { get; }

        /// <summary>
        /// Merge the reference that was recently fetched. This will merge
        /// the branch on the fetched remote that corresponded to the
        /// current local branch when we did the fetch. This is the
        /// second step in performing a pull operation (after having
        /// performed said fetch).
        /// </summary>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <param name="options">Specifies optional parameters controlling merge behavior; if null, the defaults are used.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        MergeResult MergeFetchedRefs(Signature merger, MergeOptions options);

        /// <summary>
        /// Cherry picks changes from the commit into the branch pointed at by HEAD.
        /// </summary>
        /// <param name="commit">The commit to cherry pick into branch pointed at by HEAD.</param>
        /// <param name="committer">The <see cref="Signature"/> of who is performing the cherry pick.</param>
        /// <param name="options">Specifies optional parameters controlling cherry pick behavior; if null, the defaults are used.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        CherryPickResult CherryPick(Commit commit, Signature committer, CherryPickOptions options);

        /// <summary>
        /// Manipulate the currently ignored files.
        /// </summary>
        Ignore Ignore { get; }

        /// <summary>
        /// Provides access to network functionality for a repository.
        /// </summary>
        Network Network { get; }

        ///<summary>
        /// Lookup and enumerate stashes in the repository.
        ///</summary>
        StashCollection Stashes { get; }

        /// <summary>
        /// Find where each line of a file originated.
        /// </summary>
        /// <param name="path">Path of the file to blame.</param>
        /// <param name="options">Specifies optional parameters; if null, the defaults are used.</param>
        /// <returns>The blame for the file.</returns>
        BlameHunkCollection Blame(string path, BlameOptions options);

        /// <summary>
        /// Retrieves the state of a file in the working directory, comparing it against the staging area and the latest commit.
        /// </summary>
        /// <param name="filePath">The relative path within the working directory to the file.</param>
        /// <returns>A <see cref="FileStatus"/> representing the state of the <paramref name="filePath"/> parameter.</returns>
        FileStatus RetrieveStatus(string filePath);

        /// <summary>
        /// Retrieves the state of all files in the working directory, comparing them against the staging area and the latest commit.
        /// </summary>
        /// <param name="options">If set, the options that control the status investigation.</param>
        /// <returns>A <see cref="RepositoryStatus"/> holding the state of all the files.</returns>
        RepositoryStatus RetrieveStatus(StatusOptions options);

        /// <summary>
        /// Finds the most recent annotated tag that is reachable from a commit.
        /// <para>
        ///   If the tag points to the commit, then only the tag is shown. Otherwise,
        ///   it suffixes the tag name with the number of additional commits on top
        ///   of the tagged object and the abbreviated object name of the most recent commit.
        /// </para>
        /// <para>
        ///   Optionally, the <paramref name="options"/> parameter allow to tweak the
        ///   search strategy (considering lightweight tags, or even branches as reference points)
        ///   and the formatting of the returned identifier.
        /// </para>
        /// </summary>
        /// <param name="commit">The commit to be described.</param>
        /// <param name="options">Determines how the commit will be described.</param>
        /// <returns>A descriptive identifier for the commit based on the nearest annotated tag.</returns>
        string Describe(Commit commit, DescribeOptions options);

        /// <summary>
        /// Parse an extended SHA-1 expression and retrieve the object and the reference
        /// mentioned in the revision (if any).
        /// </summary>
        /// <param name="revision">An extended SHA-1 expression for the object to look up</param>
        /// <param name="reference">The reference mentioned in the revision (if any)</param>
        /// <param name="obj">The object which the revision resolves to</param>
        void RevParse(string revision, out Reference reference, out GitObject obj);
    }

    /// <summary>
    /// The exception that is thrown when an error occurs during application execution.
    /// </summary>
    [Serializable]
    public class LibGit2SharpException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2SharpException"/> class.
        /// </summary>
        public LibGit2SharpException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2SharpException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public LibGit2SharpException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2SharpException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public LibGit2SharpException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2SharpException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public LibGit2SharpException(string format, params object[] args)
            : base(String.Format(CultureInfo.InvariantCulture, format, args))
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2SharpException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected LibGit2SharpException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }
    }

    /// <summary>
    /// Represents a line with line number and content.
    /// </summary>
    public struct Line
    {
        /// <summary>
        /// The line number of the original line in the blob.
        /// </summary>
        public int LineNumber;

        /// <summary>
        /// The content of the line in the original blob.
        /// </summary>
        public string Content;

        internal Line(int lineNumber, string content)
        {
            LineNumber = lineNumber;
            Content = content;
        }
    }

    /// <summary>
    /// The exception that is thrown attempting to open a locked file.
    /// </summary>
    [Serializable]
    public class LockedFileException : NativeException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.LockedFileException"/> class.
        /// </summary>
        public LockedFileException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.LockedFileException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public LockedFileException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.LockedFileException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public LockedFileException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.LockedFileException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public LockedFileException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.LockedFileException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected LockedFileException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal LockedFileException(string message, GitErrorCategory category)
            : base(message, category)
        { }

        internal override GitErrorCode ErrorCode
        {
            get
            {
                return GitErrorCode.LockedFile;
            }
        }
    }

    internal class Log
    {
        private static bool IsEnabled(LogConfiguration configuration, LogLevel level)
        {
            return (configuration.Level != LogLevel.None && configuration.Level >= level);
        }

        internal static bool IsEnabled(LogLevel level)
        {
            return IsEnabled(GlobalSettings.LogConfiguration, level);
        }

        internal static void Write(LogLevel level, string message, params object[] args)
        {
            LogConfiguration configuration = GlobalSettings.LogConfiguration;

            if (!IsEnabled(configuration, level))
            {
                return;
            }

            configuration.Handler(level, string.Format(message, args));
        }
    }

    /// <summary>
    /// Logging and tracing configuration for libgit2 and LibGit2Sharp.
    /// </summary>
    public sealed class LogConfiguration
    {
        /// <summary>
        /// The default logging configuration, which performs no logging at all.
        /// </summary>
        public static readonly LogConfiguration None = new LogConfiguration { Level = LogLevel.None };

        /// <summary>
        /// Creates a new logging configuration to call the given
        /// delegate when logging occurs at the given level.
        /// </summary>
        /// <param name="level">Level to log at</param>
        /// <param name="handler">Handler to call when logging occurs</param>
        public LogConfiguration(LogLevel level, LogHandler handler)
        {
            Ensure.ArgumentConformsTo<LogLevel>(level, (t) => { return (level != LogLevel.None); }, "level");
            Ensure.ArgumentNotNull(handler, "handler");

            Level = level;
            Handler = handler;

            // Explicitly create (and hold a reference to) a callback-delegate to wrap GitTraceHandler().
            GitTraceCallback = GitTraceHandler;
        }

        private LogConfiguration()
        { }

        internal LogLevel Level { get; private set; }
        internal LogHandler Handler { get; private set; }
        internal NativeMethods.git_trace_cb GitTraceCallback { get; private set; }

        /// <summary>
        /// This private method will be called from LibGit2 (from C code via
        /// the GitTraceCallback delegate) to route LibGit2 log messages to
        /// the same LogHandler as LibGit2Sharp messages.
        /// </summary>
        private void GitTraceHandler(LogLevel level, IntPtr msg)
        {
            string message = LaxUtf8Marshaler.FromNative(msg);
            Handler(level, message);
        }
    }

    /// <summary>
    /// An entry in a file's commit history.
    /// </summary>
    public sealed class LogEntry
    {
        /// <summary>
        /// The file's path relative to the repository's root.
        /// </summary>
        public string Path { get; internal set; }

        /// <summary>
        /// The commit in which the file was created or changed.
        /// </summary>
        public Commit Commit { get; internal set; }
    }

    /// <summary>
    /// Available logging levels.  When logging is enabled at a particular
    /// level, callers will be provided logging at the given level and all
    /// lower levels.
    /// </summary>
    public enum LogLevel
    {
        /// <summary>
        /// No logging will be provided.
        /// </summary>
        None = 0,

        /// <summary>
        /// Severe errors that may impact the program's execution.
        /// </summary>
        Fatal = 1,

        /// <summary>
        /// Errors that do not impact the program's execution.
        /// </summary>
        Error = 2,

        /// <summary>
        /// Warnings that suggest abnormal data.
        /// </summary>
        Warning = 3,

        /// <summary>
        /// Informational messages about program execution.
        /// </summary>
        Info = 4,

        /// <summary>
        /// Detailed data that allows for debugging.
        /// </summary>
        Debug = 5,

        /// <summary>
        /// Tracing is exceptionally detailed debugging data.
        /// </summary>
        Trace = 6,
    }

    internal class MatchedPathsAggregator : IEnumerable<FilePath>
    {
        private readonly List<FilePath> matchedPaths = new List<FilePath>();

        /// <summary>
        /// The delegate with a signature that matches the native diff git_diff_notify_cb function's signature.
        /// </summary>
        /// <param name="diffListSoFar">The diff list so far, before the delta is inserted.</param>
        /// <param name="deltaToAdd">The delta that is being diffed</param>
        /// <param name="matchedPathspec">The pathsec that matched the path of the diffed files.</param>
        /// <param name="payload">Payload object.</param>
        internal int OnGitDiffNotify(IntPtr diffListSoFar, IntPtr deltaToAdd, IntPtr matchedPathspec, IntPtr payload)
        {
            // Convert null strings into empty strings.
            var path = LaxFilePathMarshaler.FromNative(matchedPathspec) ?? FilePath.Empty;

            if (matchedPaths.Contains(path))
            {
                return 0;
            }

            matchedPaths.Add(path);
            return 0;
        }

        public IEnumerator<FilePath> GetEnumerator()
        {
            return matchedPaths.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }

    /// <summary>
    /// Options controlling the behavior of things that do a merge and then
    /// check out the merge results (eg: merge, revert, cherry-pick).
    /// </summary>
    public abstract class MergeAndCheckoutOptionsBase : MergeOptionsBase, IConvertableToGitCheckoutOpts
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MergeOptions"/> class.
        /// <para>
        ///   Default behavior:
        ///     A fast-forward merge will be performed if possible, unless the merge.ff configuration option is set.
        ///     A merge commit will be committed, if one was created.
        ///     Merge will attempt to find renames.
        /// </para>
        /// </summary>
        public MergeAndCheckoutOptionsBase()
        {
            CommitOnSuccess = true;
        }

        /// <summary>
        /// The Flags specifying what conditions are
        /// reported through the OnCheckoutNotify delegate.
        /// </summary>
        public CheckoutNotifyFlags CheckoutNotifyFlags { get; set; }

        /// <summary>
        /// Commit the merge if the merge is successful and this is a non-fast-forward merge.
        /// If this is a fast-forward merge, then there is no merge commit and this option
        /// will not affect the merge.
        /// </summary>
        public bool CommitOnSuccess { get; set; }

        /// <summary>
        /// How conflicting index entries should be written out during checkout.
        /// </summary>
        public CheckoutFileConflictStrategy FileConflictStrategy { get; set; }

        /// <summary>
        /// Delegate that the checkout will report progress through.
        /// </summary>
        public CheckoutProgressHandler OnCheckoutProgress { get; set; }

        /// <summary>
        /// Delegate that checkout will notify callers of
        /// certain conditions. The conditions that are reported is
        /// controlled with the CheckoutNotifyFlags property.
        /// </summary>
        public CheckoutNotifyHandler OnCheckoutNotify { get; set; }

        #region IConvertableToGitCheckoutOpts

        CheckoutCallbacks IConvertableToGitCheckoutOpts.GenerateCallbacks()
        {
            return CheckoutCallbacks.From(OnCheckoutProgress, OnCheckoutNotify);
        }

        CheckoutStrategy IConvertableToGitCheckoutOpts.CheckoutStrategy
        {
            get
            {
                return CheckoutStrategy.GIT_CHECKOUT_SAFE |
                       GitCheckoutOptsWrapper.CheckoutStrategyFromFileConflictStrategy(FileConflictStrategy);
            }
        }

        #endregion
    }

    /// <summary>
    /// The exception that is thrown when the ref to merge with was as part of a pull operation not fetched.
    /// </summary>
    [Serializable]
    public class MergeFetchHeadNotFoundException : NotFoundException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MergeFetchHeadNotFoundException"/> class.
        /// </summary>
        public MergeFetchHeadNotFoundException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="MergeFetchHeadNotFoundException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public MergeFetchHeadNotFoundException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="MergeFetchHeadNotFoundException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public MergeFetchHeadNotFoundException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="MergeFetchHeadNotFoundException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public MergeFetchHeadNotFoundException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="MergeFetchHeadNotFoundException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected MergeFetchHeadNotFoundException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }
    }

    /// <summary>
    /// A merge head is a parent for the next commit.
    /// </summary>
    internal class MergeHead : ReferenceWrapper<Commit>
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected MergeHead()
        { }

        internal MergeHead(Repository repo, ObjectId targetId, int index)
            : base(repo, new DirectReference(string.Format(CultureInfo.InvariantCulture, "MERGE_HEAD[{0}]", index), repo, targetId), r => r.CanonicalName)
        { }

        /// <summary>
        /// Gets the <see cref="Commit"/> that this merge head points to.
        /// </summary>
        public virtual Commit Tip
        {
            get { return TargetObject; }
        }

        /// <summary>
        /// Returns "MERGE_HEAD[i]", where i is the index of this merge head.
        /// </summary>
        protected override string Shorten()
        {
            return CanonicalName;
        }
    }

    /// <summary>
    /// Options controlling Merge behavior.
    /// </summary>
    public sealed class MergeOptions : MergeAndCheckoutOptionsBase
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MergeOptions"/> class.
        /// <para>
        ///   Default behavior:
        ///     A fast-forward merge will be performed if possible, unless the merge.ff configuration option is set.
        ///     A merge commit will be committed, if one was created.
        ///     Merge will attempt to find renames.
        /// </para>
        /// </summary>
        public MergeOptions()
        { }

        /// <summary>
        /// The type of merge to perform.
        /// </summary>
        public FastForwardStrategy FastForwardStrategy { get; set; }
    }

    /// <summary>
    /// Strategy used for merging.
    /// </summary>
    public enum FastForwardStrategy
    {
        /// <summary>
        /// Default fast-forward strategy.  If the merge.ff configuration option is set,
        /// it will be used.  If it is not set, this will perform a fast-forward merge if
        /// possible, otherwise a non-fast-forward merge that results in a merge commit.
        /// </summary>
        Default = 0,

        /// <summary>
        /// Do not fast-forward. Always creates a merge commit.
        /// </summary>
        NoFastForward = 1, /* GIT_MERGE_NO_FASTFORWARD */

        /// <summary>
        /// Only perform fast-forward merges.
        /// </summary>
        FastForwardOnly = 2, /* GIT_MERGE_FASTFORWARD_ONLY */
    }

    /// <summary>
    /// Options controlling the behavior of actions that use merge (merge
    /// proper, cherry-pick, revert)
    /// </summary>
    public abstract class MergeOptionsBase
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MergeOptionsBase"/> class.
        /// The default behavior is to attempt to find renames.
        /// </summary>
        protected MergeOptionsBase()
        {
            FindRenames = true;
            RenameThreshold = 50;
            TargetLimit = 200;
        }

        /// <summary>
        /// Find renames. Default is true.
        /// </summary>
        public bool FindRenames { get; set; }

        /// <summary>
        /// If set, do not create or return conflict entries, but stop and return
        /// an error result after finding the first conflict.
        /// </summary>
        public bool FailOnConflict { get; set; }

        /// <summary>
        /// Do not write the Resolve Undo Cache extension on the generated index. This can
        /// be useful when no merge resolution will be presented to the user (e.g. a server-side
        /// merge attempt).
        /// </summary>
        public bool SkipReuc { get; set; }

        /// <summary>
        /// Similarity to consider a file renamed.
        /// </summary>
        public int RenameThreshold;

        /// <summary>
        /// Maximum similarity sources to examine (overrides
        /// 'merge.renameLimit' config (default 200)
        /// </summary>
        public int TargetLimit;

        /// <summary>
        /// How to handle conflicts encountered during a merge.
        /// </summary>
        public MergeFileFavor MergeFileFavor { get; set; }

        /// <summary>
        /// Ignore changes in amount of whitespace
        /// </summary>
        public bool IgnoreWhitespaceChange { get; set; }
    }

    /// <summary>
    /// Enum specifying how merge should deal with conflicting regions
    /// of the files.
    /// </summary>
    public enum MergeFileFavor
    {
        /// <summary>
        /// When a region of a file is changed in both branches, a conflict
        /// will be recorded in the index so that the checkout operation can produce
        /// a merge file with conflict markers in the working directory.
        /// This is the default.
        /// </summary>
        Normal = 0,

        /// <summary>
        /// When a region of a file is changed in both branches, the file
        /// created in the index will contain the "ours" side of any conflicting
        /// region. The index will not record a conflict.
        /// </summary>
        Ours = 1,

        /// <summary>
        /// When a region of a file is changed in both branches, the file
        /// created in the index will contain the "theirs" side of any conflicting
        /// region. The index will not record a conflict.
        /// </summary>
        Theirs = 2,

        /// <summary>
        /// When a region of a file is changed in both branches, the file
        /// created in the index will contain each unique line from each side,
        /// which has the result of combining both files. The index will not
        /// record a conflict.
        /// </summary>
        Union = 3,
    }

    /// <summary>
    /// Class to report the result of a merge.
    /// </summary>
    public class MergeResult
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected MergeResult()
        { }

        internal MergeResult(MergeStatus status, Commit commit = null)
        {
            this.Status = status;
            this.Commit = commit;
        }

        /// <summary>
        /// The status of the merge.
        /// </summary>
        public virtual MergeStatus Status
        {
            get;
            private set;
        }

        /// <summary>
        /// The resulting commit of the merge. For fast-forward merges, this is the
        /// commit that merge was fast forwarded to.
        /// <para>This will return <code>null</code> if the merge has been unsuccessful due to conflicts.</para>
        /// </summary>
        public virtual Commit Commit
        {
            get;
            private set;
        }
    }

    /// <summary>
    /// The status of what happened as a result of a merge.
    /// </summary>
    public enum MergeStatus
    {
        /// <summary>
        /// Merge was up-to-date.
        /// </summary>
        UpToDate,

        /// <summary>
        /// Fast-forward merge.
        /// </summary>
        FastForward,

        /// <summary>
        /// Non-fast-forward merge.
        /// </summary>
        NonFastForward,

        /// <summary>
        /// Merge resulted in conflicts.
        /// </summary>
        Conflicts,
    }

    /// <summary>
    /// Options controlling the behavior of two trees being merged.
    /// </summary>
    public sealed class MergeTreeOptions : MergeOptionsBase
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MergeTreeOptions"/> class.
        /// <para>
        ///   Default behavior:
        ///     Merge will attempt to find renames.
        /// </para>
        /// </summary>
        public MergeTreeOptions()
        { }
    }

    /// <summary>
    /// The results of a merge of two trees.
    /// </summary>
    public class MergeTreeResult
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected MergeTreeResult()
        { }

        internal MergeTreeResult(IEnumerable<Conflict> conflicts)
        {
            this.Status = MergeTreeStatus.Conflicts;
            this.Conflicts = conflicts;
        }

        internal MergeTreeResult(Tree tree)
        {
            this.Status = MergeTreeStatus.Succeeded;
            this.Tree = tree;
            this.Conflicts = new List<Conflict>();
        }

        /// <summary>
        /// The status of the merge.
        /// </summary>
        public virtual MergeTreeStatus Status { get; private set; }

        /// <summary>
        /// The resulting tree of the merge.
        /// <para>This will return <code>null</code> if the merge has been unsuccessful due to conflicts.</para>
        /// </summary>
        public virtual Tree Tree { get; private set; }

        /// <summary>
        /// The resulting conflicts from the merge.
        /// <para>This will return <code>null</code> if the merge was successful and there were no conflicts.</para>
        /// </summary>
        public virtual IEnumerable<Conflict> Conflicts { get; private set; }
    }

    /// <summary>
    /// The status of what happened as a result of a merge.
    /// </summary>
    public enum MergeTreeStatus
    {
        /// <summary>
        /// Merge succeeded.
        /// </summary>
        Succeeded,

        /// <summary>
        /// Merge resulted in conflicts.
        /// </summary>
        Conflicts,
    }

    /// <summary>
    /// Git specific modes for entries.
    /// </summary>
    public enum Mode
    {
        // Inspired from http://stackoverflow.com/a/8347325/335418

        /// <summary>
        /// 000000 file mode (the entry doesn't exist or is unreadable)
        /// </summary>
        Nonexistent = 0,

        /// <summary>
        /// 040000 file mode
        /// </summary>
        Directory = 0x4000,

        /// <summary>
        /// 100644 file mode
        /// </summary>
        NonExecutableFile = 0x81A4,

        /// <summary>
        /// Obsolete 100664 file mode.
        /// <para>0100664 mode is an early Git design mistake. It's kept for
        ///   ascendant compatibility as some <see cref="Tree"/> and
        ///   <see cref="Repository.Index"/> entries may still bear
        ///   this mode in some old git repositories, but it's now deprecated.
        /// </para>
        /// </summary>
        NonExecutableGroupWritableFile = 0x81B4,

        /// <summary>
        /// 100755 file mode
        /// </summary>
        ExecutableFile = 0x81ED,

        /// <summary>
        /// 120000 file mode
        /// </summary>
        SymbolicLink = 0xA000,

        /// <summary>
        /// 160000 file mode
        /// </summary>
        GitLink = 0xE000
    }

    /// <summary>
    /// The exception that is thrown when a reference, a remote, a submodule... with the same name already exists in the repository
    /// </summary>
    [Serializable]
    public class NameConflictException : NativeException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NameConflictException"/> class.
        /// </summary>
        public NameConflictException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="NameConflictException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public NameConflictException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="NameConflictException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public NameConflictException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="NameConflictException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public NameConflictException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="NameConflictException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected NameConflictException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal NameConflictException(string message, GitErrorCategory category)
            : base(message, category)
        { }

        internal override GitErrorCode ErrorCode
        {
            get
            {
                return GitErrorCode.Exists;
            }
        }
    }

    /// <summary>
    /// An exception thrown that corresponds to a libgit2 (native library) error.
    /// </summary>
    [Serializable]
    public abstract class NativeException : LibGit2SharpException
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected NativeException()
        { }

        internal NativeException(string message)
            : base(message)
        { }

        internal NativeException(string message, Exception innerException)
            : base(message, innerException)
        { }

        internal NativeException(string format, params object[] args)
            : base(format, args)
        {
        }

        internal NativeException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal NativeException(string message, GitErrorCategory category) : this(message)
        {
            Data.Add("libgit2.category", (int)category);
        }

        internal abstract GitErrorCode ErrorCode { get; }
    }

    /// <summary>
    /// Provides access to network functionality for a repository.
    /// </summary>
    public class Network
    {
        private readonly Repository repository;
        private readonly Lazy<RemoteCollection> remotes;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Network()
        { }

        internal Network(Repository repository)
        {
            this.repository = repository;
            remotes = new Lazy<RemoteCollection>(() => new RemoteCollection(repository));
        }

        /// <summary>
        /// Lookup and manage remotes in the repository.
        /// </summary>
        public virtual RemoteCollection Remotes
        {
            get { return remotes.Value; }
        }

        /// <summary>
        /// List references in a <see cref="Remote"/> repository.
        /// <para>
        /// When the remote tips are ahead of the local ones, the retrieved
        /// <see cref="DirectReference"/>s may point to non existing
        /// <see cref="GitObject"/>s in the local repository. In that
        /// case, <see cref="DirectReference.Target"/> will return <c>null</c>.
        /// </para>
        /// </summary>
        /// <param name="remote">The <see cref="Remote"/> to list from.</param>
        /// <returns>The references in the <see cref="Remote"/> repository.</returns>
        public virtual IEnumerable<Reference> ListReferences(Remote remote)
        {
            Ensure.ArgumentNotNull(remote, "remote");

            return ListReferencesInternal(remote.Url, null, new ProxyOptions());
        }

        /// <summary>
        /// List references in a <see cref="Remote"/> repository.
        /// <para>
        /// When the remote tips are ahead of the local ones, the retrieved
        /// <see cref="DirectReference"/>s may point to non existing
        /// <see cref="GitObject"/>s in the local repository. In that
        /// case, <see cref="DirectReference.Target"/> will return <c>null</c>.
        /// </para>
        /// </summary>
        /// <param name="remote">The <see cref="Remote"/> to list from.</param>
        /// <param name="proxyOptions">Options for connecting through a proxy.</param>
        /// <returns>The references in the <see cref="Remote"/> repository.</returns>
        public virtual IEnumerable<Reference> ListReferences(Remote remote, ProxyOptions proxyOptions)
        {
            Ensure.ArgumentNotNull(remote, "remote");

            return ListReferencesInternal(remote.Url, null, proxyOptions);
        }

        /// <summary>
        /// List references in a <see cref="Remote"/> repository.
        /// <para>
        /// When the remote tips are ahead of the local ones, the retrieved
        /// <see cref="DirectReference"/>s may point to non existing
        /// <see cref="GitObject"/>s in the local repository. In that
        /// case, <see cref="DirectReference.Target"/> will return <c>null</c>.
        /// </para>
        /// </summary>
        /// <param name="remote">The <see cref="Remote"/> to list from.</param>
        /// <param name="credentialsProvider">The <see cref="Func{Credentials}"/> used to connect to remote repository.</param>
        /// <returns>The references in the <see cref="Remote"/> repository.</returns>
        public virtual IEnumerable<Reference> ListReferences(Remote remote, CredentialsHandler credentialsProvider)
        {
            Ensure.ArgumentNotNull(remote, "remote");
            Ensure.ArgumentNotNull(credentialsProvider, "credentialsProvider");

            return ListReferencesInternal(remote.Url, credentialsProvider, new ProxyOptions());
        }

        /// <summary>
        /// List references in a <see cref="Remote"/> repository.
        /// <para>
        /// When the remote tips are ahead of the local ones, the retrieved
        /// <see cref="DirectReference"/>s may point to non existing
        /// <see cref="GitObject"/>s in the local repository. In that
        /// case, <see cref="DirectReference.Target"/> will return <c>null</c>.
        /// </para>
        /// </summary>
        /// <param name="remote">The <see cref="Remote"/> to list from.</param>
        /// <param name="credentialsProvider">The <see cref="Func{Credentials}"/> used to connect to remote repository.</param>
        /// <param name="proxyOptions">Options for connecting through a proxy.</param>
        /// <returns>The references in the <see cref="Remote"/> repository.</returns>
        public virtual IEnumerable<Reference> ListReferences(Remote remote, CredentialsHandler credentialsProvider, ProxyOptions proxyOptions)
        {
            Ensure.ArgumentNotNull(remote, "remote");
            Ensure.ArgumentNotNull(credentialsProvider, "credentialsProvider");

            return ListReferencesInternal(remote.Url, credentialsProvider, proxyOptions);
        }

        /// <summary>
        /// List references in a remote repository.
        /// <para>
        /// When the remote tips are ahead of the local ones, the retrieved
        /// <see cref="DirectReference"/>s may point to non existing
        /// <see cref="GitObject"/>s in the local repository. In that
        /// case, <see cref="DirectReference.Target"/> will return <c>null</c>.
        /// </para>
        /// </summary>
        /// <param name="url">The url to list from.</param>
        /// <returns>The references in the remote repository.</returns>
        public virtual IEnumerable<Reference> ListReferences(string url)
        {
            Ensure.ArgumentNotNull(url, "url");

            return ListReferencesInternal(url, null, new ProxyOptions());
        }

        /// <summary>
        /// List references in a remote repository.
        /// <para>
        /// When the remote tips are ahead of the local ones, the retrieved
        /// <see cref="DirectReference"/>s may point to non existing
        /// <see cref="GitObject"/>s in the local repository. In that
        /// case, <see cref="DirectReference.Target"/> will return <c>null</c>.
        /// </para>
        /// </summary>
        /// <param name="url">The url to list from.</param>
        /// <param name="proxyOptions">Options for connecting through a proxy.</param>
        /// <returns>The references in the remote repository.</returns>
        public virtual IEnumerable<Reference> ListReferences(string url, ProxyOptions proxyOptions)
        {
            Ensure.ArgumentNotNull(url, "url");

            return ListReferencesInternal(url, null, proxyOptions);
        }

        /// <summary>
        /// List references in a remote repository.
        /// <para>
        /// When the remote tips are ahead of the local ones, the retrieved
        /// <see cref="DirectReference"/>s may point to non existing
        /// <see cref="GitObject"/>s in the local repository. In that
        /// case, <see cref="DirectReference.Target"/> will return <c>null</c>.
        /// </para>
        /// </summary>
        /// <param name="url">The url to list from.</param>
        /// <param name="credentialsProvider">The <see cref="Func{Credentials}"/> used to connect to remote repository.</param>
        /// <returns>The references in the remote repository.</returns>
        public virtual IEnumerable<Reference> ListReferences(string url, CredentialsHandler credentialsProvider)
        {
            Ensure.ArgumentNotNull(url, "url");
            Ensure.ArgumentNotNull(credentialsProvider, "credentialsProvider");

            return ListReferencesInternal(url, credentialsProvider, new ProxyOptions());
        }

        /// <summary>
        /// List references in a remote repository.
        /// <para>
        /// When the remote tips are ahead of the local ones, the retrieved
        /// <see cref="DirectReference"/>s may point to non existing
        /// <see cref="GitObject"/>s in the local repository. In that
        /// case, <see cref="DirectReference.Target"/> will return <c>null</c>.
        /// </para>
        /// </summary>
        /// <param name="url">The url to list from.</param>
        /// <param name="credentialsProvider">The <see cref="Func{Credentials}"/> used to connect to remote repository.</param>
        /// <param name="proxyOptions">Options for connecting through a proxy.</param>
        /// <returns>The references in the remote repository.</returns>
        public virtual IEnumerable<Reference> ListReferences(string url, CredentialsHandler credentialsProvider, ProxyOptions proxyOptions)
        {
            Ensure.ArgumentNotNull(url, "url");
            Ensure.ArgumentNotNull(credentialsProvider, "credentialsProvider");

            return ListReferencesInternal(url, credentialsProvider, new ProxyOptions());
        }

        private IEnumerable<Reference> ListReferencesInternal(string url, CredentialsHandler credentialsProvider, ProxyOptions proxyOptions)
        {
            if (proxyOptions == null) proxyOptions = new ProxyOptions();

            RemoteHandle remoteHandle = BuildRemoteHandle(repository.Handle, url);
            var proxyOptionsWrapper = new GitProxyOptionsWrapper(proxyOptions.CreateGitProxyOptions());

            GitRemoteCallbacks gitCallbacks = new GitRemoteCallbacks { version = 1 };

            if (credentialsProvider != null)
            {
                var callbacks = new RemoteCallbacks(credentialsProvider);
                gitCallbacks = callbacks.GenerateCallbacks();
            }

            var gitProxyOptions = proxyOptionsWrapper.Options;

            Proxy.git_remote_connect(remoteHandle, GitDirection.Fetch, ref gitCallbacks, ref gitProxyOptions);
            return Proxy.git_remote_ls(repository, remoteHandle);
        }

        static RemoteHandle BuildRemoteHandle(RepositoryHandle repoHandle, string url)
        {
            Debug.Assert(repoHandle != null && !repoHandle.IsNull);
            Debug.Assert(url != null);

            RemoteHandle remoteHandle = Proxy.git_remote_create_anonymous(repoHandle, url);
            Debug.Assert(remoteHandle != null && !(remoteHandle.IsNull));

            return remoteHandle;
        }

        /// <summary>
        /// Fetch from a url with a set of fetch refspecs
        /// </summary>
        /// <param name="url">The url to fetch from</param>
        /// <param name="refspecs">The list of resfpecs to use</param>
        public virtual void Fetch(string url, IEnumerable<string> refspecs)
        {
            Fetch(url, refspecs, null, null);
        }

        /// <summary>
        /// Fetch from a url with a set of fetch refspecs
        /// </summary>
        /// <param name="url">The url to fetch from</param>
        /// <param name="refspecs">The list of resfpecs to use</param>
        /// <param name="options"><see cref="FetchOptions"/> controlling fetch behavior</param>
        public virtual void Fetch(string url, IEnumerable<string> refspecs, FetchOptions options)
        {
            Fetch(url, refspecs, options, null);
        }

        /// <summary>
        /// Fetch from a url with a set of fetch refspecs
        /// </summary>
        /// <param name="url">The url to fetch from</param>
        /// <param name="refspecs">The list of resfpecs to use</param>
        /// <param name="logMessage">Message to use when updating the reflog.</param>
        public virtual void Fetch(string url, IEnumerable<string> refspecs, string logMessage)
        {
            Fetch(url, refspecs, null, logMessage);
        }

        /// <summary>
        /// Fetch from a url with a set of fetch refspecs
        /// </summary>
        /// <param name="url">The url to fetch from</param>
        /// <param name="refspecs">The list of resfpecs to use</param>
        /// <param name="options"><see cref="FetchOptions"/> controlling fetch behavior</param>
        /// <param name="logMessage">Message to use when updating the reflog.</param>
        public virtual void Fetch(
            string url,
            IEnumerable<string> refspecs,
            FetchOptions options,
            string logMessage)
        {
            Ensure.ArgumentNotNull(url, "url");
            Ensure.ArgumentNotNull(refspecs, "refspecs");

            Commands.Fetch(repository, url, refspecs, options, logMessage);
        }

        /// <summary>
        /// Push the specified branch to its tracked branch on the remote.
        /// </summary>
        /// <param name="branch">The branch to push.</param>
        /// <exception cref="LibGit2SharpException">Throws if either the Remote or the UpstreamBranchCanonicalName is not set.</exception>
        public virtual void Push(
            Branch branch)
        {
            Push(new[] { branch });
        }
        /// <summary>
        /// Push the specified branch to its tracked branch on the remote.
        /// </summary>
        /// <param name="branch">The branch to push.</param>
        /// <param name="pushOptions"><see cref="PushOptions"/> controlling push behavior</param>
        /// <exception cref="LibGit2SharpException">Throws if either the Remote or the UpstreamBranchCanonicalName is not set.</exception>
        public virtual void Push(
            Branch branch,
            PushOptions pushOptions)
        {
            Push(new[] { branch }, pushOptions);
        }

        /// <summary>
        /// Push the specified branches to their tracked branches on the remote.
        /// </summary>
        /// <param name="branches">The branches to push.</param>
        /// <exception cref="LibGit2SharpException">Throws if either the Remote or the UpstreamBranchCanonicalName is not set.</exception>
        public virtual void Push(
            IEnumerable<Branch> branches)
        {
            Push(branches, null);
        }

        /// <summary>
        /// Push the specified branches to their tracked branches on the remote.
        /// </summary>
        /// <param name="branches">The branches to push.</param>
        /// <param name="pushOptions"><see cref="PushOptions"/> controlling push behavior</param>
        /// <exception cref="LibGit2SharpException">Throws if either the Remote or the UpstreamBranchCanonicalName is not set.</exception>
        public virtual void Push(
            IEnumerable<Branch> branches,
            PushOptions pushOptions)
        {
            var enumeratedBranches = branches as IList<Branch> ?? branches.ToList();

            foreach (var branch in enumeratedBranches)
            {
                if (string.IsNullOrEmpty(branch.UpstreamBranchCanonicalName))
                {
                    throw new LibGit2SharpException("The branch '{0}' (\"{1}\") that you are trying to push does not track an upstream branch.",
                            branch.FriendlyName, branch.CanonicalName);
                }
            }

            foreach (var branch in enumeratedBranches)
            {
                using (var remote = repository.Network.Remotes.RemoteForName(branch.RemoteName))
                {
                    Push(remote, string.Format(
                        CultureInfo.InvariantCulture,
                        "{0}:{1}", branch.CanonicalName, branch.UpstreamBranchCanonicalName), pushOptions);
                }
            }
        }

        /// <summary>
        /// Push the objectish to the destination reference on the <see cref="Remote"/>.
        /// </summary>
        /// <param name="remote">The <see cref="Remote"/> to push to.</param>
        /// <param name="objectish">The source objectish to push.</param>
        /// <param name="destinationSpec">The reference to update on the remote.</param>
        public virtual void Push(
            Remote remote,
            string objectish,
            string destinationSpec)
        {
            Ensure.ArgumentNotNull(objectish, "objectish");
            Ensure.ArgumentNotNullOrEmptyString(destinationSpec, "destinationSpec");

            Push(remote,
                 string.Format(CultureInfo.InvariantCulture,
                               "{0}:{1}",
                               objectish,
                               destinationSpec));
        }

        /// <summary>
        /// Push the objectish to the destination reference on the <see cref="Remote"/>.
        /// </summary>
        /// <param name="remote">The <see cref="Remote"/> to push to.</param>
        /// <param name="objectish">The source objectish to push.</param>
        /// <param name="destinationSpec">The reference to update on the remote.</param>
        /// <param name="pushOptions"><see cref="PushOptions"/> controlling push behavior</param>
        public virtual void Push(
            Remote remote,
            string objectish,
            string destinationSpec,
            PushOptions pushOptions)
        {
            Ensure.ArgumentNotNull(objectish, "objectish");
            Ensure.ArgumentNotNullOrEmptyString(destinationSpec, "destinationSpec");

            Push(remote,
                 string.Format(CultureInfo.InvariantCulture,
                               "{0}:{1}",
                               objectish,
                               destinationSpec),
                 pushOptions);
        }

        /// <summary>
        /// Push specified reference to the <see cref="Remote"/>.
        /// </summary>
        /// <param name="remote">The <see cref="Remote"/> to push to.</param>
        /// <param name="pushRefSpec">The pushRefSpec to push.</param>
        public virtual void Push(Remote remote, string pushRefSpec)
        {
            Ensure.ArgumentNotNullOrEmptyString(pushRefSpec, "pushRefSpec");

            Push(remote, new[] { pushRefSpec });
        }
        /// <summary>
        /// Push specified reference to the <see cref="Remote"/>.
        /// </summary>
        /// <param name="remote">The <see cref="Remote"/> to push to.</param>
        /// <param name="pushRefSpec">The pushRefSpec to push.</param>
        /// <param name="pushOptions"><see cref="PushOptions"/> controlling push behavior</param>
        public virtual void Push(
            Remote remote,
            string pushRefSpec,
            PushOptions pushOptions)
        {
            Ensure.ArgumentNotNullOrEmptyString(pushRefSpec, "pushRefSpec");

            Push(remote, new[] { pushRefSpec }, pushOptions);
        }

        /// <summary>
        /// Push specified references to the <see cref="Remote"/>.
        /// </summary>
        /// <param name="remote">The <see cref="Remote"/> to push to.</param>
        /// <param name="pushRefSpecs">The pushRefSpecs to push.</param>
        public virtual void Push(Remote remote, IEnumerable<string> pushRefSpecs)
        {
            Push(remote, pushRefSpecs, null);
        }

        /// <summary>
        /// Push specified references to the <see cref="Remote"/>.
        /// </summary>
        /// <param name="remote">The <see cref="Remote"/> to push to.</param>
        /// <param name="pushRefSpecs">The pushRefSpecs to push.</param>
        /// <param name="pushOptions"><see cref="PushOptions"/> controlling push behavior</param>
        public virtual void Push(Remote remote, IEnumerable<string> pushRefSpecs, PushOptions pushOptions)
        {
            Ensure.ArgumentNotNull(remote, "remote");
            Ensure.ArgumentNotNull(pushRefSpecs, "pushRefSpecs");

            // Return early if there is nothing to push.
            if (!pushRefSpecs.Any())
            {
                return;
            }

            if (pushOptions == null)
            {
                pushOptions = new PushOptions();
            }

            // Load the remote.
            using (RemoteHandle remoteHandle = Proxy.git_remote_lookup(repository.Handle, remote.Name, true))

            // Create a git options wrapper so managed strings are disposed.
            using (var pushOptionsWrapper = new GitPushOptionsWrapper())
            {
                var callbacks = new RemoteCallbacks(pushOptions);
                GitRemoteCallbacks gitCallbacks = callbacks.GenerateCallbacks();

                var gitPushOptions = pushOptionsWrapper.Options;
                gitPushOptions.PackbuilderDegreeOfParallelism = pushOptions.PackbuilderDegreeOfParallelism;
                gitPushOptions.RemoteCallbacks = gitCallbacks;
                gitPushOptions.ProxyOptions = pushOptions.ProxyOptions.CreateGitProxyOptions();

                // If there are custom headers, create a managed string array.
                if (pushOptions.CustomHeaders != null && pushOptions.CustomHeaders.Length > 0)
                {
                    gitPushOptions.CustomHeaders = GitStrArrayManaged.BuildFrom(pushOptions.CustomHeaders);
                }

                Proxy.git_remote_push(remoteHandle,
                                      pushRefSpecs,
                                      gitPushOptions);
            }
        }

        /// <summary>
        /// The heads that have been updated during the last fetch.
        /// </summary>
        internal virtual IEnumerable<FetchHead> FetchHeads
        {
            get
            {
                int i = 0;

                Func<string, string, GitOid, bool, FetchHead> resultSelector =
                    (name, url, oid, isMerge) => new FetchHead(repository, name, url, oid, isMerge, i++);

                return Proxy.git_repository_fetchhead_foreach(repository.Handle, resultSelector);
            }
        }
    }

    /// <summary>
    /// The exception that is thrown when push cannot be performed
    /// against the remote without losing commits.
    /// </summary>
    [Serializable]
    public class NonFastForwardException : NativeException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.NonFastForwardException"/> class.
        /// </summary>
        public NonFastForwardException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.NonFastForwardException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public NonFastForwardException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.NonFastForwardException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public NonFastForwardException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.NonFastForwardException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public NonFastForwardException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.NonFastForwardException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected NonFastForwardException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal NonFastForwardException(string message, GitErrorCategory category)
            : base(message, category)
        { }

        internal override GitErrorCode ErrorCode
        {
            get
            {
                return GitErrorCode.NonFastForward;
            }
        }
    }

    /// <summary>
    /// A note, attached to a given <see cref="GitObject"/>.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class Note : IEquatable<Note>
    {
        private static readonly LambdaEqualityHelper<Note> equalityHelper =
            new LambdaEqualityHelper<Note>(x => x.BlobId, x => x.TargetObjectId, x => x.Namespace);

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Note()
        { }

        private Note(ObjectId blobId, string message, ObjectId targetObjectId, string @namespace)
        {
            BlobId = blobId;
            Namespace = @namespace;
            Message = message;
            TargetObjectId = targetObjectId;
        }

        /// <summary>
        /// The <see cref="ObjectId"/> of the blob containing the note message.
        /// </summary>
        public virtual ObjectId BlobId { get; private set; }

        /// <summary>
        /// The message.
        /// </summary>
        public virtual string Message { get; private set; }

        /// <summary>
        /// The namespace with which this note is associated.
        /// <para>This is the abbreviated namespace (e.g.: commits), and not the canonical namespace (e.g.: refs/notes/commits).</para>
        /// </summary>
        public virtual string Namespace { get; private set; }

        /// <summary>
        /// The <see cref="ObjectId"/> of the target object.
        /// </summary>
        public virtual ObjectId TargetObjectId { get; private set; }

        internal static Note BuildFromPtr(NoteHandle note, string @namespace, ObjectId targetObjectId)
        {
            ObjectId oid = Proxy.git_note_id(note);
            string message = Proxy.git_note_message(note);

            return new Note(oid, message, targetObjectId, @namespace);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="Note"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="Note"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="Note"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as Note);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Note"/> is equal to the current <see cref="Note"/>.
        /// </summary>
        /// <param name="other">The <see cref="Note"/> to compare with the current <see cref="Note"/>.</param>
        /// <returns>True if the specified <see cref="Note"/> is equal to the current <see cref="Note"/>; otherwise, false.</returns>
        public bool Equals(Note other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="Note"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="Note"/> to compare.</param>
        /// <param name="right">Second <see cref="Note"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(Note left, Note right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="Note"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="Note"/> to compare.</param>
        /// <param name="right">Second <see cref="Note"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(Note left, Note right)
        {
            return !Equals(left, right);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "Target \"{0}\", Namespace \"{1}\": {2}",
                                     TargetObjectId.ToString(7),
                                     Namespace,
                                     Message);
            }
        }
    }

    /// <summary>
    /// A collection of <see cref="Note"/> exposed in the <see cref="Repository"/>.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class NoteCollection : IEnumerable<Note>
    {
        internal readonly Repository repo;
        private readonly Lazy<string> defaultNamespace;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected NoteCollection()
        { }

        internal NoteCollection(Repository repo)
        {
            this.repo = repo;
            defaultNamespace = new Lazy<string>(RetrieveDefaultNamespace);
        }

        #region Implementation of IEnumerable

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<Note> GetEnumerator()
        {
            return this[DefaultNamespace].GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        /// <summary>
        /// The default namespace for notes.
        /// </summary>
        public virtual string DefaultNamespace
        {
            get { return defaultNamespace.Value; }
        }

        /// <summary>
        /// The list of canonicalized namespaces related to notes.
        /// </summary>
        public virtual IEnumerable<string> Namespaces
        {
            get { return NamespaceRefs.Select(UnCanonicalizeName); }
        }

        internal IEnumerable<string> NamespaceRefs
        {
            get
            {
                return new[] { NormalizeToCanonicalName(DefaultNamespace) }.Concat(repo.Refs
                    .Select(reference => reference.CanonicalName)
                    .Where(refCanonical => refCanonical.StartsWith(Reference.NotePrefix, StringComparison.Ordinal) && refCanonical != NormalizeToCanonicalName(DefaultNamespace)));
            }
        }

        /// <summary>
        /// Gets the collection of <see cref="Note"/> associated with the specified <see cref="ObjectId"/>.
        /// </summary>
        public virtual IEnumerable<Note> this[ObjectId id]
        {
            get
            {
                Ensure.ArgumentNotNull(id, "id");

                return NamespaceRefs
                    .Select(ns => this[ns, id])
                    .Where(n => n != null);
            }
        }

        /// <summary>
        /// Gets the collection of <see cref="Note"/> associated with the specified namespace.
        /// <para>This is similar to the 'get notes list' command.</para>
        /// </summary>
        public virtual IEnumerable<Note> this[string @namespace]
        {
            get
            {
                Ensure.ArgumentNotNull(@namespace, "@namespace");

                string canonicalNamespace = NormalizeToCanonicalName(@namespace);

                return Proxy.git_note_foreach(repo.Handle,
                                              canonicalNamespace,
                                              (blobId, annotatedObjId) => this[canonicalNamespace, annotatedObjId]);
            }
        }

        /// <summary>
        /// Gets the <see cref="Note"/> associated with the specified objectId and the specified namespace.
        /// </summary>
        public virtual Note this[string @namespace, ObjectId id]
        {
            get
            {
                Ensure.ArgumentNotNull(id, "id");
                Ensure.ArgumentNotNull(@namespace, "@namespace");

                string canonicalNamespace = NormalizeToCanonicalName(@namespace);

                using (NoteHandle noteHandle = Proxy.git_note_read(repo.Handle, canonicalNamespace, id))
                {
                    return noteHandle == null
                        ? null
                        : Note.BuildFromPtr(noteHandle, UnCanonicalizeName(canonicalNamespace), id);
                }
            }
        }

        private string RetrieveDefaultNamespace()
        {
            string notesRef = Proxy.git_note_default_ref(repo.Handle);

            return UnCanonicalizeName(notesRef);
        }

        internal static string NormalizeToCanonicalName(string name)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");

            if (name.LooksLikeNote())
            {
                return name;
            }

            return string.Concat(Reference.NotePrefix, name);
        }

        internal static string UnCanonicalizeName(string name)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");

            if (!name.LooksLikeNote())
            {
                return name;
            }

            return name.Substring(Reference.NotePrefix.Length);
        }

        /// <summary>
        /// Creates or updates a <see cref="Note"/> on the specified object, and for the given namespace.
        /// </summary>
        /// <param name="targetId">The target <see cref="ObjectId"/>, for which the note will be created.</param>
        /// <param name="message">The note message.</param>
        /// <param name="author">The author.</param>
        /// <param name="committer">The committer.</param>
        /// <param name="namespace">The namespace on which the note will be created. It can be either a canonical namespace or an abbreviated namespace ('refs/notes/myNamespace' or just 'myNamespace').</param>
        /// <returns>The note which was just saved.</returns>
        public virtual Note Add(ObjectId targetId, string message, Signature author, Signature committer, string @namespace)
        {
            Ensure.ArgumentNotNull(targetId, "targetId");
            Ensure.ArgumentNotNullOrEmptyString(message, "message");
            Ensure.ArgumentNotNull(author, "author");
            Ensure.ArgumentNotNull(committer, "committer");
            Ensure.ArgumentNotNullOrEmptyString(@namespace, "@namespace");

            string canonicalNamespace = NormalizeToCanonicalName(@namespace);

            Remove(targetId, author, committer, @namespace);

            Proxy.git_note_create(repo.Handle, canonicalNamespace, author, committer, targetId, message, true);

            return this[canonicalNamespace, targetId];
        }

        /// <summary>
        /// Deletes the note on the specified object, and for the given namespace.
        /// </summary>
        /// <param name="targetId">The target <see cref="ObjectId"/>, for which the note will be created.</param>
        /// <param name="author">The author.</param>
        /// <param name="committer">The committer.</param>
        /// <param name="namespace">The namespace on which the note will be removed. It can be either a canonical namespace or an abbreviated namespace ('refs/notes/myNamespace' or just 'myNamespace').</param>
        public virtual void Remove(ObjectId targetId, Signature author, Signature committer, string @namespace)
        {
            Ensure.ArgumentNotNull(targetId, "targetId");
            Ensure.ArgumentNotNull(author, "author");
            Ensure.ArgumentNotNull(committer, "committer");
            Ensure.ArgumentNotNullOrEmptyString(@namespace, "@namespace");

            string canonicalNamespace = NormalizeToCanonicalName(@namespace);

            Proxy.git_note_remove(repo.Handle, canonicalNamespace, author, committer, targetId);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "Count = {0}", this.Count());
            }
        }
    }

    /// <summary>
    /// The exception that is thrown attempting to reference a resource that does not exist.
    /// </summary>
    [Serializable]
    public class NotFoundException : NativeException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.NotFoundException"/> class.
        /// </summary>
        public NotFoundException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.NotFoundException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public NotFoundException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.NotFoundException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public NotFoundException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.NotFoundException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public NotFoundException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.NotFoundException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected NotFoundException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal NotFoundException(string message, GitErrorCategory category)
            : base(message, category)
        { }

        internal override GitErrorCode ErrorCode
        {
            get
            {
                return GitErrorCode.NotFound;
            }
        }
    }

    /// <summary>
    /// Provides methods to directly work against the Git object database
    /// without involving the index nor the working directory.
    /// </summary>
    public class ObjectDatabase : IEnumerable<GitObject>
    {
        private readonly Repository repo;
        private readonly ObjectDatabaseHandle handle;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected ObjectDatabase()
        { }

        internal ObjectDatabase(Repository repo)
        {
            this.repo = repo;
            handle = Proxy.git_repository_odb(repo.Handle);

            repo.RegisterForCleanup(handle);
        }

        #region Implementation of IEnumerable

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<GitObject> GetEnumerator()
        {
            ICollection<ObjectId> oids = Proxy.git_odb_foreach(handle);

            return oids
                .Select(gitOid => repo.Lookup<GitObject>(gitOid))
                .GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        /// <summary>
        /// Determines if the given object can be found in the object database.
        /// </summary>
        /// <param name="objectId">Identifier of the object being searched for.</param>
        /// <returns>True if the object has been found; false otherwise.</returns>
        public virtual bool Contains(ObjectId objectId)
        {
            Ensure.ArgumentNotNull(objectId, "objectId");

            return Proxy.git_odb_exists(handle, objectId);
        }

        /// <summary>
        /// Retrieves the header of a GitObject from the object database. The header contains the Size
        /// and Type of the object. Note that most backends do not support reading only the header
        /// of an object, so the whole object will be read and then size would be returned.
        /// </summary>
        /// <param name="objectId">Object Id of the queried object</param>
        /// <returns>GitObjectMetadata object instance containg object header information</returns>
        public virtual GitObjectMetadata RetrieveObjectMetadata(ObjectId objectId)
        {
            Ensure.ArgumentNotNull(objectId, "objectId");

            return Proxy.git_odb_read_header(handle, objectId);
        }

        /// <summary>
        /// Inserts a <see cref="Blob"/> into the object database, created from the content of a file.
        /// </summary>
        /// <param name="path">Path to the file to create the blob from.  A relative path is allowed to
        /// be passed if the <see cref="Repository"/> is a standard, non-bare, repository. The path
        /// will then be considered as a path relative to the root of the working directory.</param>
        /// <returns>The created <see cref="Blob"/>.</returns>
        public virtual Blob CreateBlob(string path)
        {
            Ensure.ArgumentNotNullOrEmptyString(path, "path");

            if (repo.Info.IsBare && !Path.IsPathRooted(path))
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture,
                                                    "Cannot create a blob in a bare repository from a relative path ('{0}').",
                                                    path));
            }

            ObjectId id = Path.IsPathRooted(path)
                ? Proxy.git_blob_create_from_disk(repo.Handle, path)
                : Proxy.git_blob_create_from_workdir(repo.Handle, path);

            return repo.Lookup<Blob>(id);
        }

        /// <summary>
        /// Adds the provided backend to the object database with the specified priority.
        /// <para>
        /// If the provided backend implements <see cref="IDisposable"/>, the <see cref="IDisposable.Dispose"/>
        /// method will be honored and invoked upon the disposal of the repository.
        /// </para>
        /// </summary>
        /// <param name="backend">The backend to add</param>
        /// <param name="priority">The priority at which libgit2 should consult this backend (higher values are consulted first)</param>
        public virtual void AddBackend(OdbBackend backend, int priority)
        {
            Ensure.ArgumentNotNull(backend, "backend");
            Ensure.ArgumentConformsTo(priority, s => s > 0, "priority");

            Proxy.git_odb_add_backend(handle, backend.GitOdbBackendPointer, priority);
        }

        private class Processor
        {
            private readonly Stream stream;
            private readonly long? numberOfBytesToConsume;
            private int totalNumberOfReadBytes;

            public Processor(Stream stream, long? numberOfBytesToConsume)
            {
                this.stream = stream;
                this.numberOfBytesToConsume = numberOfBytesToConsume;
            }

            public int Provider(IntPtr content, int max_length, IntPtr data)
            {
                var local = new byte[max_length];

                int bytesToRead = max_length;

                if (numberOfBytesToConsume.HasValue)
                {
                    long totalRemainingBytesToRead = numberOfBytesToConsume.Value - totalNumberOfReadBytes;

                    if (totalRemainingBytesToRead < max_length)
                    {
                        bytesToRead = totalRemainingBytesToRead > int.MaxValue
                            ? int.MaxValue
                            : (int)totalRemainingBytesToRead;
                    }
                }

                if (bytesToRead == 0)
                {
                    return 0;
                }

                int numberOfReadBytes = stream.Read(local, 0, bytesToRead);

                if (numberOfBytesToConsume.HasValue && numberOfReadBytes == 0)
                {
                    return (int)GitErrorCode.User;
                }

                totalNumberOfReadBytes += numberOfReadBytes;

                Marshal.Copy(local, 0, content, numberOfReadBytes);

                return numberOfReadBytes;
            }
        }

        /// <summary>
        /// Writes an object to the object database.
        /// </summary>
        /// <param name="data">The contents of the object</param>
        /// <typeparam name="T">The type of object to write</typeparam>
        public virtual ObjectId Write<T>(byte[] data) where T : GitObject
        {
            return Proxy.git_odb_write(handle, data, GitObject.TypeToKindMap[typeof(T)]);
        }

        /// <summary>
        /// Writes an object to the object database.
        /// </summary>
        /// <param name="stream">The contents of the object</param>
        /// <param name="numberOfBytesToConsume">The number of bytes to consume from the stream</param>
        /// <typeparam name="T">The type of object to write</typeparam>
        public virtual ObjectId Write<T>(Stream stream, long numberOfBytesToConsume) where T : GitObject
        {
            Ensure.ArgumentNotNull(stream, "stream");

            if (!stream.CanRead)
            {
                throw new ArgumentException("The stream cannot be read from.", "stream");
            }

            using (var odbStream = Proxy.git_odb_open_wstream(handle, numberOfBytesToConsume, GitObjectType.Blob))
            {
                var buffer = new byte[4 * 1024];
                long totalRead = 0;

                while (totalRead < numberOfBytesToConsume)
                {
                    long left = numberOfBytesToConsume - totalRead;
                    int toRead = left < buffer.Length ? (int)left : buffer.Length;
                    var read = stream.Read(buffer, 0, toRead);

                    if (read == 0)
                    {
                        throw new EndOfStreamException("The stream ended unexpectedly");
                    }

                    Proxy.git_odb_stream_write(odbStream, buffer, read);
                    totalRead += read;
                }

                return Proxy.git_odb_stream_finalize_write(odbStream);
            }
        }

        /// <summary>
        /// Inserts a <see cref="Blob"/> into the object database, created from the content of a stream.
        /// <para>Optionally, git filters will be applied to the content before storing it.</para>
        /// </summary>
        /// <param name="stream">The stream from which will be read the content of the blob to be created.</param>
        /// <returns>The created <see cref="Blob"/>.</returns>
        public virtual Blob CreateBlob(Stream stream)
        {
            return CreateBlob(stream, null, null);
        }

        /// <summary>
        /// Inserts a <see cref="Blob"/> into the object database, created from the content of a stream.
        /// <para>Optionally, git filters will be applied to the content before storing it.</para>
        /// </summary>
        /// <param name="stream">The stream from which will be read the content of the blob to be created.</param>
        /// <param name="hintpath">The hintpath is used to determine what git filters should be applied to the object before it can be placed to the object database.</param>
        /// <returns>The created <see cref="Blob"/>.</returns>
        public virtual Blob CreateBlob(Stream stream, string hintpath)
        {
            return CreateBlob(stream, hintpath, null);
        }

        /// <summary>
        /// Inserts a <see cref="Blob"/> into the object database, created from the content of a stream.
        /// <para>Optionally, git filters will be applied to the content before storing it.</para>
        /// </summary>
        /// <param name="stream">The stream from which will be read the content of the blob to be created.</param>
        /// <param name="hintpath">The hintpath is used to determine what git filters should be applied to the object before it can be placed to the object database.</param>
        /// <param name="numberOfBytesToConsume">The number of bytes to consume from the stream.</param>
        /// <returns>The created <see cref="Blob"/>.</returns>
        public virtual Blob CreateBlob(Stream stream, string hintpath, long numberOfBytesToConsume)
        {
            return CreateBlob(stream, hintpath, (long?)numberOfBytesToConsume);
        }

        private unsafe Blob CreateBlob(Stream stream, string hintpath, long? numberOfBytesToConsume)
        {
            Ensure.ArgumentNotNull(stream, "stream");

            // there's no need to buffer the file for filtering, so simply use a stream
            if (hintpath == null && numberOfBytesToConsume.HasValue)
            {
                return CreateBlob(stream, numberOfBytesToConsume.Value);
            }

            if (!stream.CanRead)
            {
                throw new ArgumentException("The stream cannot be read from.", "stream");
            }

            IntPtr writestream_ptr = Proxy.git_blob_create_from_stream(repo.Handle, hintpath);
            GitWriteStream writestream = (GitWriteStream)Marshal.PtrToStructure(writestream_ptr, typeof(GitWriteStream));

            try
            {
                var buffer = new byte[4 * 1024];
                long totalRead = 0;
                int read = 0;

                while (true)
                {
                    int toRead = numberOfBytesToConsume.HasValue ?
                        (int)Math.Min(numberOfBytesToConsume.Value - totalRead, (long)buffer.Length) :
                        buffer.Length;

                    if (toRead > 0)
                    {
                        read = (toRead > 0) ? stream.Read(buffer, 0, toRead) : 0;
                    }

                    if (read == 0)
                    {
                        break;
                    }

                    fixed (byte* buffer_ptr = buffer)
                    {
                        writestream.write(writestream_ptr, (IntPtr)buffer_ptr, (UIntPtr)read);
                    }

                    totalRead += read;
                }

                if (numberOfBytesToConsume.HasValue && totalRead < numberOfBytesToConsume.Value)
                {
                    throw new EndOfStreamException("The stream ended unexpectedly");
                }
            }
            catch (Exception)
            {
                writestream.free(writestream_ptr);
                throw;
            }

            ObjectId id = Proxy.git_blob_create_fromstream_commit(writestream_ptr);
            return repo.Lookup<Blob>(id);
        }

        /// <summary>
        /// Inserts a <see cref="Blob"/> into the object database created from the content of the stream.
        /// </summary>
        /// <param name="stream">The stream from which will be read the content of the blob to be created.</param>
        /// <param name="numberOfBytesToConsume">Number of bytes to consume from the stream.</param>
        /// <returns>The created <see cref="Blob"/>.</returns>
        public virtual Blob CreateBlob(Stream stream, long numberOfBytesToConsume)
        {
            var id = Write<Blob>(stream, numberOfBytesToConsume);
            return repo.Lookup<Blob>(id);
        }

        /// <summary>
        /// Inserts a <see cref="Tree"/> into the object database, created from a <see cref="TreeDefinition"/>.
        /// </summary>
        /// <param name="treeDefinition">The <see cref="TreeDefinition"/>.</param>
        /// <returns>The created <see cref="Tree"/>.</returns>
        public virtual Tree CreateTree(TreeDefinition treeDefinition)
        {
            Ensure.ArgumentNotNull(treeDefinition, "treeDefinition");

            return treeDefinition.Build(repo);
        }

        /// <summary>
        /// Inserts a <see cref="Tree"/> into the object database, created from the <see cref="Index"/>.
        /// <para>
        ///   It recursively creates tree objects for each of the subtrees stored in the index, but only returns the root tree.
        /// </para>
        /// <para>
        ///   The index must be fully merged.
        /// </para>
        /// </summary>
        /// <param name="index">The <see cref="Index"/>.</param>
        /// <returns>The created <see cref="Tree"/>. This can be used e.g. to create a <see cref="Commit"/>.</returns>
        public virtual Tree CreateTree(Index index)
        {
            Ensure.ArgumentNotNull(index, "index");

            var treeId = Proxy.git_index_write_tree(index.Handle);
            return this.repo.Lookup<Tree>(treeId);
        }

        /// <summary>
        /// Inserts a <see cref="Commit"/> into the object database, referencing an existing <see cref="Tree"/>.
        /// <para>
        /// Prettifing the message includes:
        /// * Removing empty lines from the beginning and end.
        /// * Removing trailing spaces from every line.
        /// * Turning multiple consecutive empty lines between paragraphs into just one empty line.
        /// * Ensuring the commit message ends with a newline.
        /// * Removing every line starting with "#".
        /// </para>
        /// </summary>
        /// <param name="author">The <see cref="Signature"/> of who made the change.</param>
        /// <param name="committer">The <see cref="Signature"/> of who added the change to the repository.</param>
        /// <param name="message">The description of why a change was made to the repository.</param>
        /// <param name="tree">The <see cref="Tree"/> of the <see cref="Commit"/> to be created.</param>
        /// <param name="parents">The parents of the <see cref="Commit"/> to be created.</param>
        /// <param name="prettifyMessage">True to prettify the message, or false to leave it as is.</param>
        /// <returns>The created <see cref="Commit"/>.</returns>
        public virtual Commit CreateCommit(Signature author, Signature committer, string message, Tree tree, IEnumerable<Commit> parents, bool prettifyMessage)
        {
            return CreateCommit(author, committer, message, tree, parents, prettifyMessage, null);
        }

        /// <summary>
        /// Inserts a <see cref="Commit"/> into the object database, referencing an existing <see cref="Tree"/>.
        /// <para>
        /// Prettifing the message includes:
        /// * Removing empty lines from the beginning and end.
        /// * Removing trailing spaces from every line.
        /// * Turning multiple consecutive empty lines between paragraphs into just one empty line.
        /// * Ensuring the commit message ends with a newline.
        /// * Removing every line starting with the <paramref name="commentChar"/>.
        /// </para>
        /// </summary>
        /// <param name="author">The <see cref="Signature"/> of who made the change.</param>
        /// <param name="committer">The <see cref="Signature"/> of who added the change to the repository.</param>
        /// <param name="message">The description of why a change was made to the repository.</param>
        /// <param name="tree">The <see cref="Tree"/> of the <see cref="Commit"/> to be created.</param>
        /// <param name="parents">The parents of the <see cref="Commit"/> to be created.</param>
        /// <param name="prettifyMessage">True to prettify the message, or false to leave it as is.</param>
        /// <param name="commentChar">When non null, lines starting with this character will be stripped if prettifyMessage is true.</param>
        /// <returns>The created <see cref="Commit"/>.</returns>
        public virtual Commit CreateCommit(Signature author, Signature committer, string message, Tree tree, IEnumerable<Commit> parents, bool prettifyMessage, char? commentChar)
        {
            Ensure.ArgumentNotNull(message, "message");
            Ensure.ArgumentDoesNotContainZeroByte(message, "message");
            Ensure.ArgumentNotNull(author, "author");
            Ensure.ArgumentNotNull(committer, "committer");
            Ensure.ArgumentNotNull(tree, "tree");
            Ensure.ArgumentNotNull(parents, "parents");

            if (prettifyMessage)
            {
                message = Proxy.git_message_prettify(message, commentChar);
            }
            GitOid[] parentIds = parents.Select(p => p.Id.Oid).ToArray();

            ObjectId commitId = Proxy.git_commit_create(repo.Handle, null, author, committer, message, tree, parentIds);

            Commit commit = repo.Lookup<Commit>(commitId);
            Ensure.GitObjectIsNotNull(commit, commitId.Sha);
            return commit;
        }

        /// <summary>
        /// Inserts a <see cref="Commit"/> into the object database after attaching the given signature.
        /// </summary>
        /// <param name="commitContent">The raw unsigned commit</param>
        /// <param name="signature">The signature data </param>
        /// <param name="field">The header field in the commit in which to store the signature</param>
        /// <returns>The created <see cref="Commit"/>.</returns>
        public virtual ObjectId CreateCommitWithSignature(string commitContent, string signature, string field)
        {
            return Proxy.git_commit_create_with_signature(repo.Handle, commitContent, signature, field);
        }

        /// <summary>
        /// Inserts a <see cref="Commit"/> into the object database after attaching the given signature.
        /// <para>
        /// This overload uses the default header field of "gpgsig"
        /// </para>
        /// </summary>
        /// <param name="commitContent">The raw unsigned commit</param>
        /// <param name="signature">The signature data </param>
        /// <returns>The created <see cref="Commit"/>.</returns>
        public virtual ObjectId CreateCommitWithSignature(string commitContent, string signature)
        {
            return Proxy.git_commit_create_with_signature(repo.Handle, commitContent, signature, null);
        }

        /// <summary>
        /// Inserts a <see cref="TagAnnotation"/> into the object database, pointing to a specific <see cref="GitObject"/>.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="target">The <see cref="GitObject"/> being pointed at.</param>
        /// <param name="tagger">The tagger.</param>
        /// <param name="message">The message.</param>
        /// <returns>The created <see cref="TagAnnotation"/>.</returns>
        public virtual TagAnnotation CreateTagAnnotation(string name, GitObject target, Signature tagger, string message)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");
            Ensure.ArgumentNotNull(message, "message");
            Ensure.ArgumentNotNull(target, "target");
            Ensure.ArgumentNotNull(tagger, "tagger");
            Ensure.ArgumentDoesNotContainZeroByte(name, "name");
            Ensure.ArgumentDoesNotContainZeroByte(message, "message");

            string prettifiedMessage = Proxy.git_message_prettify(message, null);

            ObjectId tagId = Proxy.git_tag_annotation_create(repo.Handle, name, target, tagger, prettifiedMessage);

            return repo.Lookup<TagAnnotation>(tagId);
        }

        /// <summary>
        /// Returns the merge base (best common ancestor) of the given commits
        /// and the distance between each of these commits and this base.
        /// </summary>
        /// <param name="one">The <see cref="Commit"/> being used as a reference.</param>
        /// <param name="another">The <see cref="Commit"/> being compared against <paramref name="one"/>.</param>
        /// <returns>A instance of <see cref="HistoryDivergence"/>.</returns>
        public virtual HistoryDivergence CalculateHistoryDivergence(Commit one, Commit another)
        {
            Ensure.ArgumentNotNull(one, "one");
            Ensure.ArgumentNotNull(another, "another");

            return new HistoryDivergence(repo, one, another);
        }

        /// <summary>
        /// Performs a cherry-pick of <paramref name="cherryPickCommit"/> onto <paramref name="cherryPickOnto"/> commit.
        /// </summary>
        /// <param name="cherryPickCommit">The commit to cherry-pick.</param>
        /// <param name="cherryPickOnto">The commit to cherry-pick onto.</param>
        /// <param name="mainline">Which commit to consider the parent for the diff when cherry-picking a merge commit.</param>
        /// <param name="options">The options for the merging in the cherry-pick operation.</param>
        /// <returns>A result containing a <see cref="Tree"/> if the cherry-pick was successful and a list of <see cref="Conflict"/>s if it is not.</returns>
        public virtual MergeTreeResult CherryPickCommit(Commit cherryPickCommit, Commit cherryPickOnto, int mainline, MergeTreeOptions options)
        {
            Ensure.ArgumentNotNull(cherryPickCommit, "cherryPickCommit");
            Ensure.ArgumentNotNull(cherryPickOnto, "cherryPickOnto");

            var modifiedOptions = new MergeTreeOptions();

            // We throw away the index after looking at the conflicts, so we'll never need the REUC
            // entries to be there
            modifiedOptions.SkipReuc = true;

            if (options != null)
            {
                modifiedOptions.FailOnConflict = options.FailOnConflict;
                modifiedOptions.FindRenames = options.FindRenames;
                modifiedOptions.MergeFileFavor = options.MergeFileFavor;
                modifiedOptions.RenameThreshold = options.RenameThreshold;
                modifiedOptions.TargetLimit = options.TargetLimit;
            }

            bool earlyStop;

            using (var indexHandle = CherryPickCommit(cherryPickCommit, cherryPickOnto, mainline, modifiedOptions, out earlyStop))
            {
                MergeTreeResult cherryPickResult;

                // Stopped due to FailOnConflict so there's no index or conflict list
                if (earlyStop)
                {
                    return new MergeTreeResult(new Conflict[] { });
                }

                if (Proxy.git_index_has_conflicts(indexHandle))
                {
                    List<Conflict> conflicts = new List<Conflict>();
                    Conflict conflict;
                    using (ConflictIteratorHandle iterator = Proxy.git_index_conflict_iterator_new(indexHandle))
                    {
                        while ((conflict = Proxy.git_index_conflict_next(iterator)) != null)
                        {
                            conflicts.Add(conflict);
                        }
                    }
                    cherryPickResult = new MergeTreeResult(conflicts);
                }
                else
                {
                    var treeId = Proxy.git_index_write_tree_to(indexHandle, repo.Handle);
                    cherryPickResult = new MergeTreeResult(this.repo.Lookup<Tree>(treeId));
                }

                return cherryPickResult;
            }
        }

        /// <summary>
        /// Calculates the current shortest abbreviated <see cref="ObjectId"/>
        /// string representation for a <see cref="GitObject"/>.
        /// </summary>
        /// <param name="gitObject">The <see cref="GitObject"/> which identifier should be shortened.</param>
        /// <returns>A short string representation of the <see cref="ObjectId"/>.</returns>
        public virtual string ShortenObjectId(GitObject gitObject)
        {
            var shortSha = Proxy.git_object_short_id(repo.Handle, gitObject.Id);
            return shortSha;
        }

        /// <summary>
        /// Calculates the current shortest abbreviated <see cref="ObjectId"/>
        /// string representation for a <see cref="GitObject"/>.
        /// </summary>
        /// <param name="gitObject">The <see cref="GitObject"/> which identifier should be shortened.</param>
        /// <param name="minLength">Minimum length of the shortened representation.</param>
        /// <returns>A short string representation of the <see cref="ObjectId"/>.</returns>
        public virtual string ShortenObjectId(GitObject gitObject, int minLength)
        {
            Ensure.ArgumentNotNull(gitObject, "gitObject");

            if (minLength <= 0 || minLength > ObjectId.HexSize)
            {
                throw new ArgumentOutOfRangeException("minLength",
                                                      minLength,
                                                      string.Format("Expected value should be greater than zero and less than or equal to {0}.",
                                                                    ObjectId.HexSize));
            }

            string shortSha = Proxy.git_object_short_id(repo.Handle, gitObject.Id);

            if (shortSha == null)
            {
                throw new LibGit2SharpException("Unable to abbreviate SHA-1 value for GitObject " + gitObject.Id);
            }

            if (minLength <= shortSha.Length)
            {
                return shortSha;
            }

            return gitObject.Sha.Substring(0, minLength);
        }

        /// <summary>
        /// Returns whether merging <paramref name="one"/> into <paramref name="another"/>
        /// would result in merge conflicts.
        /// </summary>
        /// <param name="one">The commit wrapping the base tree to merge into.</param>
        /// <param name="another">The commit wrapping the tree to merge into <paramref name="one"/>.</param>
        /// <returns>True if the merge does not result in a conflict, false otherwise.</returns>
        public virtual bool CanMergeWithoutConflict(Commit one, Commit another)
        {
            Ensure.ArgumentNotNull(one, "one");
            Ensure.ArgumentNotNull(another, "another");

            var opts = new MergeTreeOptions()
            {
                SkipReuc = true,
                FailOnConflict = true,
            };

            var result = repo.ObjectDatabase.MergeCommits(one, another, opts);
            return (result.Status == MergeTreeStatus.Succeeded);
        }

        /// <summary>
        /// Find the best possible merge base given two <see cref="Commit"/>s.
        /// </summary>
        /// <param name="first">The first <see cref="Commit"/>.</param>
        /// <param name="second">The second <see cref="Commit"/>.</param>
        /// <returns>The merge base or null if none found.</returns>
        public virtual Commit FindMergeBase(Commit first, Commit second)
        {
            Ensure.ArgumentNotNull(first, "first");
            Ensure.ArgumentNotNull(second, "second");

            return FindMergeBase(new[] { first, second }, MergeBaseFindingStrategy.Standard);
        }

        /// <summary>
        /// Find the best possible merge base given two or more <see cref="Commit"/> according to the <see cref="MergeBaseFindingStrategy"/>.
        /// </summary>
        /// <param name="commits">The <see cref="Commit"/>s for which to find the merge base.</param>
        /// <param name="strategy">The strategy to leverage in order to find the merge base.</param>
        /// <returns>The merge base or null if none found.</returns>
        public virtual Commit FindMergeBase(IEnumerable<Commit> commits, MergeBaseFindingStrategy strategy)
        {
            Ensure.ArgumentNotNull(commits, "commits");

            ObjectId id;
            List<GitOid> ids = new List<GitOid>(8);
            int count = 0;

            foreach (var commit in commits)
            {
                if (commit == null)
                {
                    throw new ArgumentException("Enumerable contains null at position: " + count.ToString(CultureInfo.InvariantCulture), "commits");
                }
                ids.Add(commit.Id.Oid);
                count++;
            }

            if (count < 2)
            {
                throw new ArgumentException("The enumerable must contains at least two commits.", "commits");
            }

            switch (strategy)
            {
                case MergeBaseFindingStrategy.Standard:
                    id = Proxy.git_merge_base_many(repo.Handle, ids.ToArray());
                    break;

                case MergeBaseFindingStrategy.Octopus:
                    id = Proxy.git_merge_base_octopus(repo.Handle, ids.ToArray());
                    break;

                default:
                    throw new ArgumentException("", "strategy");
            }

            return id == null ? null : repo.Lookup<Commit>(id);
        }

        /// <summary>
        /// Perform a three-way merge of two commits, looking up their
        /// commit ancestor. The returned <see cref="MergeTreeResult"/> will contain the results
        /// of the merge and can be examined for conflicts.
        /// </summary>
        /// <param name="ours">The first commit</param>
        /// <param name="theirs">The second commit</param>
        /// <param name="options">The <see cref="MergeTreeOptions"/> controlling the merge</param>
        /// <returns>The <see cref="MergeTreeResult"/> containing the merged trees and any conflicts</returns>
        public virtual MergeTreeResult MergeCommits(Commit ours, Commit theirs, MergeTreeOptions options)
        {
            Ensure.ArgumentNotNull(ours, "ours");
            Ensure.ArgumentNotNull(theirs, "theirs");

            var modifiedOptions = new MergeTreeOptions();

            // We throw away the index after looking at the conflicts, so we'll never need the REUC
            // entries to be there
            modifiedOptions.SkipReuc = true;

            if (options != null)
            {
                modifiedOptions.FailOnConflict = options.FailOnConflict;
                modifiedOptions.FindRenames = options.FindRenames;
                modifiedOptions.IgnoreWhitespaceChange = options.IgnoreWhitespaceChange;
                modifiedOptions.MergeFileFavor = options.MergeFileFavor;
                modifiedOptions.RenameThreshold = options.RenameThreshold;
                modifiedOptions.TargetLimit = options.TargetLimit;
            }

            bool earlyStop;
            using (var indexHandle = MergeCommits(ours, theirs, modifiedOptions, out earlyStop))
            {
                MergeTreeResult mergeResult;

                // Stopped due to FailOnConflict so there's no index or conflict list
                if (earlyStop)
                {
                    return new MergeTreeResult(new Conflict[] { });
                }

                if (Proxy.git_index_has_conflicts(indexHandle))
                {
                    List<Conflict> conflicts = new List<Conflict>();
                    Conflict conflict;

                    using (ConflictIteratorHandle iterator = Proxy.git_index_conflict_iterator_new(indexHandle))
                    {
                        while ((conflict = Proxy.git_index_conflict_next(iterator)) != null)
                        {
                            conflicts.Add(conflict);
                        }
                    }

                    mergeResult = new MergeTreeResult(conflicts);
                }
                else
                {
                    var treeId = Proxy.git_index_write_tree_to(indexHandle, repo.Handle);
                    mergeResult = new MergeTreeResult(this.repo.Lookup<Tree>(treeId));
                }

                return mergeResult;
            }
        }

        /// <summary>
        /// Packs all the objects in the <see cref="ObjectDatabase"/> and write a pack (.pack) and index (.idx) files for them.
        /// </summary>
        /// <param name="options">Packing options</param>
        /// This method will invoke the default action of packing all objects in an arbitrary order.
        /// <returns>Packing results</returns>
        public virtual PackBuilderResults Pack(PackBuilderOptions options)
        {
            return InternalPack(options, builder =>
            {
                foreach (GitObject obj in repo.ObjectDatabase)
                {
                    builder.Add(obj.Id);
                }
            });
        }

        /// <summary>
        /// Packs objects in the <see cref="ObjectDatabase"/> chosen by the packDelegate action
        /// and write a pack (.pack) and index (.idx) files for them
        /// </summary>
        /// <param name="options">Packing options</param>
        /// <param name="packDelegate">Packing action</param>
        /// <returns>Packing results</returns>
        public virtual PackBuilderResults Pack(PackBuilderOptions options, Action<PackBuilder> packDelegate)
        {
            return InternalPack(options, packDelegate);
        }

        /// <summary>
        /// Perform a three-way merge of two commits, looking up their
        /// commit ancestor. The returned index will contain the results
        /// of the merge and can be examined for conflicts.
        /// </summary>
        /// <param name="ours">The first tree</param>
        /// <param name="theirs">The second tree</param>
        /// <param name="options">The <see cref="MergeTreeOptions"/> controlling the merge</param>
        /// <returns>The <see cref="TransientIndex"/> containing the merged trees and any conflicts, or null if the merge stopped early due to conflicts.
        /// The index must be disposed by the caller.</returns>
        public virtual TransientIndex MergeCommitsIntoIndex(Commit ours, Commit theirs, MergeTreeOptions options)
        {
            Ensure.ArgumentNotNull(ours, "ours");
            Ensure.ArgumentNotNull(theirs, "theirs");

            options = options ?? new MergeTreeOptions();

            bool earlyStop;
            var indexHandle = MergeCommits(ours, theirs, options, out earlyStop);
            if (earlyStop)
            {
                if (indexHandle != null)
                {
                    indexHandle.Dispose();
                }
                return null;
            }
            var result = new TransientIndex(indexHandle, repo);
            return result;
        }

        /// <summary>
        /// Performs a cherry-pick of <paramref name="cherryPickCommit"/> onto <paramref name="cherryPickOnto"/> commit.
        /// </summary>
        /// <param name="cherryPickCommit">The commit to cherry-pick.</param>
        /// <param name="cherryPickOnto">The commit to cherry-pick onto.</param>
        /// <param name="mainline">Which commit to consider the parent for the diff when cherry-picking a merge commit.</param>
        /// <param name="options">The options for the merging in the cherry-pick operation.</param>
        /// <returns>The <see cref="TransientIndex"/> containing the cherry-pick result tree and any conflicts, or null if the merge stopped early due to conflicts.
        /// The index must be disposed by the caller. </returns>
        public virtual TransientIndex CherryPickCommitIntoIndex(Commit cherryPickCommit, Commit cherryPickOnto, int mainline, MergeTreeOptions options)
        {
            Ensure.ArgumentNotNull(cherryPickCommit, "cherryPickCommit");
            Ensure.ArgumentNotNull(cherryPickOnto, "cherryPickOnto");

            options = options ?? new MergeTreeOptions();

            bool earlyStop;
            var indexHandle = CherryPickCommit(cherryPickCommit, cherryPickOnto, mainline, options, out earlyStop);
            if (earlyStop)
            {
                if (indexHandle != null)
                {
                    indexHandle.Dispose();
                }
                return null;
            }
            var result = new TransientIndex(indexHandle, repo);
            return result;
        }

        /// <summary>
        /// Perform a three-way merge of two commits, looking up their
        /// commit ancestor. The returned index will contain the results
        /// of the merge and can be examined for conflicts.
        /// </summary>
        /// <param name="ours">The first tree</param>
        /// <param name="theirs">The second tree</param>
        /// <param name="options">The <see cref="MergeTreeOptions"/> controlling the merge</param>
        /// <param name="earlyStop">True if the merge stopped early due to conflicts</param>
        /// <returns>The <see cref="IndexHandle"/> containing the merged trees and any conflicts</returns>
        private IndexHandle MergeCommits(Commit ours, Commit theirs, MergeTreeOptions options, out bool earlyStop)
        {
            GitMergeFlag mergeFlags = GitMergeFlag.GIT_MERGE_NORMAL;
            if (options.SkipReuc)
            {
                mergeFlags |= GitMergeFlag.GIT_MERGE_SKIP_REUC;
            }
            if (options.FindRenames)
            {
                mergeFlags |= GitMergeFlag.GIT_MERGE_FIND_RENAMES;
            }
            if (options.FailOnConflict)
            {
                mergeFlags |= GitMergeFlag.GIT_MERGE_FAIL_ON_CONFLICT;
            }

            var mergeOptions = new GitMergeOpts
            {
                Version = 1,
                MergeFileFavorFlags = options.MergeFileFavor,
                MergeTreeFlags = mergeFlags,
                RenameThreshold = (uint)options.RenameThreshold,
                TargetLimit = (uint)options.TargetLimit,
            };
            using (var oneHandle = Proxy.git_object_lookup(repo.Handle, ours.Id, GitObjectType.Commit))
            using (var twoHandle = Proxy.git_object_lookup(repo.Handle, theirs.Id, GitObjectType.Commit))
            {
                var indexHandle = Proxy.git_merge_commits(repo.Handle, oneHandle, twoHandle, mergeOptions, out earlyStop);
                return indexHandle;
            }
        }

        /// <summary>
        /// Performs a cherry-pick of <paramref name="cherryPickCommit"/> onto <paramref name="cherryPickOnto"/> commit.
        /// </summary>
        /// <param name="cherryPickCommit">The commit to cherry-pick.</param>
        /// <param name="cherryPickOnto">The commit to cherry-pick onto.</param>
        /// <param name="mainline">Which commit to consider the parent for the diff when cherry-picking a merge commit.</param>
        /// <param name="options">The options for the merging in the cherry-pick operation.</param>
        /// <param name="earlyStop">True if the cherry-pick stopped early due to conflicts</param>
        /// <returns>The <see cref="IndexHandle"/> containing the cherry-pick result tree and any conflicts</returns>
        private IndexHandle CherryPickCommit(Commit cherryPickCommit, Commit cherryPickOnto, int mainline, MergeTreeOptions options, out bool earlyStop)
        {
            GitMergeFlag mergeFlags = GitMergeFlag.GIT_MERGE_NORMAL;
            if (options.SkipReuc)
            {
                mergeFlags |= GitMergeFlag.GIT_MERGE_SKIP_REUC;
            }
            if (options.FindRenames)
            {
                mergeFlags |= GitMergeFlag.GIT_MERGE_FIND_RENAMES;
            }
            if (options.FailOnConflict)
            {
                mergeFlags |= GitMergeFlag.GIT_MERGE_FAIL_ON_CONFLICT;
            }

            var mergeOptions = new GitMergeOpts
            {
                Version = 1,
                MergeFileFavorFlags = options.MergeFileFavor,
                MergeTreeFlags = mergeFlags,
                RenameThreshold = (uint)options.RenameThreshold,
                TargetLimit = (uint)options.TargetLimit,
            };

            using (var cherryPickOntoHandle = Proxy.git_object_lookup(repo.Handle, cherryPickOnto.Id, GitObjectType.Commit))
            using (var cherryPickCommitHandle = Proxy.git_object_lookup(repo.Handle, cherryPickCommit.Id, GitObjectType.Commit))
            {
                var indexHandle = Proxy.git_cherrypick_commit(repo.Handle, cherryPickCommitHandle, cherryPickOntoHandle, (uint)mainline, mergeOptions, out earlyStop);
                return indexHandle;
            }
        }

        /// <summary>
        /// Packs objects in the <see cref="ObjectDatabase"/> and write a pack (.pack) and index (.idx) files for them.
        /// For internal use only.
        /// </summary>
        /// <param name="options">Packing options</param>
        /// <param name="packDelegate">Packing action</param>
        /// <returns>Packing results</returns>
        private PackBuilderResults InternalPack(PackBuilderOptions options, Action<PackBuilder> packDelegate)
        {
            Ensure.ArgumentNotNull(options, "options");
            Ensure.ArgumentNotNull(packDelegate, "packDelegate");

            PackBuilderResults results = new PackBuilderResults();

            using (PackBuilder builder = new PackBuilder(repo))
            {
                // set pre-build options
                builder.SetMaximumNumberOfThreads(options.MaximumNumberOfThreads);

                // call the provided action
                packDelegate(builder);

                // writing the pack and index files
                builder.Write(options.PackDirectoryPath);

                // adding the results to the PackBuilderResults object
                results.WrittenObjectsCount = builder.WrittenObjectsCount;
            }

            return results;
        }

        /// <summary>
        /// Performs a revert of <paramref name="revertCommit"/> onto <paramref name="revertOnto"/> commit.
        /// </summary>
        /// <param name="revertCommit">The commit to revert.</param>
        /// <param name="revertOnto">The commit to revert onto.</param>
        /// <param name="mainline">Which commit to consider the parent for the diff when reverting a merge commit.</param>
        /// <param name="options">The options for the merging in the revert operation.</param>
        /// <returns>A result containing a <see cref="Tree"/> if the revert was successful and a list of <see cref="Conflict"/>s if it is not.</returns>
        public virtual MergeTreeResult RevertCommit(Commit revertCommit, Commit revertOnto, int mainline, MergeTreeOptions options)
        {
            Ensure.ArgumentNotNull(revertCommit, "revertCommit");
            Ensure.ArgumentNotNull(revertOnto, "revertOnto");

            options = options ?? new MergeTreeOptions();

            // We throw away the index after looking at the conflicts, so we'll never need the REUC
            // entries to be there
            GitMergeFlag mergeFlags = GitMergeFlag.GIT_MERGE_NORMAL | GitMergeFlag.GIT_MERGE_SKIP_REUC;
            if (options.FindRenames)
            {
                mergeFlags |= GitMergeFlag.GIT_MERGE_FIND_RENAMES;
            }
            if (options.FailOnConflict)
            {
                mergeFlags |= GitMergeFlag.GIT_MERGE_FAIL_ON_CONFLICT;
            }

            var opts = new GitMergeOpts
            {
                Version = 1,
                MergeFileFavorFlags = options.MergeFileFavor,
                MergeTreeFlags = mergeFlags,
                RenameThreshold = (uint)options.RenameThreshold,
                TargetLimit = (uint)options.TargetLimit
            };

            bool earlyStop;

            using (var revertOntoHandle = Proxy.git_object_lookup(repo.Handle, revertOnto.Id, GitObjectType.Commit))
            using (var revertCommitHandle = Proxy.git_object_lookup(repo.Handle, revertCommit.Id, GitObjectType.Commit))
            using (var indexHandle = Proxy.git_revert_commit(repo.Handle, revertCommitHandle, revertOntoHandle, (uint)mainline, opts, out earlyStop))
            {
                MergeTreeResult revertTreeResult;

                // Stopped due to FailOnConflict so there's no index or conflict list
                if (earlyStop)
                {
                    return new MergeTreeResult(new Conflict[] { });
                }

                if (Proxy.git_index_has_conflicts(indexHandle))
                {
                    List<Conflict> conflicts = new List<Conflict>();
                    Conflict conflict;
                    using (ConflictIteratorHandle iterator = Proxy.git_index_conflict_iterator_new(indexHandle))
                    {
                        while ((conflict = Proxy.git_index_conflict_next(iterator)) != null)
                        {
                            conflicts.Add(conflict);
                        }
                    }
                    revertTreeResult = new MergeTreeResult(conflicts);
                }
                else
                {
                    var treeId = Proxy.git_index_write_tree_to(indexHandle, repo.Handle);
                    revertTreeResult = new MergeTreeResult(this.repo.Lookup<Tree>(treeId));
                }

                return revertTreeResult;
            }
        }
    }

    /// <summary>
    /// Uniquely identifies a <see cref="GitObject"/>.
    /// </summary>
    public sealed class ObjectId : IEquatable<ObjectId>
    {
        private readonly GitOid oid;
        private const int rawSize = GitOid.Size;
        private readonly string sha;

        /// <summary>
        /// Size of the string-based representation of a SHA-1.
        /// </summary>
        internal const int HexSize = rawSize * 2;

        private const string hexDigits = "0123456789abcdef";
        private static readonly byte[] reverseHexDigits = BuildReverseHexDigits();
        private static readonly Func<int, byte> byteConverter = i => reverseHexDigits[i - '0'];

        private static readonly LambdaEqualityHelper<ObjectId> equalityHelper =
            new LambdaEqualityHelper<ObjectId>(x => x.Sha);

        /// <summary>
        /// Zero ObjectId
        /// </summary>
        public static ObjectId Zero = new ObjectId(new string('0', HexSize));

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectId"/> class.
        /// </summary>
        /// <param name="oid">The oid.</param>
        internal ObjectId(GitOid oid)
        {
            if (oid.Id == null || oid.Id.Length != rawSize)
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "A non null array of {0} bytes is expected.", rawSize), "oid");
            }

            this.oid = oid;
            sha = ToString(oid.Id, oid.Id.Length * 2);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectId"/> class.
        /// </summary>
        /// <param name="rawId">The byte array.</param>
        public ObjectId(byte[] rawId)
            : this(new GitOid { Id = rawId })
        {
            Ensure.ArgumentNotNull(rawId, "rawId");
            Ensure.ArgumentConformsTo(rawId, b => b.Length == rawSize, "rawId");
        }

        internal static unsafe ObjectId BuildFromPtr(IntPtr ptr)
        {
            return BuildFromPtr((git_oid*) ptr.ToPointer());
        }

        internal static unsafe ObjectId BuildFromPtr(git_oid* id)
        {
            return id == null ? null : new ObjectId(id->Id);
        }

        internal unsafe ObjectId(byte* rawId)
        {
            byte[] id = new byte[GitOid.Size];

            fixed(byte* p = id)
            {
                for (int i = 0; i < rawSize; i++)
                {
                    p[i] = rawId[i];
                }
            }

            this.oid = new GitOid { Id = id };
            this.sha = ToString(oid.Id, oid.Id.Length * 2);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectId"/> class.
        /// </summary>
        /// <param name="sha">The sha.</param>
        public ObjectId(string sha)
        {
            GitOid? parsedOid = BuildOidFrom(sha, true);

            if (!parsedOid.HasValue)
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "'{0}' is not a valid Sha-1.", sha));
            }

            oid = parsedOid.Value;
            this.sha = sha;
        }

        internal GitOid Oid
        {
            get { return oid; }
        }

        /// <summary>
        /// Gets the raw id.
        /// </summary>
        public byte[] RawId
        {
            get { return oid.Id; }
        }

        /// <summary>
        /// Gets the sha.
        /// </summary>
        public string Sha
        {
            get { return sha; }
        }

        /// <summary>
        /// Converts the specified string representation of a Sha-1 to its <see cref="ObjectId"/> equivalent and returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="sha">A string containing a Sha-1 to convert.</param>
        /// <param name="result">When this method returns, contains the <see cref="ObjectId"/> value equivalent to the Sha-1 contained in <paramref name="sha"/>, if the conversion succeeded, or <code>null</code> if the conversion failed.</param>
        /// <returns>true if the <paramref name="sha"/> parameter was converted successfully; otherwise, false.</returns>
        public static bool TryParse(string sha, out ObjectId result)
        {
            result = BuildOidFrom(sha, false);

            return result != null;
        }

        private static GitOid? BuildOidFrom(string sha, bool shouldThrowIfInvalid)
        {
            if (!LooksValid(sha, shouldThrowIfInvalid))
            {
                return null;
            }

            return ToOid(sha);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="ObjectId"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="ObjectId"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="ObjectId"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as ObjectId);
        }

        /// <summary>
        /// Determines whether the specified <see cref="ObjectId"/> is equal to the current <see cref="ObjectId"/>.
        /// </summary>
        /// <param name="other">The <see cref="ObjectId"/> to compare with the current <see cref="ObjectId"/>.</param>
        /// <returns>True if the specified <see cref="ObjectId"/> is equal to the current <see cref="ObjectId"/>; otherwise, false.</returns>
        public bool Equals(ObjectId other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Returns the <see cref="Sha"/>, a <see cref="String"/> representation of the current <see cref="ObjectId"/>.
        /// </summary>
        /// <returns>The <see cref="Sha"/> that represents the current <see cref="ObjectId"/>.</returns>
        public override string ToString()
        {
            return Sha;
        }

        /// <summary>
        /// Returns the <see cref="Sha"/>, a <see cref="String"/> representation of the current <see cref="ObjectId"/>.
        /// </summary>
        /// <param name="prefixLength">The number of chars the <see cref="Sha"/> should be truncated to.</param>
        /// <returns>The <see cref="Sha"/> that represents the current <see cref="ObjectId"/>.</returns>
        public string ToString(int prefixLength)
        {
            int normalizedLength = NormalizeLength(prefixLength);
            return Sha.Substring(0, Math.Min(Sha.Length, normalizedLength));
        }

        private static int NormalizeLength(int prefixLength)
        {
            if (prefixLength < 1)
            {
                return 1;
            }

            if (prefixLength > HexSize)
            {
                return HexSize;
            }

            return prefixLength;
        }

        /// <summary>
        /// Tests if two <see cref="ObjectId"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="ObjectId"/> to compare.</param>
        /// <param name="right">Second <see cref="ObjectId"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(ObjectId left, ObjectId right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="ObjectId"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="ObjectId"/> to compare.</param>
        /// <param name="right">Second <see cref="ObjectId"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(ObjectId left, ObjectId right)
        {
            return !Equals(left, right);
        }

        /// <summary>
        /// Create an <see cref="ObjectId"/> for the given <paramref name="sha"/>.
        /// </summary>
        /// <param name="sha">The object SHA.</param>
        /// <returns>An <see cref="ObjectId"/>, or null if <paramref name="sha"/> is null.</returns>
        public static explicit operator ObjectId(string sha)
        {
            return sha == null ? null : new ObjectId(sha);
        }

        private static byte[] BuildReverseHexDigits()
        {
            var bytes = new byte['f' - '0' + 1];

            for (int i = 0; i < 10; i++)
            {
                bytes[i] = (byte)i;
            }

            for (int i = 10; i < 16; i++)
            {
                bytes[i + 'a' - '0' - 0x0a] = (byte)(i);
            }

            return bytes;
        }

        internal static string ToString(byte[] id, int lengthInNibbles)
        {
            // Inspired from http://stackoverflow.com/questions/623104/c-byte-to-hex-string/3974535#3974535

            var c = new char[lengthInNibbles];

            for (int i = 0; i < (lengthInNibbles & -2); i++)
            {
                int index0 = i >> 1;
                var b = ((byte)(id[index0] >> 4));
                c[i++] = hexDigits[b];

                b = ((byte)(id[index0] & 0x0F));
                c[i] = hexDigits[b];
            }

            if ((lengthInNibbles & 1) == 1)
            {
                int index0 = lengthInNibbles >> 1;
                var b = ((byte)(id[index0] >> 4));
                c[lengthInNibbles - 1] = hexDigits[b];
            }

            return new string(c);
        }

        private static GitOid ToOid(string sha)
        {
            var bytes = new byte[rawSize];

            if ((sha.Length & 1) == 1)
            {
                sha += "0";
            }

            for (int i = 0; i < sha.Length; i++)
            {
                int c1 = byteConverter(sha[i++]) << 4;
                int c2 = byteConverter(sha[i]);

                bytes[i >> 1] = (byte)(c1 + c2);
            }

            var oid = new GitOid { Id = bytes };
            return oid;
        }

        private static bool LooksValid(string objectId, bool throwIfInvalid)
        {
            if (string.IsNullOrEmpty(objectId))
            {
                if (!throwIfInvalid)
                {
                    return false;
                }

                Ensure.ArgumentNotNullOrEmptyString(objectId, "objectId");
            }

            if ((objectId.Length != HexSize))
            {
                if (!throwIfInvalid)
                {
                    return false;
                }

                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture,
                                                          "'{0}' is not a valid object identifier. Its length should be {1}.",
                                                          objectId,
                                                          HexSize),
                                            "objectId");
            }

            return objectId.All(c => hexDigits.IndexOf(c) >= 0);
        }

        /// <summary>
        /// Determine whether <paramref name="shortSha"/> matches the hexified
        /// representation of the first nibbles of this instance.
        /// <para>
        ///   Comparison is made in a case insensitive-manner.
        /// </para>
        /// </summary>
        /// <returns>True if this instance starts with <paramref name="shortSha"/>,
        /// false otherwise.</returns>
        public bool StartsWith(string shortSha)
        {
            Ensure.ArgumentNotNullOrEmptyString(shortSha, "shortSha");

            return Sha.StartsWith(shortSha, StringComparison.OrdinalIgnoreCase);
        }
    }

    /// <summary>
    /// Underlying type of a <see cref="GitObject"/>
    /// </summary>
    public enum ObjectType
    {
        /// <summary>
        /// A commit object.
        /// </summary>
        Commit = 1,

        /// <summary>
        /// A tree (directory listing) object.
        /// </summary>
        Tree = 2,

        /// <summary>
        /// A file revision object.
        /// </summary>
        Blob = 3,

        /// <summary>
        /// An annotated tag object.
        /// </summary>
        Tag = 4,
    }

    internal static class ObjectTypeExtensions
    {
        public static GitObjectType ToGitObjectType(this ObjectType type)
        {
            switch (type)
            {
                case ObjectType.Commit:
                    return GitObjectType.Commit;

                case ObjectType.Tree:
                    return GitObjectType.Tree;

                case ObjectType.Blob:
                    return GitObjectType.Blob;

                case ObjectType.Tag:
                    return GitObjectType.Tag;

                default:
                    throw new InvalidOperationException(
                        string.Format(CultureInfo.InvariantCulture, "Cannot map {0} to a GitObjectType.", type));
            }
        }
    }

    /// <summary>
    /// Base class for all custom managed backends for the libgit2 object database (ODB).
    /// <para>
    /// If the derived backend implements <see cref="IDisposable"/>, the <see cref="IDisposable.Dispose"/>
    /// method will be honored and invoked upon the disposal of the repository.
    /// </para>
    /// </summary>
    public abstract class OdbBackend
    {
        /// <summary>
        /// Invoked by libgit2 when this backend is no longer needed.
        /// </summary>
        internal void Free()
        {
            if (nativeBackendPointer == IntPtr.Zero)
            {
                return;
            }

            GCHandle.FromIntPtr(Marshal.ReadIntPtr(nativeBackendPointer, GitOdbBackend.GCHandleOffset)).Free();
            Marshal.FreeHGlobal(nativeBackendPointer);
            nativeBackendPointer = IntPtr.Zero;
        }

        /// <summary>
        /// In your subclass, override this member to provide the list of actions your backend supports.
        /// </summary>
        protected abstract OdbBackendOperations SupportedOperations { get; }

        /// <summary>
        /// Call this method from your implementations of Read and ReadPrefix to allocate a buffer in
        /// which to return the object's data.
        /// </summary>
        /// <param name="bytes">The bytes to be copied to the stream.</param>
        /// <returns>
        /// A Stream already filled with the content of provided the byte array.
        /// Do not dispose this object before returning it.
        /// </returns>
        protected UnmanagedMemoryStream AllocateAndBuildFrom(byte[] bytes)
        {
            var stream = Allocate(bytes.Length);

            stream.Write(bytes, 0, bytes.Length);

            return stream;
        }

        /// <summary>
        /// Call this method from your implementations of Read and ReadPrefix to allocate a buffer in
        /// which to return the object's data.
        /// </summary>
        /// <param name="size">Number of bytes to allocate</param>
        /// <returns>A Stream for you to write to and then return. Do not dispose this object before returning it.</returns>
        protected unsafe UnmanagedMemoryStream Allocate(long size)
        {
            if (size < 0 || (UIntPtr.Size == sizeof(int) && size > int.MaxValue))
            {
                throw new ArgumentOutOfRangeException("size");
            }

            IntPtr buffer = Proxy.git_odb_backend_data_alloc(this.GitOdbBackendPointer, new UIntPtr((ulong)size));

            return new UnmanagedMemoryStream((byte*)buffer, 0, size, FileAccess.ReadWrite);
        }

        /// <summary>
        /// Requests that this backend read an object.
        /// </summary>
        public abstract int Read(
            ObjectId id,
            out UnmanagedMemoryStream data,
            out ObjectType objectType);

        /// <summary>
        /// Requests that this backend read an object. The object ID may not be complete (may be a prefix).
        /// </summary>
        public abstract int ReadPrefix(
            string shortSha,
            out ObjectId oid,
            out UnmanagedMemoryStream data,
            out ObjectType objectType);

        /// <summary>
        /// Requests that this backend read an object's header (length and object type) but not its contents.
        /// </summary>
        public abstract int ReadHeader(
            ObjectId id,
            out int length,
            out ObjectType objectType);

        /// <summary>
        /// Requests that this backend write an object to the backing store.
        /// </summary>
        public abstract int Write(
            ObjectId id,
            Stream dataStream,
            long length,
            ObjectType objectType);

        /// <summary>
        /// Requests that this backend read an object. Returns a stream so that the caller can read the data in chunks.
        /// </summary>
        public abstract int ReadStream(
            ObjectId id,
            out OdbBackendStream stream);

        /// <summary>
        /// Requests that this backend write an object to the backing store. Returns a stream so that the caller can write
        /// the data in chunks.
        /// </summary>
        public abstract int WriteStream(
            long length,
            ObjectType objectType,
            out OdbBackendStream stream);

        /// <summary>
        /// Requests that this backend check if an object ID exists.
        /// </summary>
        public abstract bool Exists(ObjectId id);

        /// <summary>
        /// Requests that this backend check if an object ID exists. The object ID may not be complete (may be a prefix).
        /// </summary>
        public abstract int ExistsPrefix(string shortSha, out ObjectId found);

        /// <summary>
        /// Requests that this backend enumerate all items in the backing store.
        /// </summary>
        public abstract int ForEach(ForEachCallback callback);

        /// <summary>
        /// The signature of the callback method provided to the Foreach method.
        /// </summary>
        /// <param name="oid">The object ID of the object in the backing store.</param>
        /// <returns>A non-negative result indicates the enumeration should continue. Otherwise, the enumeration should stop.</returns>
        public delegate int ForEachCallback(ObjectId oid);

        private IntPtr nativeBackendPointer;

        internal IntPtr GitOdbBackendPointer
        {
            get
            {
                if (IntPtr.Zero == nativeBackendPointer)
                {
                    var nativeBackend = new GitOdbBackend();
                    nativeBackend.Version = 1;

                    // The "free" entry point is always provided.
                    nativeBackend.Free = BackendEntryPoints.FreeCallback;

                    var supportedOperations = this.SupportedOperations;

                    if ((supportedOperations & OdbBackendOperations.Read) != 0)
                    {
                        nativeBackend.Read = BackendEntryPoints.ReadCallback;
                    }

                    if ((supportedOperations & OdbBackendOperations.ReadPrefix) != 0)
                    {
                        nativeBackend.ReadPrefix = BackendEntryPoints.ReadPrefixCallback;
                    }

                    if ((supportedOperations & OdbBackendOperations.ReadHeader) != 0)
                    {
                        nativeBackend.ReadHeader = BackendEntryPoints.ReadHeaderCallback;
                    }

                    if ((supportedOperations & OdbBackendOperations.ReadStream) != 0)
                    {
                        nativeBackend.ReadStream = BackendEntryPoints.ReadStreamCallback;
                    }

                    if ((supportedOperations & OdbBackendOperations.Write) != 0)
                    {
                        nativeBackend.Write = BackendEntryPoints.WriteCallback;
                    }

                    if ((supportedOperations & OdbBackendOperations.WriteStream) != 0)
                    {
                        nativeBackend.WriteStream = BackendEntryPoints.WriteStreamCallback;
                    }

                    if ((supportedOperations & OdbBackendOperations.Exists) != 0)
                    {
                        nativeBackend.Exists = BackendEntryPoints.ExistsCallback;
                    }

                    if ((supportedOperations & OdbBackendOperations.ExistsPrefix) != 0)
                    {
                        nativeBackend.ExistsPrefix = BackendEntryPoints.ExistsPrefixCallback;
                    }

                    if ((supportedOperations & OdbBackendOperations.ForEach) != 0)
                    {
                        nativeBackend.Foreach = BackendEntryPoints.ForEachCallback;
                    }

                    nativeBackend.GCHandle = GCHandle.ToIntPtr(GCHandle.Alloc(this));
                    nativeBackendPointer = Marshal.AllocHGlobal(Marshal.SizeOf(nativeBackend));
                    Marshal.StructureToPtr(nativeBackend, nativeBackendPointer, false);
                }

                return nativeBackendPointer;
            }
        }

        private static class BackendEntryPoints
        {
            // Because our GitOdbBackend structure exists on the managed heap only for a short time (to be marshaled
            // to native memory with StructureToPtr), we need to bind to static delegates. If at construction time
            // we were to bind to the methods directly, that's the same as newing up a fresh delegate every time.
            // Those delegates won't be rooted in the object graph and can be collected as soon as StructureToPtr finishes.
            public static readonly GitOdbBackend.read_callback ReadCallback = Read;
            public static readonly GitOdbBackend.read_prefix_callback ReadPrefixCallback = ReadPrefix;
            public static readonly GitOdbBackend.read_header_callback ReadHeaderCallback = ReadHeader;
            public static readonly GitOdbBackend.readstream_callback ReadStreamCallback = ReadStream;
            public static readonly GitOdbBackend.write_callback WriteCallback = Write;
            public static readonly GitOdbBackend.writestream_callback WriteStreamCallback = WriteStream;
            public static readonly GitOdbBackend.exists_callback ExistsCallback = Exists;
            public static readonly GitOdbBackend.exists_prefix_callback ExistsPrefixCallback = ExistsPrefix;
            public static readonly GitOdbBackend.foreach_callback ForEachCallback = Foreach;
            public static readonly GitOdbBackend.free_callback FreeCallback = Free;

            private static OdbBackend MarshalOdbBackend(IntPtr backendPtr)
            {

                var intPtr = Marshal.ReadIntPtr(backendPtr, GitOdbBackend.GCHandleOffset);
                var odbBackend = GCHandle.FromIntPtr(intPtr).Target as OdbBackend;

                if (odbBackend == null)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Reference, "Cannot retrieve the managed OdbBackend.");
                    return null;
                }

                return odbBackend;
            }

            private unsafe static int Read(
                out IntPtr buffer_p,
                out UIntPtr len_p,
                out GitObjectType type_p,
                IntPtr backend,
                ref GitOid oid)
            {
                buffer_p = IntPtr.Zero;
                len_p = UIntPtr.Zero;
                type_p = GitObjectType.Bad;

                OdbBackend odbBackend = MarshalOdbBackend(backend);
                if (odbBackend == null)
                {
                    return (int)GitErrorCode.Error;
                }

                UnmanagedMemoryStream memoryStream = null;

                try
                {
                    ObjectType objectType;
                    int toReturn = odbBackend.Read(new ObjectId(oid), out memoryStream, out objectType);

                    if (toReturn != 0)
                    {
                        return toReturn;
                    }

                    if (memoryStream == null)
                    {
                        return (int)GitErrorCode.Error;
                    }

                    len_p = new UIntPtr((ulong)memoryStream.Capacity);
                    type_p = objectType.ToGitObjectType();

                    memoryStream.Seek(0, SeekOrigin.Begin);
                    buffer_p = new IntPtr(memoryStream.PositionPointer);

                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                    return (int)GitErrorCode.Error;
                }
                finally
                {
                    if (memoryStream != null)
                    {
                        memoryStream.Dispose();
                    }
                }

                return (int)GitErrorCode.Ok;
            }

            private unsafe static int ReadPrefix(
                out GitOid out_oid,
                out IntPtr buffer_p,
                out UIntPtr len_p,
                out GitObjectType type_p,
                IntPtr backend,
                ref GitOid short_oid,
                UIntPtr len)
            {
                out_oid = default(GitOid);
                buffer_p = IntPtr.Zero;
                len_p = UIntPtr.Zero;
                type_p = GitObjectType.Bad;

                OdbBackend odbBackend = MarshalOdbBackend(backend);
                if (odbBackend == null)
                {
                    return (int)GitErrorCode.Error;
                }

                UnmanagedMemoryStream memoryStream = null;

                try
                {
                    var shortSha = ObjectId.ToString(short_oid.Id, (int)len);

                    ObjectId oid;
                    ObjectType objectType;

                    int toReturn = odbBackend.ReadPrefix(shortSha, out oid, out memoryStream, out objectType);

                    if (toReturn != 0)
                    {
                        return toReturn;
                    }

                    if (memoryStream == null)
                    {
                        return (int)GitErrorCode.Error;
                    }

                    out_oid.Id = oid.RawId;
                    len_p = new UIntPtr((ulong)memoryStream.Capacity);
                    type_p = objectType.ToGitObjectType();

                    memoryStream.Seek(0, SeekOrigin.Begin);
                    buffer_p = new IntPtr(memoryStream.PositionPointer);
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                    return (int)GitErrorCode.Error;
                }
                finally
                {
                    if (memoryStream != null)
                    {
                        memoryStream.Dispose();
                    }
                }

                return (int)GitErrorCode.Ok;
            }

            private static int ReadHeader(
                out UIntPtr len_p,
                out GitObjectType type_p,
                IntPtr backend,
                ref GitOid oid)
            {
                len_p = UIntPtr.Zero;
                type_p = GitObjectType.Bad;

                OdbBackend odbBackend = MarshalOdbBackend(backend);
                if (odbBackend == null)
                {
                    return (int)GitErrorCode.Error;
                }

                try
                {
                    int length;
                    ObjectType objectType;
                    int toReturn = odbBackend.ReadHeader(new ObjectId(oid), out length, out objectType);

                    if (toReturn != 0)
                    {
                        return toReturn;
                    }

                    len_p = new UIntPtr((uint)length);
                    type_p = objectType.ToGitObjectType();
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                    return (int)GitErrorCode.Error;
                }

                return (int)GitErrorCode.Ok;
            }

            private static unsafe int Write(
                IntPtr backend,
                ref GitOid oid,
                IntPtr data,
                UIntPtr len,
                GitObjectType type)
            {
                long length = ConverToLong(len);

                OdbBackend odbBackend = MarshalOdbBackend(backend);
                if (odbBackend == null)
                {
                    return (int)GitErrorCode.Error;
                }

                try
                {
                    using (var stream = new UnmanagedMemoryStream((byte*)data, length))
                    {
                        return odbBackend.Write(new ObjectId(oid), stream, length, type.ToObjectType());
                    }
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                    return (int)GitErrorCode.Error;
                }
            }

            private static int WriteStream(
                out IntPtr stream_out,
                IntPtr backend,
                long len,
                GitObjectType type)
            {
                stream_out = IntPtr.Zero;

                OdbBackend odbBackend = MarshalOdbBackend(backend);
                if (odbBackend == null)
                {
                    return (int)GitErrorCode.Error;
                }

                ObjectType objectType = type.ToObjectType();

                try
                {
                    OdbBackendStream stream;
                    int toReturn = odbBackend.WriteStream(len, objectType, out stream);

                    if (toReturn == 0)
                    {
                        stream_out = stream.GitOdbBackendStreamPointer;
                    }

                    return toReturn;
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                    return (int)GitErrorCode.Error;
                }
            }

            private static int ReadStream(
                out IntPtr stream_out,
                IntPtr backend,
                ref GitOid oid)
            {
                stream_out = IntPtr.Zero;

                OdbBackend odbBackend = MarshalOdbBackend(backend);
                if (odbBackend == null)
                {
                    return (int)GitErrorCode.Error;
                }

                try
                {
                    OdbBackendStream stream;
                    int toReturn = odbBackend.ReadStream(new ObjectId(oid), out stream);

                    if (toReturn == 0)
                    {
                        stream_out = stream.GitOdbBackendStreamPointer;
                    }

                    return toReturn;
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                    return (int)GitErrorCode.Error;
                }
            }

            private static bool Exists(
                IntPtr backend,
                ref GitOid oid)
            {
                OdbBackend odbBackend = MarshalOdbBackend(backend);
                if (odbBackend == null)
                {
                    return false; // Weird
                }

                try
                {
                    return odbBackend.Exists(new ObjectId(oid));
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                    return false;
                }
            }

            private static int ExistsPrefix(
                ref GitOid found_oid,
                IntPtr backend,
                ref GitOid short_oid,
                UIntPtr len)
            {
                OdbBackend odbBackend = MarshalOdbBackend(backend);
                if (odbBackend == null)
                {
                    return (int)GitErrorCode.Error;
                }

                try
                {
                    ObjectId found;
                    var shortSha = ObjectId.ToString(short_oid.Id, (int)len);

                    found_oid.Id = ObjectId.Zero.RawId;
                    int result = odbBackend.ExistsPrefix(shortSha, out found);

                    if (result == (int)GitErrorCode.Ok)
                    {
                        found_oid.Id = found.RawId;
                    }

                    return result;
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                    return (int)GitErrorCode.Error;
                }
            }

            private static int Foreach(
                IntPtr backend,
                GitOdbBackend.foreach_callback_callback cb,
                IntPtr data)
            {
                OdbBackend odbBackend = MarshalOdbBackend(backend);
                if (odbBackend == null)
                {
                    return (int)GitErrorCode.Error;
                }

                try
                {
                    return odbBackend.ForEach(new ForeachState(cb, data).ManagedCallback);
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                    return (int)GitErrorCode.Error;
                }
            }

            private static void Free(
                IntPtr backend)
            {
                OdbBackend odbBackend = MarshalOdbBackend(backend);
                if (odbBackend == null)
                {
                    return;
                }

                try
                {
                    odbBackend.Free();

                    var disposable = odbBackend as IDisposable;

                    if (disposable == null)
                    {
                        return;
                    }

                    disposable.Dispose();
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                }
            }

            private class ForeachState
            {
                public ForeachState(GitOdbBackend.foreach_callback_callback cb, IntPtr data)
                {
                    this.cb = cb;
                    this.data = data;
                    this.ManagedCallback = CallbackMethod;
                }

                private unsafe int CallbackMethod(ObjectId id)
                {
                    var oid = id.RawId;

                    fixed (void* ptr = &oid[0])
                    {
                        return cb(new IntPtr(ptr), data);
                    }
                }

                public readonly ForEachCallback ManagedCallback;

                private readonly GitOdbBackend.foreach_callback_callback cb;
                private readonly IntPtr data;
            }
        }

        internal static long ConverToLong(UIntPtr len)
        {
            if (len.ToUInt64() > long.MaxValue)
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture,
                                                                  "Provided length ({0}) exceeds long.MaxValue ({1}).",
                                                                  len.ToUInt64(),
                                                                  long.MaxValue));
            }

            return (long)len.ToUInt64();
        }

        /// <summary>
        /// Flags used by subclasses of OdbBackend to indicate which operations they support.
        /// </summary>
        [Flags]
        protected enum OdbBackendOperations
        {
            /// <summary>
            /// This OdbBackend declares that it supports the Read method.
            /// </summary>
            Read = 1,

            /// <summary>
            /// This OdbBackend declares that it supports the ReadPrefix method.
            /// </summary>
            ReadPrefix = 2,

            /// <summary>
            /// This OdbBackend declares that it supports the ReadHeader method.
            /// </summary>
            ReadHeader = 4,

            /// <summary>
            /// This OdbBackend declares that it supports the Write method.
            /// </summary>
            Write = 8,

            /// <summary>
            /// This OdbBackend declares that it supports the ReadStream method.
            /// </summary>
            ReadStream = 16,

            /// <summary>
            /// This OdbBackend declares that it supports the WriteStream method.
            /// </summary>
            WriteStream = 32,

            /// <summary>
            /// This OdbBackend declares that it supports the Exists method.
            /// </summary>
            Exists = 64,

            /// <summary>
            /// This OdbBackend declares that it supports the ExistsPrefix method.
            /// </summary>
            ExistsPrefix = 128,

            /// <summary>
            /// This OdbBackend declares that it supports the Foreach method.
            /// </summary>
            ForEach = 256,
        }

        /// <summary>
        /// Libgit2 expected backend return codes.
        /// </summary>
        protected enum ReturnCode
        {
            /// <summary>
            /// No error has occured.
            /// </summary>
            GIT_OK = 0,

            /// <summary>
            /// No object matching the oid, or short oid, can be found in the backend.
            /// </summary>
            GIT_ENOTFOUND = -3,

            /// <summary>
            /// The given short oid is ambiguous.
            /// </summary>
            GIT_EAMBIGUOUS = -5,

            /// <summary>
            /// Interruption of the foreach() callback is requested.
            /// </summary>
            GIT_EUSER = -7,
        }
    }

    /// <summary>
    /// When an OdbBackend implements the WriteStream or ReadStream methods, it returns an OdbBackendStream to libgit2.
    /// Libgit2 then uses the OdbBackendStream to read or write from the backend in a streaming fashion.
    /// </summary>
    public abstract class OdbBackendStream
    {
        /// <summary>
        /// This is to quiet the MetaFixture.TypesInLibGit2SharpMustBeExtensibleInATestingContext test.
        /// Do not use this constructor.
        /// </summary>
        protected internal OdbBackendStream()
        {
            throw new InvalidOperationException();
        }

        /// <summary>
        /// Base constructor for OdbBackendStream. Make sure that your derived class calls this base constructor.
        /// </summary>
        /// <param name="backend">The backend to which this backend stream is attached.</param>
        protected OdbBackendStream(OdbBackend backend)
        {
            this.backend = backend;
        }

        /// <summary>
        /// Invoked by libgit2 when this stream is no longer needed.
        /// </summary>
        protected virtual void Dispose()
        {
            if (IntPtr.Zero != nativeBackendStreamPointer)
            {
                GCHandle.FromIntPtr(Marshal.ReadIntPtr(nativeBackendStreamPointer, GitOdbBackendStream.GCHandleOffset)).Free();
                Marshal.FreeHGlobal(nativeBackendStreamPointer);
                nativeBackendStreamPointer = IntPtr.Zero;
            }
        }

        /// <summary>
        /// If true, then it is legal to call the Read method.
        /// </summary>
        public abstract bool CanRead { get; }

        /// <summary>
        /// If true, then it is legal to call the Write and FinalizeWrite methods.
        /// </summary>
        public abstract bool CanWrite { get; }

        /// <summary>
        /// Requests that the stream write the next length bytes of the stream to the provided Stream object.
        /// </summary>
        public abstract int Read(Stream dataStream, long length);

        /// <summary>
        /// Requests that the stream write the first length bytes of the provided Stream object to the stream.
        /// </summary>
        public abstract int Write(Stream dataStream, long length);

        /// <summary>
        /// After all bytes have been written to the stream, the object ID is provided to FinalizeWrite.
        /// </summary>
        public abstract int FinalizeWrite(ObjectId id);

        /// <summary>
        /// The backend object this stream was created by.
        /// </summary>
        public virtual OdbBackend Backend
        {
            get { return this.backend; }
        }

        private readonly OdbBackend backend;
        private IntPtr nativeBackendStreamPointer;

        internal IntPtr GitOdbBackendStreamPointer
        {
            get
            {
                if (IntPtr.Zero == nativeBackendStreamPointer)
                {
                    var nativeBackendStream = new GitOdbBackendStream();

                    nativeBackendStream.Backend = this.backend.GitOdbBackendPointer;
                    nativeBackendStream.Free = BackendStreamEntryPoints.FreeCallback;

                    if (CanRead)
                    {
                        nativeBackendStream.Read = BackendStreamEntryPoints.ReadCallback;

                        nativeBackendStream.Mode |= GitOdbBackendStreamMode.Read;
                    }

                    if (CanWrite)
                    {
                        nativeBackendStream.Write = BackendStreamEntryPoints.WriteCallback;
                        nativeBackendStream.FinalizeWrite = BackendStreamEntryPoints.FinalizeWriteCallback;

                        nativeBackendStream.Mode |= GitOdbBackendStreamMode.Write;
                    }

                    nativeBackendStream.GCHandle = GCHandle.ToIntPtr(GCHandle.Alloc(this));
                    nativeBackendStreamPointer = Marshal.AllocHGlobal(Marshal.SizeOf(nativeBackendStream));
                    Marshal.StructureToPtr(nativeBackendStream, nativeBackendStreamPointer, false);
                }

                return nativeBackendStreamPointer;
            }
        }

        private static class BackendStreamEntryPoints
        {
            // Because our GitOdbBackendStream structure exists on the managed heap only for a short time (to be marshaled
            // to native memory with StructureToPtr), we need to bind to static delegates. If at construction time
            // we were to bind to the methods directly, that's the same as newing up a fresh delegate every time.
            // Those delegates won't be rooted in the object graph and can be collected as soon as StructureToPtr finishes.
            public static readonly GitOdbBackendStream.read_callback ReadCallback = Read;
            public static readonly GitOdbBackendStream.write_callback WriteCallback = Write;
            public static readonly GitOdbBackendStream.finalize_write_callback FinalizeWriteCallback = FinalizeWrite;
            public static readonly GitOdbBackendStream.free_callback FreeCallback = Free;

            private unsafe static int Read(IntPtr stream, IntPtr buffer, UIntPtr len)
            {
                OdbBackendStream odbBackendStream = GCHandle.FromIntPtr(Marshal.ReadIntPtr(stream, GitOdbBackendStream.GCHandleOffset)).Target as OdbBackendStream;

                if (odbBackendStream != null)
                {
                    long length = OdbBackend.ConverToLong(len);

                    using (UnmanagedMemoryStream memoryStream = new UnmanagedMemoryStream((byte*)buffer, 0, length, FileAccess.ReadWrite))
                    {
                        try
                        {
                            return odbBackendStream.Read(memoryStream, length);
                        }
                        catch (Exception ex)
                        {
                            Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                        }
                    }
                }

                return (int)GitErrorCode.Error;
            }

            private static unsafe int Write(IntPtr stream, IntPtr buffer, UIntPtr len)
            {
                OdbBackendStream odbBackendStream = GCHandle.FromIntPtr(Marshal.ReadIntPtr(stream, GitOdbBackendStream.GCHandleOffset)).Target as OdbBackendStream;

                if (odbBackendStream != null)
                {
                    long length = OdbBackend.ConverToLong(len);

                    using (UnmanagedMemoryStream dataStream = new UnmanagedMemoryStream((byte*)buffer, length))
                    {
                        try
                        {
                            return odbBackendStream.Write(dataStream, length);
                        }
                        catch (Exception ex)
                        {
                            Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                        }
                    }
                }

                return (int)GitErrorCode.Error;
            }

            private static int FinalizeWrite(IntPtr stream, ref GitOid oid)
            {
                OdbBackendStream odbBackendStream = GCHandle.FromIntPtr(Marshal.ReadIntPtr(stream, GitOdbBackendStream.GCHandleOffset)).Target as OdbBackendStream;

                if (odbBackendStream != null)
                {
                    try
                    {
                        return odbBackendStream.FinalizeWrite(new ObjectId(oid));
                    }
                    catch (Exception ex)
                    {
                        Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                    }
                }

                return (int)GitErrorCode.Error;
            }

            private static void Free(IntPtr stream)
            {
                OdbBackendStream odbBackendStream = GCHandle.FromIntPtr(Marshal.ReadIntPtr(stream, GitOdbBackendStream.GCHandleOffset)).Target as OdbBackendStream;

                if (odbBackendStream != null)
                {
                    try
                    {
                        odbBackendStream.Dispose();
                    }
                    catch (Exception ex)
                    {
                        Proxy.git_error_set_str(GitErrorCategory.Odb, ex);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Representation of a git PackBuilder.
    /// </summary>
    public sealed class PackBuilder : IDisposable
    {
        private readonly PackBuilderHandle packBuilderHandle;

        /// <summary>
        /// Constructs a PackBuilder for a <see cref="Repository"/>.
        /// </summary>
        internal PackBuilder(Repository repository)
        {
            Ensure.ArgumentNotNull(repository, "repository");

            packBuilderHandle = Proxy.git_packbuilder_new(repository.Handle);
        }

        /// <summary>
        /// Inserts a single <see cref="GitObject"/> to the PackBuilder.
        /// For an optimal pack it's mandatory to insert objects in recency order, commits followed by trees and blobs. (quoted from libgit2 API ref)
        /// </summary>
        /// <param name="gitObject">The object to be inserted.</param>
        /// <exception cref="ArgumentNullException">if the gitObject is null</exception>
        public void Add<T>(T gitObject) where T : GitObject
        {
            Ensure.ArgumentNotNull(gitObject, "gitObject");

            Add(gitObject.Id);
        }

        /// <summary>
        /// Recursively inserts a <see cref="GitObject"/> and its referenced objects.
        /// Inserts the object as well as any object it references.
        /// </summary>
        /// <param name="gitObject">The object to be inserted recursively.</param>
        /// <exception cref="ArgumentNullException">if the gitObject is null</exception>
        public void AddRecursively<T>(T gitObject) where T : GitObject
        {
            Ensure.ArgumentNotNull(gitObject, "gitObject");

            AddRecursively(gitObject.Id);
        }

        /// <summary>
        /// Inserts a single object to the PackBuilder by its <see cref="ObjectId"/>.
        /// For an optimal pack it's mandatory to insert objects in recency order, commits followed by trees and blobs. (quoted from libgit2 API ref)
        /// </summary>
        /// <param name="id">The object ID to be inserted.</param>
        /// <exception cref="ArgumentNullException">if the id is null</exception>
        public void Add(ObjectId id)
        {
            Ensure.ArgumentNotNull(id, "id");

            Proxy.git_packbuilder_insert(packBuilderHandle, id, null);
        }

        /// <summary>
        /// Recursively inserts an object and its referenced objects by its <see cref="ObjectId"/>.
        /// Inserts the object as well as any object it references.
        /// </summary>
        /// <param name="id">The object ID to be recursively inserted.</param>
        /// <exception cref="ArgumentNullException">if the id is null</exception>
        public void AddRecursively(ObjectId id)
        {
            Ensure.ArgumentNotNull(id, "id");

            Proxy.git_packbuilder_insert_recur(packBuilderHandle, id, null);
        }

        /// <summary>
        /// Disposes the PackBuilder object.
        /// </summary>
        void IDisposable.Dispose()
        {
            packBuilderHandle.SafeDispose();
        }

        /// <summary>
        /// Writes the pack file and corresponding index file to path.
        /// </summary>
        /// <param name="path">The path that pack and index files will be written to it.</param>
        internal void Write(string path)
        {
            Proxy.git_packbuilder_write(packBuilderHandle, path);
        }

        /// <summary>
        /// Sets number of threads to spawn.
        /// </summary>
        /// <returns> Returns the number of actual threads to be used.</returns>
        /// <param name="nThread">The Number of threads to spawn. An argument of 0 ensures using all available CPUs</param>
        internal int SetMaximumNumberOfThreads(int nThread)
        {
            // Libgit2 set the number of threads to 1 by default, 0 ensures git_online_cpus
            return (int)Proxy.git_packbuilder_set_threads(packBuilderHandle, (uint)nThread);
        }

        /// <summary>
        /// Number of objects the PackBuilder will write out.
        /// </summary>
        internal long ObjectsCount
        {
            get { return (long)Proxy.git_packbuilder_object_count(packBuilderHandle); }
        }

        /// <summary>
        /// Number of objects the PackBuilder has already written out.
        /// This is only correct after the pack file has been written.
        /// </summary>
        internal long WrittenObjectsCount
        {
            get { return (long)Proxy.git_packbuilder_written(packBuilderHandle); }
        }

        internal PackBuilderHandle Handle
        {
            get { return packBuilderHandle; }
        }
    }

    /// <summary>
    /// The results of pack process of the <see cref="ObjectDatabase"/>.
    /// </summary>
    public struct PackBuilderResults
    {
        /// <summary>
        /// Number of objects the PackBuilder has already written out.
        /// </summary>
        public long WrittenObjectsCount { get; internal set; }
    }

    /// <summary>
    /// Packing options of the <see cref="ObjectDatabase"/>.
    /// </summary>
    public sealed class PackBuilderOptions
    {
        private string path;
        private int nThreads;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="packDirectory">Directory path to write the pack and index files to it</param>
        /// The default value for maximum number of threads to spawn is 0 which ensures using all available CPUs.
        /// <exception cref="ArgumentNullException">if packDirectory is null or empty</exception>
        /// <exception cref="DirectoryNotFoundException">if packDirectory doesn't exist</exception>
        public PackBuilderOptions(string packDirectory)
        {
            PackDirectoryPath = packDirectory;
            MaximumNumberOfThreads = 0;
        }

        /// <summary>
        /// Directory path to write the pack and index files to it.
        /// </summary>
        public string PackDirectoryPath
        {
            set
            {
                Ensure.ArgumentNotNullOrEmptyString(value, "packDirectory");

                if (!Directory.Exists(value))
                {
                    throw new DirectoryNotFoundException("The Directory " + value + " does not exist.");
                }

                path = value;
            }
            get
            {
                return path;
            }
        }

        /// <summary>
        /// Maximum number of threads to spawn.
        /// The default value is 0 which ensures using all available CPUs.
        /// </summary>
        public int MaximumNumberOfThreads
        {
            set
            {
                if (value < 0)
                {
                    throw new ArgumentException("Argument can not be negative", "value");
                }

                nThreads = value;
            }
            get
            {
                return nThreads;
            }
        }
    }

    /// <summary>
    /// Holds the patch between two trees.
    /// <para>The individual patches for each file can be accessed through the indexer of this class.</para>
    /// <para>Building a patch is an expensive operation. If you only need to know which files have been added,
    /// deleted, modified, ..., then consider using a simpler <see cref="TreeChanges"/>.</para>
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class Patch : IEnumerable<PatchEntryChanges>, IDiffResult
    {
        private readonly StringBuilder fullPatchBuilder = new StringBuilder();

        private readonly IDictionary<FilePath, PatchEntryChanges> changes = new Dictionary<FilePath, PatchEntryChanges>();
        private int linesAdded;
        private int linesDeleted;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Patch()
        { }

        internal unsafe Patch(DiffHandle diff)
        {
            using (diff)
            {
                int count = Proxy.git_diff_num_deltas(diff);
                for (int i = 0; i < count; i++)
                {
                    using (var patch = Proxy.git_patch_from_diff(diff, i))
                    {
                        var delta = Proxy.git_diff_get_delta(diff, i);
                        AddFileChange(delta);
                        Proxy.git_patch_print(patch, PrintCallBack);
                    }
                }
            }
        }

        private unsafe void AddFileChange(git_diff_delta* delta)
        {
            var treeEntryChanges = new TreeEntryChanges(delta);

            changes.Add(treeEntryChanges.Path, new PatchEntryChanges(delta->flags.HasFlag(GitDiffFlags.GIT_DIFF_FLAG_BINARY), treeEntryChanges));
        }

        private unsafe int PrintCallBack(git_diff_delta* delta, GitDiffHunk hunk, GitDiffLine line, IntPtr payload)
        {
            string patchPart = LaxUtf8Marshaler.FromNative(line.content, (int)line.contentLen);

            // Deleted files mean no "new file" path

            var pathPtr = delta->new_file.Path != null
                ? delta->new_file.Path
                : delta->old_file.Path;
            var filePath = LaxFilePathMarshaler.FromNative(pathPtr);

            PatchEntryChanges currentChange = this[filePath];
            string prefix = string.Empty;

            switch (line.lineOrigin)
            {
                case GitDiffLineOrigin.GIT_DIFF_LINE_CONTEXT:
                    prefix = " ";
                    break;

                case GitDiffLineOrigin.GIT_DIFF_LINE_ADDITION:
                    linesAdded++;
                    currentChange.LinesAdded++;
                    currentChange.AddedLines.Add(new Line(line.NewLineNo, patchPart));
                    prefix = "+";
                    break;

                case GitDiffLineOrigin.GIT_DIFF_LINE_DELETION:
                    linesDeleted++;
                    currentChange.LinesDeleted++;
                    currentChange.DeletedLines.Add(new Line(line.OldLineNo, patchPart));
                    prefix = "-";
                    break;
            }

            string formattedOutput = string.Concat(prefix, patchPart);

            fullPatchBuilder.Append(formattedOutput);
            currentChange.AppendToPatch(formattedOutput);

            return 0;
        }

        #region IEnumerable<PatchEntryChanges> Members

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<PatchEntryChanges> GetEnumerator()
        {
            return changes.Values.GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        /// <summary>
        /// Gets the <see cref="ContentChanges"/> corresponding to the specified <paramref name="path"/>.
        /// </summary>
        public virtual PatchEntryChanges this[string path]
        {
            get { return this[(FilePath)path]; }
        }

        private PatchEntryChanges this[FilePath path]
        {
            get
            {
                PatchEntryChanges entryChanges;
                if (changes.TryGetValue(path, out entryChanges))
                {
                    return entryChanges;
                }

                return null;
            }
        }

        /// <summary>
        /// The total number of lines added in this diff.
        /// </summary>
        public virtual int LinesAdded
        {
            get { return linesAdded; }
        }

        /// <summary>
        /// The total number of lines deleted in this diff.
        /// </summary>
        public virtual int LinesDeleted
        {
            get { return linesDeleted; }
        }

        /// <summary>
        /// The full patch file of this diff.
        /// </summary>
        public virtual string Content
        {
            get { return fullPatchBuilder.ToString(); }
        }

        /// <summary>
        /// Implicit operator for string conversion.
        /// </summary>
        /// <param name="patch"><see cref="Patch"/>.</param>
        /// <returns>The patch content as string.</returns>
        public static implicit operator string(Patch patch)
        {
            return patch.fullPatchBuilder.ToString();
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "+{0} -{1}",
                                     linesAdded,
                                     linesDeleted);
            }
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources.
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            // This doesn't do anything yet because it loads everything
            // eagerly and disposes of the diff handle in the constructor.
        }
    }

    /// <summary>
    /// Holds the changes between two versions of a file.
    /// </summary>
    public class PatchEntryChanges : ContentChanges
    {
        private readonly TreeEntryChanges treeEntryChanges;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected PatchEntryChanges()
        { }

        internal PatchEntryChanges(bool isBinaryComparison, TreeEntryChanges treeEntryChanges)
            : base(isBinaryComparison)
        {
            this.treeEntryChanges = treeEntryChanges;
        }

        /// <summary>
        /// The new path.
        /// </summary>
        public virtual string Path
        {
            get { return treeEntryChanges.Path; }
        }

        /// <summary>
        /// The new <see cref="Mode"/>.
        /// </summary>
        public virtual Mode Mode
        {
            get { return treeEntryChanges.Mode; }
        }

        /// <summary>
        /// The new content hash.
        /// </summary>
        public virtual ObjectId Oid
        {
            get { return treeEntryChanges.Oid; }
        }

        /// <summary>
        /// The kind of change that has been done (added, deleted, modified ...).
        /// </summary>
        public virtual ChangeKind Status
        {
            get { return treeEntryChanges.Status; }
        }

        /// <summary>
        /// The old path.
        /// </summary>
        public virtual string OldPath
        {
            get { return treeEntryChanges.OldPath; }
        }

        /// <summary>
        /// The old <see cref="Mode"/>.
        /// </summary>
        public virtual Mode OldMode
        {
            get { return treeEntryChanges.OldMode; }
        }

        /// <summary>
        /// The old content hash.
        /// </summary>
        public virtual ObjectId OldOid
        {
            get { return treeEntryChanges.OldOid; }
        }
    }

    /// <summary>
    /// Holds summary information for a diff.
    /// <para>The individual patches for each file can be accessed through the indexer of this class.</para>
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class PatchStats : IEnumerable<ContentChangeStats>, IDiffResult
    {
        private readonly IDictionary<FilePath, ContentChangeStats> changes = new Dictionary<FilePath, ContentChangeStats>();
        private readonly int totalLinesAdded;
        private readonly int totalLinesDeleted;

        /// <summary>
        /// For mocking.
        /// </summary>
        protected PatchStats()
        { }

        internal unsafe PatchStats(DiffHandle diff)
        {
            using (diff)
            {
                int count = Proxy.git_diff_num_deltas(diff);
                for (int i = 0; i < count; i++)
                {
                    using (var patch = Proxy.git_patch_from_diff(diff, i))
                    {
                        var delta = Proxy.git_diff_get_delta(diff, i);
                        var pathPtr = delta->new_file.Path != null ? delta->new_file.Path : delta->old_file.Path;
                        var newFilePath = LaxFilePathMarshaler.FromNative(pathPtr);

                        var stats = Proxy.git_patch_line_stats(patch);
                        int added = stats.Item1;
                        int deleted = stats.Item2;
                        changes.Add(newFilePath, new ContentChangeStats(added, deleted));
                        totalLinesAdded += added;
                        totalLinesDeleted += deleted;
                    }
                }
            }
        }

        #region IEnumerable<ContentChanges> Members

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<ContentChangeStats> GetEnumerator()
        {
            return changes.Values.GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        /// <summary>
        /// Gets the <see cref="ContentChangeStats"/> corresponding to the specified <paramref name="path"/>.
        /// </summary>
        /// <param name="path"></param>
        public virtual ContentChangeStats this[string path]
        {
            get { return this[(FilePath)path]; }
        }

        private ContentChangeStats this[FilePath path]
        {
            get
            {
                ContentChangeStats stats;
                if (changes.TryGetValue(path, out stats))
                {
                    return stats;
                }
                return null;
            }
        }

        /// <summary>
        /// The total number of lines added in this diff.
        /// </summary>
        public virtual int TotalLinesAdded
        {
            get { return totalLinesAdded; }
        }

        /// <summary>
        /// The total number of lines deleted in this diff.
        /// </summary>
        public virtual int TotalLinesDeleted
        {
            get { return totalLinesDeleted; }
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "+{0} -{1}",
                                     TotalLinesAdded,
                                     TotalLinesDeleted);
            }
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources.
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            // This doesn't do anything yet because it loads everything
            // eagerly and disposes of the diff handle in the constructor.
        }
    }

    /// <summary>
    /// The exception that is thrown when a tag cannot be peeled to the
    /// target type due to the object model.
    /// </summary>
    [Serializable]
    public class PeelException : NativeException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PeelException"/> class.
        /// </summary>
        public PeelException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="PeelException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public PeelException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="PeelException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public PeelException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="PeelException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public PeelException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="PeelException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected PeelException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal PeelException(string message, GitErrorCategory category)
            : base(message, category)
        { }

        internal override GitErrorCode ErrorCode
        {
            get
            {
                return GitErrorCode.Peel;
            }
        }
    }

    /// <summary>
    /// Options for connecting through a proxy.
    /// </summary>
    public sealed class ProxyOptions
    {
        /// <summary>
        /// The type of proxy to use. Set to Auto by default.
        /// </summary>
        public ProxyType ProxyType = ProxyType.Auto;

        /// <summary>
        /// The URL of the proxy when <see cref="LibGit2Sharp.ProxyType"/> is set to Specified.
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// Handler to generate <see cref="LibGit2Sharp.Credentials"/> for authentication.
        /// </summary>
        public CredentialsHandler CredentialsProvider { get; set; }

        /// <summary>
        /// This handler will be called to let the user make a decision on whether to allow
        /// the connection to proceed based on the certificate presented by the server.
        /// </summary>
        public CertificateCheckHandler CertificateCheck { get; set; }

        internal unsafe GitProxyOptions CreateGitProxyOptions()
        {
            var gitProxyOptions = new GitProxyOptions
            {
                Version = 1,
                Type = (GitProxyType)ProxyType
            };

            if (Url != null)
            {
                gitProxyOptions.Url = StrictUtf8Marshaler.FromManaged(Url);
            }

            if (CredentialsProvider != null)
            {
                gitProxyOptions.Credentials = GitCredentialHandler;
            }

            if (CertificateCheck != null)
            {
                gitProxyOptions.CertificateCheck = GitCertificateCheck;
            }

            return gitProxyOptions;
        }

        private int GitCredentialHandler(out IntPtr ptr, IntPtr cUrl, IntPtr usernameFromUrl, GitCredentialType credTypes, IntPtr payload)
        {
            string url = LaxUtf8Marshaler.FromNative(cUrl);
            string username = LaxUtf8Marshaler.FromNative(usernameFromUrl);

            SupportedCredentialTypes types = default(SupportedCredentialTypes);
            if (credTypes.HasFlag(GitCredentialType.UserPassPlaintext))
            {
                types |= SupportedCredentialTypes.UsernamePassword;
            }
            if (credTypes.HasFlag(GitCredentialType.Default))
            {
                types |= SupportedCredentialTypes.Default;
            }

            ptr = IntPtr.Zero;
            try
            {
                var cred = CredentialsProvider(url, username, types);
                if (cred == null)
                {
                    return (int)GitErrorCode.PassThrough;
                }
                return cred.GitCredentialHandler(out ptr);
            }
            catch (Exception exception)
            {
                Proxy.git_error_set_str(GitErrorCategory.Callback, exception);
                return (int)GitErrorCode.Error;
            }
        }

        private unsafe int GitCertificateCheck(git_certificate* certPtr, int valid, IntPtr cHostname, IntPtr payload)
        {
            string hostname = LaxUtf8Marshaler.FromNative(cHostname);
            Certificate cert = null;

            switch (certPtr->type)
            {
                case GitCertificateType.X509:
                    cert = new CertificateX509((git_certificate_x509*)certPtr);
                    break;
                case GitCertificateType.Hostkey:
                    cert = new CertificateSsh((git_certificate_ssh*)certPtr);
                    break;
            }

            bool result = false;
            try
            {
                result = CertificateCheck(cert, valid != 0, hostname);
            }
            catch (Exception exception)
            {
                Proxy.git_error_set_str(GitErrorCategory.Callback, exception);
            }

            return Proxy.ConvertResultToCancelFlag(result);
        }
    }

    /// <summary>
    /// The type of proxy to use.
    /// </summary>
    public enum ProxyType
    {
        /// <summary>
        /// Do not attempt to connect through a proxy.
        /// </summary>
        None,

        /// <summary>
        /// Try to auto-detect the proxy from the git configuration.
        /// </summary>
        Auto,

        /// <summary>
        /// Connect via the URL given in the options.
        /// </summary>
        Specified
    }

    /// <summary>
    /// Parameters controlling Pull behavior.
    /// </summary>
    public sealed class PullOptions
    {
        /// <summary>
        /// Constructor.
        /// </summary>
        public PullOptions()
        { }

        /// <summary>
        /// Parameters controlling Fetch behavior.
        /// </summary>
        public FetchOptions FetchOptions { get; set; }

        /// <summary>
        /// Parameters controlling Merge behavior.
        /// </summary>
        public MergeOptions MergeOptions { get; set; }
    }

    /// <summary>
    /// Collection of parameters controlling Push behavior.
    /// </summary>
    public sealed class PushOptions
    {
        /// <summary>
        /// Handler to generate <see cref="LibGit2Sharp.Credentials"/> for authentication.
        /// </summary>
        public CredentialsHandler CredentialsProvider { get; set; }

        /// <summary>
        /// This handler will be called to let the user make a decision on whether to allow
        /// the connection to preoceed based on the certificate presented by the server.
        /// </summary>
        public CertificateCheckHandler CertificateCheck { get; set; }

        /// <summary>
        /// If the transport being used to push to the remote requires the creation
        /// of a pack file, this controls the number of worker threads used by
        /// the packbuilder when creating that pack file to be sent to the remote.
        /// The default is 0, which indicates that the packbuilder will auto-detect
        /// the number of threads to create.
        /// </summary>
        public int PackbuilderDegreeOfParallelism { get; set; }

        /// <summary>
        /// Delegate to report errors when updating references on the remote.
        /// </summary>
        public PushStatusErrorHandler OnPushStatusError { get; set; }

        /// <summary>
        /// Delegate that progress updates of the network transfer portion of push
        /// will be reported through. The frequency of progress updates will not
        /// be more than once every 0.5 seconds (in general).
        /// </summary>
        public PushTransferProgressHandler OnPushTransferProgress { get; set; }

        /// <summary>
        /// Delegate that progress updates of the pack building portion of push
        /// will be reported through. The frequency of progress updates will not
        /// be more than once every 0.5 seconds (in general).
        /// </summary>
        public PackBuilderProgressHandler OnPackBuilderProgress { get; set; }

        /// <summary>
        /// Called once between the negotiation step and the upload. It provides
        /// information about what updates will be performed.
        /// </summary>
        public PrePushHandler OnNegotiationCompletedBeforePush { get; set; }

        /// <summary>
        /// Get/Set the custom headers.
        /// <para>
        /// This allows you to set custom headers (e.g. X-Forwarded-For,
        /// X-Request-Id, etc),
        /// </para>
        /// </summary>
        /// <remarks>
        /// Libgit2 sets some headers for HTTP requests (User-Agent, Host,
        /// Accept, Content-Type, Transfer-Encoding, Content-Length, Accept) that
        /// cannot be overriden.
        /// </remarks>
        /// <example>
        /// var pushOptions - new PushOptions() {
        ///     CustomHeaders = new String[] {"X-Request-Id: 12345"}
        /// };
        /// </example>
        /// <value>The custom headers string array</value>
        public string[] CustomHeaders { get; set; }

        /// <summary>
        /// Options for connecting through a proxy.
        /// </summary>
        public ProxyOptions ProxyOptions = new ProxyOptions();
    }

    /// <summary>
    /// Contains the results of a push operation.
    /// </summary>
    public class PushResult
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected PushResult()
        { }

        /// <summary>
        /// <see cref="PushStatusError"/>s that failed to update.
        /// </summary>
        public virtual IEnumerable<PushStatusError> FailedPushUpdates
        {
            get { return failedPushUpdates; }
        }

        /// <summary>
        /// Flag indicating if there were errors reported
        /// when updating references on the remote.
        /// </summary>
        public virtual bool HasErrors
        {
            get { return failedPushUpdates.Count > 0; }
        }

        internal PushResult(List<PushStatusError> failedPushUpdates)
        {
            this.failedPushUpdates = failedPushUpdates ?? new List<PushStatusError>();
        }

        private readonly List<PushStatusError> failedPushUpdates;
    }

    /// <summary>
    /// Information on an error updating reference on remote during a push.
    /// </summary>
    public class PushStatusError
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected PushStatusError()
        { }

        /// <summary>
        /// The reference this status refers to.
        /// </summary>
        public virtual string Reference { get; private set; }

        /// <summary>
        /// The message regarding the update of this reference.
        /// </summary>
        public virtual string Message { get; private set; }

        internal PushStatusError(string reference, string message)
        {
            Reference = reference;
            Message = message;
        }
    }

    /// <summary>
    /// Represents an update which will be performed on the remote during push
    /// </summary>
    public class PushUpdate
    {
        internal PushUpdate(string srcRefName, ObjectId srcOid, string dstRefName, ObjectId dstOid)
        {
            DestinationObjectId = dstOid;
            DestinationRefName = dstRefName;
            SourceObjectId = srcOid;
            SourceRefName = srcRefName;
        }

        internal unsafe PushUpdate(git_push_update* update)
        {
            DestinationObjectId = ObjectId.BuildFromPtr(&update->dst);
            DestinationRefName = LaxUtf8Marshaler.FromNative(update->dst_refname);
            SourceObjectId = ObjectId.BuildFromPtr(&update->src);
            SourceRefName = LaxUtf8Marshaler.FromNative(update->src_refname);
        }
        /// <summary>
        /// Empty constructor to support test suites
        /// </summary>
        protected PushUpdate()
        {
            DestinationObjectId = ObjectId.Zero;
            DestinationRefName = String.Empty;
            SourceObjectId = ObjectId.Zero;
            SourceRefName = String.Empty;
        }

        /// <summary>
        /// The source name of the reference
        /// </summary>
        public readonly string SourceRefName;
        /// <summary>
        /// The name of the reference to update on the server
        /// </summary>
        public readonly string DestinationRefName;
        /// <summary>
        /// The current target of the reference
        /// </summary>
        public readonly ObjectId SourceObjectId;
        /// <summary>
        /// The new target for the reference
        /// </summary>
        public readonly ObjectId DestinationObjectId;
    }

    /// <summary>
    /// The type of operation to be performed in a rebase step.
    /// </summary>
    public enum RebaseStepOperation
    {
        /// <summary>
        /// Commit is to be cherry-picked.
        /// </summary>
        Pick = 0,

        /// <summary>
        /// Cherry-pick the commit and edit the commit message.
        /// </summary>
        Reword,

        /// <summary>
        /// Cherry-pick the commit but allow user to edit changes.
        /// </summary>
        Edit,

        /// <summary>
        /// Commit is to be squashed into previous commit. The commit
        /// message will be merged with the previous message.
        /// </summary>
        Squash,

        /// <summary>
        /// Commit is to be squashed into previous commit. The commit
        /// message will be discarded.
        /// </summary>
        Fixup,

        // <summary>
        // No commit to cherry-pick. Run the given command and continue
        // if successful.
        // </summary>
        // Exec
    }

    /// <summary>
    /// Encapsulates a rebase operation.
    /// </summary>
    public class Rebase
    {
        internal readonly Repository repository;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Rebase()
        { }

        internal Rebase(Repository repo)
        {
            this.repository = repo;
        }

        unsafe AnnotatedCommitHandle AnnotatedCommitHandleFromRefHandle(ReferenceHandle refHandle)
        {
            return (refHandle == null) ?
                new AnnotatedCommitHandle(null, false) :
                Proxy.git_annotated_commit_from_ref(this.repository.Handle, refHandle);
        }

        /// <summary>
        /// Start a rebase operation.
        /// </summary>
        /// <param name="branch">The branch to rebase.</param>
        /// <param name="upstream">The starting commit to rebase.</param>
        /// <param name="onto">The branch to rebase onto.</param>
        /// <param name="committer">The <see cref="Identity"/> of who added the change to the repository.</param>
        /// <param name="options">The <see cref="RebaseOptions"/> that specify the rebase behavior.</param>
        /// <returns>true if completed successfully, false if conflicts encountered.</returns>
        public virtual RebaseResult Start(Branch branch, Branch upstream, Branch onto, Identity committer, RebaseOptions options)
        {
            Ensure.ArgumentNotNull(upstream, "upstream");

            options = options ?? new RebaseOptions();

            EnsureNonBareRepo();

            if (this.repository.Info.CurrentOperation != CurrentOperation.None)
            {
                throw new LibGit2SharpException("A {0} operation is already in progress.",
                    this.repository.Info.CurrentOperation);
            }

            Func<Branch, ReferenceHandle> RefHandleFromBranch = (Branch b) =>
            {
                return (b == null) ?
                    null :
                    this.repository.Refs.RetrieveReferencePtr(b.CanonicalName);
            };

            using (GitCheckoutOptsWrapper checkoutOptionsWrapper = new GitCheckoutOptsWrapper(options))
            {
                GitRebaseOptions gitRebaseOptions = new GitRebaseOptions()
                {
                    version = 1,
                    checkout_options = checkoutOptionsWrapper.Options,
                };

                using (ReferenceHandle branchRefPtr = RefHandleFromBranch(branch))
                using (ReferenceHandle upstreamRefPtr = RefHandleFromBranch(upstream))
                using (ReferenceHandle ontoRefPtr = RefHandleFromBranch(onto))
                using (AnnotatedCommitHandle annotatedBranchCommitHandle = AnnotatedCommitHandleFromRefHandle(branchRefPtr))
                using (AnnotatedCommitHandle upstreamRefAnnotatedCommitHandle = AnnotatedCommitHandleFromRefHandle(upstreamRefPtr))
                using (AnnotatedCommitHandle ontoRefAnnotatedCommitHandle = AnnotatedCommitHandleFromRefHandle(ontoRefPtr))
                using (RebaseHandle rebaseOperationHandle = Proxy.git_rebase_init(this.repository.Handle,
                                                                                      annotatedBranchCommitHandle,
                                                                                      upstreamRefAnnotatedCommitHandle,
                                                                                      ontoRefAnnotatedCommitHandle,
                                                                                      gitRebaseOptions))
                {
                    RebaseResult rebaseResult = RebaseOperationImpl.Run(rebaseOperationHandle,
                                                                        this.repository,
                                                                        committer,
                                                                        options);
                    return rebaseResult;
                }
            }
        }

        /// <summary>
        /// Continue the current rebase.
        /// </summary>
        /// <param name="committer">The <see cref="Identity"/> of who added the change to the repository.</param>
        /// <param name="options">The <see cref="RebaseOptions"/> that specify the rebase behavior.</param>
        public virtual unsafe RebaseResult Continue(Identity committer, RebaseOptions options)
        {
            Ensure.ArgumentNotNull(committer, "committer");

            options = options ?? new RebaseOptions();

            EnsureNonBareRepo();

            using (GitCheckoutOptsWrapper checkoutOptionsWrapper = new GitCheckoutOptsWrapper(options))
            {
                GitRebaseOptions gitRebaseOptions = new GitRebaseOptions()
                {
                    version = 1,
                    checkout_options = checkoutOptionsWrapper.Options,
                };

                using (RebaseHandle rebase = Proxy.git_rebase_open(repository.Handle, gitRebaseOptions))
                {
                    // TODO: Should we check the pre-conditions for committing here
                    // for instance - what if we had failed on the git_rebase_finish call,
                    // do we want continue to be able to restart afterwords...
                    var rebaseCommitResult = Proxy.git_rebase_commit(rebase, null, committer);

                    // Report that we just completed the step
                    if (options.RebaseStepCompleted != null)
                    {
                        // Get information on the current step
                        long currentStepIndex = Proxy.git_rebase_operation_current(rebase);
                        long totalStepCount = Proxy.git_rebase_operation_entrycount(rebase);
                        git_rebase_operation* gitRebasestepInfo = Proxy.git_rebase_operation_byindex(rebase, currentStepIndex);

                        var stepInfo = new RebaseStepInfo(gitRebasestepInfo->type,
                                                          repository.Lookup<Commit>(ObjectId.BuildFromPtr(&gitRebasestepInfo->id)),
                                                          LaxUtf8NoCleanupMarshaler.FromNative(gitRebasestepInfo->exec));

                        if (rebaseCommitResult.WasPatchAlreadyApplied)
                        {
                            options.RebaseStepCompleted(new AfterRebaseStepInfo(stepInfo, currentStepIndex, totalStepCount));
                        }
                        else
                        {
                            options.RebaseStepCompleted(new AfterRebaseStepInfo(stepInfo,
                                                                                repository.Lookup<Commit>(new ObjectId(rebaseCommitResult.CommitId)),
                                                                                currentStepIndex,
                                                                                totalStepCount));
                        }
                    }

                    RebaseResult rebaseResult = RebaseOperationImpl.Run(rebase, repository, committer, options);
                    return rebaseResult;
                }
            }
        }

        /// <summary>
        /// Abort the rebase operation.
        /// </summary>
        public virtual void Abort()
        {
            Abort(null);
        }

        /// <summary>
        /// Abort the rebase operation.
        /// </summary>
        /// <param name="options">The <see cref="RebaseOptions"/> that specify the rebase behavior.</param>
        public virtual void Abort(RebaseOptions options)
        {
            options = options ?? new RebaseOptions();

            EnsureNonBareRepo();

            using (GitCheckoutOptsWrapper checkoutOptionsWrapper = new GitCheckoutOptsWrapper(options))
            {
                GitRebaseOptions gitRebaseOptions = new GitRebaseOptions()
                {
                    checkout_options = checkoutOptionsWrapper.Options,
                };

                using (RebaseHandle rebase = Proxy.git_rebase_open(repository.Handle, gitRebaseOptions))
                {
                    Proxy.git_rebase_abort(rebase);
                }
            }
        }

        /// <summary>
        /// The info on the current step.
        /// </summary>
        public virtual unsafe RebaseStepInfo GetCurrentStepInfo()
        {
            if (repository.Info.CurrentOperation != LibGit2Sharp.CurrentOperation.RebaseMerge)
            {
                return null;
            }

            GitRebaseOptions gitRebaseOptions = new GitRebaseOptions()
            {
                version = 1,
            };

            using (RebaseHandle rebaseHandle = Proxy.git_rebase_open(repository.Handle, gitRebaseOptions))
            {
                long currentStepIndex = Proxy.git_rebase_operation_current(rebaseHandle);
                git_rebase_operation* gitRebasestepInfo = Proxy.git_rebase_operation_byindex(rebaseHandle, currentStepIndex);
                var stepInfo = new RebaseStepInfo(gitRebasestepInfo->type,
                                                  repository.Lookup<Commit>(ObjectId.BuildFromPtr(&gitRebasestepInfo->id)),
                                                  LaxUtf8Marshaler.FromNative(gitRebasestepInfo->exec));
                return stepInfo;
            }
        }

        /// <summary>
        /// Get info on the specified step
        /// </summary>
        /// <param name="stepIndex"></param>
        /// <returns></returns>
        public virtual unsafe RebaseStepInfo GetStepInfo(long stepIndex)
        {
            if (repository.Info.CurrentOperation != LibGit2Sharp.CurrentOperation.RebaseMerge)
            {
                return null;
            }

            GitRebaseOptions gitRebaseOptions = new GitRebaseOptions()
            {
                version = 1,
            };

            using (RebaseHandle rebaseHandle = Proxy.git_rebase_open(repository.Handle, gitRebaseOptions))
            {
                git_rebase_operation* gitRebasestepInfo = Proxy.git_rebase_operation_byindex(rebaseHandle, stepIndex);
                var stepInfo = new RebaseStepInfo(gitRebasestepInfo->type,
                                                  repository.Lookup<Commit>(ObjectId.BuildFromPtr(&gitRebasestepInfo->id)),
                                                  LaxUtf8Marshaler.FromNative(gitRebasestepInfo->exec));
                return stepInfo;
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public virtual long GetCurrentStepIndex()
        {
            GitRebaseOptions gitRebaseOptions = new GitRebaseOptions()
            {
                version = 1,
            };

            using (RebaseHandle rebaseHandle = Proxy.git_rebase_open(repository.Handle, gitRebaseOptions))
            {
                return Proxy.git_rebase_operation_current(rebaseHandle);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public virtual long GetTotalStepCount()
        {
            GitRebaseOptions gitRebaseOptions = new GitRebaseOptions()
            {
                version = 1,
            };

            using (RebaseHandle rebaseHandle = Proxy.git_rebase_open(repository.Handle, gitRebaseOptions))
            {
                return Proxy.git_rebase_operation_entrycount(rebaseHandle);
            }
        }

        private void EnsureNonBareRepo()
        {
            if (this.repository.Info.IsBare)
            {
                throw new BareRepositoryException("Rebase operations in a bare repository are not supported.");
            }
        }
    }

    internal class RebaseOperationImpl
    {
        /// <summary>
        /// Run a rebase to completion, a conflict, or a requested stop point.
        /// </summary>
        /// <param name="rebaseOperationHandle">Handle to the rebase operation.</param>
        /// <param name="repository">Repository in which rebase operation is being run.</param>
        /// <param name="committer">Committer Identity to use for the rebased commits.</param>
        /// <param name="options">Options controlling rebase behavior.</param>
        /// <returns>RebaseResult that describes the result of the rebase operation.</returns>
        public static RebaseResult Run(RebaseHandle rebaseOperationHandle,
            Repository repository,
            Identity committer,
            RebaseOptions options)
        {
            Ensure.ArgumentNotNull(rebaseOperationHandle, "rebaseOperationHandle");
            Ensure.ArgumentNotNull(repository, "repository");
            Ensure.ArgumentNotNull(committer, "committer");
            Ensure.ArgumentNotNull(options, "options");

            RebaseResult rebaseResult = null;

            // This loop will run until a rebase result has been set.
            while (rebaseResult == null)
            {
                RebaseProgress rebaseStepContext = NextRebaseStep(repository, rebaseOperationHandle);

                if (rebaseStepContext.current != -1)
                {
                    rebaseResult = RunRebaseStep(rebaseOperationHandle,
                                                   repository,
                                                   committer,
                                                   options,
                                                   rebaseStepContext.current,
                                                   rebaseStepContext.total);
                }
                else
                {
                    // No step to apply - need to complete the rebase.
                    rebaseResult = CompleteRebase(rebaseOperationHandle, committer);
                }
            }

            return rebaseResult;
        }

        private static RebaseResult CompleteRebase(RebaseHandle rebaseOperationHandle, Identity committer)
        {
            long totalStepCount = Proxy.git_rebase_operation_entrycount(rebaseOperationHandle);

            // Rebase is completed!
            Proxy.git_rebase_finish(rebaseOperationHandle, committer);
            var rebaseResult = new RebaseResult(RebaseStatus.Complete,
                                            totalStepCount,
                                            totalStepCount,
                                            null);
            return rebaseResult;
        }

        /// <summary>
        /// Run the current rebase step. This will handle reporting that we are about to run a rebase step,
        /// identifying and running the operation for the current step, and reporting the current step is completed.
        /// </summary>
        /// <param name="rebaseOperationHandle"></param>
        /// <param name="repository"></param>
        /// <param name="committer"></param>
        /// <param name="options"></param>
        /// <param name="stepToApplyIndex"></param>
        /// <param name="totalStepCount"/>
        /// <returns></returns>
        private static unsafe RebaseResult RunRebaseStep(RebaseHandle rebaseOperationHandle,
                                                  Repository repository,
                                                  Identity committer,
                                                  RebaseOptions options,
                                                  long stepToApplyIndex,
                                                  long totalStepCount)
        {
            RebaseStepResult rebaseStepResult = null;
            RebaseResult rebaseSequenceResult = null;

            git_rebase_operation* rebaseOp = Proxy.git_rebase_operation_byindex(rebaseOperationHandle, stepToApplyIndex);
            ObjectId idOfCommitBeingRebased = ObjectId.BuildFromPtr(&rebaseOp->id);

            RebaseStepInfo stepToApplyInfo = new RebaseStepInfo(rebaseOp->type,
                                                                repository.Lookup<Commit>(idOfCommitBeingRebased),
                                                                LaxUtf8NoCleanupMarshaler.FromNative(rebaseOp->exec));

            // Report the rebase step we are about to perform.
            if (options.RebaseStepStarting != null)
            {
                options.RebaseStepStarting(new BeforeRebaseStepInfo(stepToApplyInfo, stepToApplyIndex, totalStepCount));
            }

            // Perform the rebase step
            git_rebase_operation* rebaseOpReport = Proxy.git_rebase_next(rebaseOperationHandle);

            // Verify that the information from the native library is consistent.
            VerifyRebaseOp(rebaseOpReport, stepToApplyInfo);

            // Handle the result
            switch (stepToApplyInfo.Type)
            {
                case RebaseStepOperation.Pick:
                    rebaseStepResult = ApplyPickStep(rebaseOperationHandle, repository, committer, options, stepToApplyInfo);
                    break;
                case RebaseStepOperation.Squash:
                case RebaseStepOperation.Edit:
                // case RebaseStepOperation.Exec:
                case RebaseStepOperation.Fixup:
                case RebaseStepOperation.Reword:
                    // These operations are not yet supported by lg2.
                    throw new LibGit2SharpException("Rebase Operation Type ({0}) is not currently supported in LibGit2Sharp.",
                        stepToApplyInfo.Type);
                default:
                    throw new ArgumentException(string.Format(
                        "Unexpected Rebase Operation Type: {0}", stepToApplyInfo.Type));
            }

            // Report that we just completed the step
            if (options.RebaseStepCompleted != null &&
                (rebaseStepResult.Status == RebaseStepStatus.Committed ||
                rebaseStepResult.Status == RebaseStepStatus.ChangesAlreadyApplied))
            {
                if (rebaseStepResult.ChangesAlreadyApplied)
                {
                    options.RebaseStepCompleted(new AfterRebaseStepInfo(stepToApplyInfo, stepToApplyIndex, totalStepCount));
                }
                else
                {
                    options.RebaseStepCompleted(new AfterRebaseStepInfo(stepToApplyInfo,
                                                                        repository.Lookup<Commit>(new ObjectId(rebaseStepResult.CommitId)),
                                                                        stepToApplyIndex,
                                                                        totalStepCount));
                }
            }

            // If the result of the rebase step is something that requires us to stop
            // running the rebase sequence operations, then report the result.
            if (rebaseStepResult.Status == RebaseStepStatus.Conflicts)
            {
                rebaseSequenceResult = new RebaseResult(RebaseStatus.Conflicts,
                                                        stepToApplyIndex,
                                                        totalStepCount,
                                                        null);
            }

            return rebaseSequenceResult;
        }

        private static RebaseStepResult ApplyPickStep(RebaseHandle rebaseOperationHandle, Repository repository, Identity committer, RebaseOptions options, RebaseStepInfo stepToApplyInfo)
        {
            RebaseStepResult rebaseStepResult;

            // commit and continue.
            if (repository.Index.IsFullyMerged)
            {
                Proxy.GitRebaseCommitResult rebase_commit_result = Proxy.git_rebase_commit(rebaseOperationHandle, null, committer);

                if (rebase_commit_result.WasPatchAlreadyApplied)
                {
                    rebaseStepResult = new RebaseStepResult(RebaseStepStatus.ChangesAlreadyApplied);
                }
                else
                {
                    rebaseStepResult = new RebaseStepResult(RebaseStepStatus.Committed, rebase_commit_result.CommitId);
                }
            }
            else
            {
                rebaseStepResult = new RebaseStepResult(RebaseStepStatus.Conflicts);
            }

            return rebaseStepResult;
        }

        /// <summary>
        /// Verify that the information in a GitRebaseOperation and a RebaseStepInfo agree
        /// </summary>
        /// <param name="rebaseOpReport"></param>
        /// <param name="stepInfo"></param>
        private static unsafe void VerifyRebaseOp(git_rebase_operation* rebaseOpReport, RebaseStepInfo stepInfo)
        {
            // The step reported via querying by index and the step returned from git_rebase_next
            // should be the same
            if (rebaseOpReport == null ||
                ObjectId.BuildFromPtr(&rebaseOpReport->id) != stepInfo.Commit.Id ||
                rebaseOpReport->type != stepInfo.Type)
            {
                // This is indicative of a program error - should never happen.
                throw new LibGit2SharpException("Unexpected step info reported by running rebase step.");
            }
        }

        private struct RebaseProgress
        {
            public long current;
            public long total;
        }

        /// <summary>
        /// Returns the next rebase step, or null if there are none,
        /// and the rebase operation needs to be finished.
        /// </summary>
        /// <param name="repository"></param>
        /// <param name="rebaseOperationHandle"></param>
        /// <returns></returns>
        private static RebaseProgress NextRebaseStep(
            Repository repository,
            RebaseHandle rebaseOperationHandle)
        {
            // stepBeingApplied indicates the step that will be applied by by git_rebase_next.
            // The current step does not get incremented until git_rebase_next (except on
            // the initial step), but we want to report the step that will be applied.
            long stepToApplyIndex = Proxy.git_rebase_operation_current(rebaseOperationHandle);

            stepToApplyIndex++;

            long totalStepCount = Proxy.git_rebase_operation_entrycount(rebaseOperationHandle);

            if (stepToApplyIndex == totalStepCount)
            {
                stepToApplyIndex = -1;
            }

            RebaseProgress progress = new RebaseProgress()
            {
                current = stepToApplyIndex,
                total = totalStepCount,
            };

            return progress;
        }

        private enum RebaseStepStatus
        {
            Committed,
            Conflicts,
            ChangesAlreadyApplied,
        }

        private class RebaseStepResult
        {
            public RebaseStepResult(RebaseStepStatus status)
            {
                Status = status;
                CommitId = GitOid.Empty;
            }

            public RebaseStepResult(RebaseStepStatus status, GitOid commitId)
            {
                Status = status;
                CommitId = commitId;
            }

            /// <summary>
            /// The ID of the commit that was generated, if any
            /// </summary>
            public GitOid CommitId;

            /// <summary>
            /// bool to indicate if the patch was already applied.
            /// If Patch was already applied, then CommitId will be empty (all zeros).
            /// </summary>
            public bool ChangesAlreadyApplied
            {
                get { return Status == RebaseStepStatus.ChangesAlreadyApplied; }
            }

            public RebaseStepStatus Status;
        }
    }

    /// <summary>
    /// Options controlling rebase behavior.
    /// </summary>
    public sealed class RebaseOptions : IConvertableToGitCheckoutOpts
    {
        /// <summary>
        /// Delegate that is called before each rebase step.
        /// </summary>
        public RebaseStepStartingHandler RebaseStepStarting { get; set; }

        /// <summary>
        /// Delegate that is called after each rebase step is completed.
        /// </summary>
        public RebaseStepCompletedHandler RebaseStepCompleted { get; set; }

        /// <summary>
        /// The Flags specifying what conditions are
        /// reported through the OnCheckoutNotify delegate.
        /// </summary>
        public CheckoutNotifyFlags CheckoutNotifyFlags { get; set; }

        /// <summary>
        /// Delegate that the checkout will report progress through.
        /// </summary>
        public CheckoutProgressHandler OnCheckoutProgress { get; set; }

        /// <summary>
        /// Delegate that checkout will notify callers of
        /// certain conditions. The conditions that are reported is
        /// controlled with the CheckoutNotifyFlags property.
        /// </summary>
        public CheckoutNotifyHandler OnCheckoutNotify { get; set; }

        /// <summary>
        /// How conflicting index entries should be written out during checkout.
        /// </summary>
        public CheckoutFileConflictStrategy FileConflictStrategy { get; set; }

        CheckoutCallbacks IConvertableToGitCheckoutOpts.GenerateCallbacks()
        {
            return CheckoutCallbacks.From(OnCheckoutProgress, OnCheckoutNotify);
        }

        CheckoutStrategy IConvertableToGitCheckoutOpts.CheckoutStrategy
        {
            get
            {
                return CheckoutStrategy.GIT_CHECKOUT_SAFE |
                       GitCheckoutOptsWrapper.CheckoutStrategyFromFileConflictStrategy(FileConflictStrategy);
            }
        }
    }

    /// <summary>
    /// The status of the rebase.
    /// </summary>
    public enum RebaseStatus
    {
        /// <summary>
        /// The rebase operation was run to completion
        /// </summary>
        Complete,

        /// <summary>
        /// The rebase operation hit a conflict and stopped.
        /// </summary>
        Conflicts,

        /// <summary>
        /// The rebase operation has hit a user requested stop point
        /// (edit, reword, ect.)
        /// </summary>
        Stop,
    };

    /// <summary>
    /// Information on a rebase operation.
    /// </summary>
    public class RebaseResult
    {
        /// <summary>
        /// Needed for mocking.
        /// </summary>
        protected RebaseResult()
        { }

        internal RebaseResult(RebaseStatus status,
                              long stepNumber,
                              long totalSteps,
                              RebaseStepInfo currentStepInfo)
        {
            Status = status;
            CompletedStepCount = stepNumber;
            TotalStepCount = totalSteps;
            CurrentStepInfo = currentStepInfo;
        }

        /// <summary>
        /// Information on the operation to be performed in the current step.
        /// If the overall Rebase operation has completed successfully, this will
        /// be null.
        /// </summary>
        public virtual RebaseStepInfo CurrentStepInfo { get; private set; }

        /// <summary>
        /// Did the rebase operation run until it should stop
        /// (completed the rebase, or the operation for the current step
        /// is one that sequencing should stop.
        /// </summary>
        public virtual RebaseStatus Status { get; protected set; }

        /// <summary>
        /// The number of completed steps.
        /// </summary>
        public virtual long CompletedStepCount { get; protected set; }

        /// <summary>
        /// The total number of steps in the rebase.
        /// </summary>
        public virtual long TotalStepCount { get; protected set; }
    }

    /// <summary>
    /// Information on a particular step of a rebase operation.
    /// </summary>
    public class RebaseStepInfo
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected RebaseStepInfo()
        { }

        internal RebaseStepInfo(RebaseStepOperation type, Commit commit, string exec)
        {
            Type = type;
            Commit = commit;
            Exec = exec;
        }

        /// <summary>
        /// The rebase operation type.
        /// </summary>
        public virtual RebaseStepOperation Type { get; private set; }

        /// <summary>
        /// The object ID the step is operating on.
        /// </summary>
        public virtual Commit Commit { get; private set; }

        /// <summary>
        /// Command to execute, if any.
        /// </summary>
        internal virtual string Exec { get; private set; }
    }

    /// <summary>
    /// The exception that is thrown when an error is encountered while recursing
    /// through submodules. The inner exception contains the exception that was
    /// initially thrown while operating on the submodule.
    /// </summary>
    [Serializable]
    public class RecurseSubmodulesException : LibGit2SharpException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RecurseSubmodulesException"/> class.
        /// </summary>
        public RecurseSubmodulesException()
        { }

        /// <summary>
        /// The path to the initial repository the operation was run on.
        /// </summary>
        public virtual string InitialRepositoryPath { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="RecurseSubmodulesException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        /// <param name="initialRepositoryPath">The path to the initial repository the operation was performed on.</param>
        public RecurseSubmodulesException(string message, Exception innerException, string initialRepositoryPath)
            : base(message, innerException)
        {
            InitialRepositoryPath = initialRepositoryPath;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.RecurseSubmodulesException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected RecurseSubmodulesException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }
    }

    /// <summary>
    /// A Reference to another git object
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public abstract class Reference : IEquatable<Reference>, IBelongToARepository
    {
        private static readonly LambdaEqualityHelper<Reference> equalityHelper =
            new LambdaEqualityHelper<Reference>(x => x.CanonicalName, x => x.TargetIdentifier);

        private readonly IRepository repo;
        private readonly string canonicalName;
        private readonly string targetIdentifier;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Reference()
        { }

        /// <remarks>
        /// This would be protected+internal, were that supported by C#.
        /// Do not use except in subclasses.
        /// </remarks>
        internal Reference(IRepository repo, string canonicalName, string targetIdentifier)
        {
            this.repo = repo;
            this.canonicalName = canonicalName;
            this.targetIdentifier = targetIdentifier;
        }

        // This overload lets public-facing methods avoid having to use the pointers directly
        internal static unsafe T BuildFromPtr<T>(ReferenceHandle handle, Repository repo) where T : Reference
        {
            return BuildFromPtr<T>((git_reference*) handle.Handle, repo);
        }

        internal static unsafe T BuildFromPtr<T>(git_reference* handle, Repository repo) where T : Reference
        {
            GitReferenceType type = Proxy.git_reference_type(handle);
            string name = Proxy.git_reference_name(handle);

            Reference reference;

            switch (type)
            {
                case GitReferenceType.Symbolic:
                    string targetIdentifier = Proxy.git_reference_symbolic_target(handle);

                    var targetRef = repo.Refs[targetIdentifier];
                    reference = new SymbolicReference(repo, name, targetIdentifier, targetRef);
                    break;

                case GitReferenceType.Oid:
                    ObjectId targetOid = Proxy.git_reference_target(handle);

                    reference = new DirectReference(name, repo, targetOid);
                    break;

                default:
                    throw new LibGit2SharpException("Unable to build a new reference from a type '{0}'.", type);
            }

            return reference as T;
        }

        /// <summary>
        /// Determines if the proposed reference name is well-formed.
        /// </summary>
        /// <para>
        /// - Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        ///
        /// - Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
        /// sequences ".." and "@{" which have special meaning to revparse.
        /// </para>
        /// <param name="canonicalName">The name to be checked.</param>
        /// <returns>true is the name is valid; false otherwise.</returns>
        public static bool IsValidName(string canonicalName)
        {
            return Proxy.git_reference_is_valid_name(canonicalName);
        }

        /// <summary>
        /// Determine if the current <see cref="Reference"/> is a local branch.
        /// </summary>
        /// <returns>true if the current <see cref="Reference"/> is a local branch, false otherwise.</returns>
        public virtual bool IsLocalBranch
        {
            get { return CanonicalName.LooksLikeLocalBranch(); }
        }

        /// <summary>
        /// Determine if the current <see cref="Reference"/> is a remote tracking branch.
        /// </summary>
        /// <returns>true if the current <see cref="Reference"/> is a remote tracking branch, false otherwise.</returns>
        public virtual bool IsRemoteTrackingBranch
        {
            get { return CanonicalName.LooksLikeRemoteTrackingBranch(); }
        }

        /// <summary>
        /// Determine if the current <see cref="Reference"/> is a tag.
        /// </summary>
        /// <returns>true if the current <see cref="Reference"/> is a tag, false otherwise.</returns>
        public virtual bool IsTag
        {
            get { return CanonicalName.LooksLikeTag(); }
        }

        /// <summary>
        /// Determine if the current <see cref="Reference"/> is a note.
        /// </summary>
        /// <returns>true if the current <see cref="Reference"/> is a note, false otherwise.</returns>
        public virtual bool IsNote
        {
            get { return CanonicalName.LooksLikeNote(); }
        }

        /// <summary>
        /// Gets the full name of this reference.
        /// </summary>
        public virtual string CanonicalName
        {
            get { return canonicalName; }
        }

        /// <summary>
        /// Recursively peels the target of the reference until a direct reference is encountered.
        /// </summary>
        /// <returns>The <see cref="DirectReference"/> this <see cref="Reference"/> points to.</returns>
        public abstract DirectReference ResolveToDirectReference();

        /// <summary>
        /// Gets the target declared by the reference.
        /// <para>
        ///   If this reference is a <see cref="SymbolicReference"/>, returns the canonical name of the target.
        ///   Otherwise, if this reference is a <see cref="DirectReference"/>, returns the sha of the target.
        /// </para>
        /// </summary>
        // TODO: Maybe find a better name for this property.
        public virtual string TargetIdentifier
        {
            get { return targetIdentifier; }
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="Reference"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="Reference"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="Reference"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as Reference);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Reference"/> is equal to the current <see cref="Reference"/>.
        /// </summary>
        /// <param name="other">The <see cref="Reference"/> to compare with the current <see cref="Reference"/>.</param>
        /// <returns>True if the specified <see cref="Reference"/> is equal to the current <see cref="Reference"/>; otherwise, false.</returns>
        public bool Equals(Reference other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="Reference"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="Reference"/> to compare.</param>
        /// <param name="right">Second <see cref="Reference"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(Reference left, Reference right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="Reference"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="Reference"/> to compare.</param>
        /// <param name="right">Second <see cref="Reference"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(Reference left, Reference right)
        {
            return !Equals(left, right);
        }

        /// <summary>
        /// Returns the <see cref="CanonicalName"/>, a <see cref="String"/> representation of the current <see cref="Reference"/>.
        /// </summary>
        /// <returns>The <see cref="CanonicalName"/> that represents the current <see cref="Reference"/>.</returns>
        public override string ToString()
        {
            return CanonicalName;
        }

        internal static string LocalBranchPrefix
        {
            get { return "refs/heads/"; }
        }

        internal static string RemoteTrackingBranchPrefix
        {
            get { return "refs/remotes/"; }
        }

        internal static string TagPrefix
        {
            get { return "refs/tags/"; }
        }

        internal static string NotePrefix
        {
            get { return "refs/notes/"; }
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0} => \"{1}\"",
                                     CanonicalName,
                                     TargetIdentifier);
            }
        }

        IRepository IBelongToARepository.Repository
        {
            get
            {
                if (repo == null)
                {
                    throw new InvalidOperationException("Repository requires a local repository");
                }

                return repo;
            }
        }
    }

    /// <summary>
    /// The Collection of references in a <see cref="Repository"/>
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class ReferenceCollection : IEnumerable<Reference>
    {
        internal readonly Repository repo;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected ReferenceCollection()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReferenceCollection"/> class.
        /// </summary>
        /// <param name="repo">The repo.</param>
        internal ReferenceCollection(Repository repo)
        {
            this.repo = repo;
        }

        /// <summary>
        /// Gets the <see cref="LibGit2Sharp.Reference"/> with the specified name.
        /// </summary>
        /// <param name="name">The canonical name of the reference to resolve.</param>
        /// <returns>The resolved <see cref="LibGit2Sharp.Reference"/> if it has been found, null otherwise.</returns>
        public virtual Reference this[string name]
        {
            get { return Resolve<Reference>(name); }
        }

        #region IEnumerable<Reference> Members

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<Reference> GetEnumerator()
        {
            return Proxy.git_reference_list(repo.Handle)
                .Select(n => this[n])
                .GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        /// <summary>
        /// Creates a direct or symbolic reference with the specified name and target
        /// </summary>
        /// <param name="name">The name of the reference to create.</param>
        /// <param name="canonicalRefNameOrObjectish">The target which can be either the canonical name of a reference or a revparse spec.</param>
        /// <param name="logMessage">The optional message to log in the <see cref="ReflogCollection"/> when adding the <see cref="Reference"/></param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference Add(string name, string canonicalRefNameOrObjectish,
            string logMessage)
        {
            return Add(name, canonicalRefNameOrObjectish, logMessage, false);
        }

        private enum RefState
        {
            Exists,
            DoesNotExistButLooksValid,
            DoesNotLookValid,
        }

        private static RefState TryResolveReference(out Reference reference, ReferenceCollection refsColl, string canonicalName)
        {
            if (!Reference.IsValidName(canonicalName))
            {
                reference = null;
                return RefState.DoesNotLookValid;
            }

            reference = refsColl[canonicalName];

            return reference != null ? RefState.Exists : RefState.DoesNotExistButLooksValid;
        }

        /// <summary>
        /// Creates a direct or symbolic reference with the specified name and target
        /// </summary>
        /// <param name="name">The name of the reference to create.</param>
        /// <param name="canonicalRefNameOrObjectish">The target which can be either the canonical name of a reference or a revparse spec.</param>
        /// <param name="logMessage">The optional message to log in the <see cref="ReflogCollection"/> when adding the <see cref="Reference"/></param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing reference, false otherwise.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference Add(string name, string canonicalRefNameOrObjectish, string logMessage, bool allowOverwrite)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");
            Ensure.ArgumentNotNullOrEmptyString(canonicalRefNameOrObjectish, "canonicalRefNameOrObjectish");

            Reference reference;
            RefState refState = TryResolveReference(out reference, this, canonicalRefNameOrObjectish);

            var gitObject = repo.Lookup(canonicalRefNameOrObjectish, GitObjectType.Any, LookUpOptions.None);

            if (refState == RefState.Exists)
            {
                return Add(name, reference, logMessage, allowOverwrite);
            }

            if (refState == RefState.DoesNotExistButLooksValid && gitObject == null)
            {
                using (ReferenceHandle handle = Proxy.git_reference_symbolic_create(repo.Handle, name, canonicalRefNameOrObjectish, allowOverwrite,
                    logMessage))
                {
                    return Reference.BuildFromPtr<Reference>(handle, repo);
                }
            }

            Ensure.GitObjectIsNotNull(gitObject, canonicalRefNameOrObjectish);

            if (logMessage == null)
            {
                logMessage = string.Format(CultureInfo.InvariantCulture, "{0}: Created from {1}",
                    name.LooksLikeLocalBranch() ? "branch" : "reference", canonicalRefNameOrObjectish);
            }

            EnsureHasLog(name);
            return Add(name, gitObject.Id, logMessage, allowOverwrite);
        }

        /// <summary>
        /// Creates a direct or symbolic reference with the specified name and target
        /// </summary>
        /// <param name="name">The name of the reference to create.</param>
        /// <param name="canonicalRefNameOrObjectish">The target which can be either the canonical name of a reference or a revparse spec.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference Add(string name, string canonicalRefNameOrObjectish)
        {
            return Add(name, canonicalRefNameOrObjectish, null, false);
        }

        /// <summary>
        /// Creates a direct or symbolic reference with the specified name and target
        /// </summary>
        /// <param name="name">The name of the reference to create.</param>
        /// <param name="canonicalRefNameOrObjectish">The target which can be either the canonical name of a reference or a revparse spec.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing reference, false otherwise.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference Add(string name, string canonicalRefNameOrObjectish, bool allowOverwrite)
        {
            return Add(name, canonicalRefNameOrObjectish, null, allowOverwrite);
        }
        /// <summary>
        /// Creates a direct reference with the specified name and target
        /// </summary>
        /// <param name="name">The canonical name of the reference to create.</param>
        /// <param name="targetId">Id of the target object.</param>
        /// <param name="logMessage">The optional message to log in the <see cref="ReflogCollection"/> when adding the <see cref="DirectReference"/></param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual DirectReference Add(string name, ObjectId targetId, string logMessage)
        {
            return Add(name, targetId, logMessage, false);
        }

        /// <summary>
        /// Creates a direct reference with the specified name and target
        /// </summary>
        /// <param name="name">The canonical name of the reference to create.</param>
        /// <param name="targetId">Id of the target object.</param>
        /// <param name="logMessage">The optional message to log in the <see cref="ReflogCollection"/> when adding the <see cref="DirectReference"/></param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing reference, false otherwise.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual DirectReference Add(string name, ObjectId targetId, string logMessage, bool allowOverwrite)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");
            Ensure.ArgumentNotNull(targetId, "targetId");

            using (ReferenceHandle handle = Proxy.git_reference_create(repo.Handle, name, targetId, allowOverwrite, logMessage))
            {
                return (DirectReference)Reference.BuildFromPtr<Reference>(handle, repo);
            }
        }

        /// <summary>
        /// Creates a direct reference with the specified name and target
        /// </summary>
        /// <param name="name">The canonical name of the reference to create.</param>
        /// <param name="targetId">Id of the target object.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual DirectReference Add(string name, ObjectId targetId)
        {
            return Add(name, targetId, null, false);
        }

        /// <summary>
        /// Creates a direct reference with the specified name and target
        /// </summary>
        /// <param name="name">The canonical name of the reference to create.</param>
        /// <param name="targetId">Id of the target object.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing reference, false otherwise.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual DirectReference Add(string name, ObjectId targetId, bool allowOverwrite)
        {
            return Add(name, targetId, null, allowOverwrite);
        }

        /// <summary>
        /// Creates a symbolic reference with the specified name and target
        /// </summary>
        /// <param name="name">The canonical name of the reference to create.</param>
        /// <param name="targetRef">The target reference.</param>
        /// <param name="logMessage">The optional message to log in the <see cref="ReflogCollection"/> when adding the <see cref="SymbolicReference"/></param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual SymbolicReference Add(string name, Reference targetRef, string logMessage)
        {
            return Add(name, targetRef, logMessage, false);
        }

        /// <summary>
        /// Creates a symbolic reference with the specified name and target
        /// </summary>
        /// <param name="name">The canonical name of the reference to create.</param>
        /// <param name="targetRef">The target reference.</param>
        /// <param name="logMessage">The optional message to log in the <see cref="ReflogCollection"/> when adding the <see cref="SymbolicReference"/></param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing reference, false otherwise.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual SymbolicReference Add(string name, Reference targetRef, string logMessage, bool allowOverwrite)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");
            Ensure.ArgumentNotNull(targetRef, "targetRef");

            using (ReferenceHandle handle = Proxy.git_reference_symbolic_create(repo.Handle,
                                                                                    name,
                                                                                    targetRef.CanonicalName,
                                                                                    allowOverwrite,
                                                                                    logMessage))
            {
                return (SymbolicReference)Reference.BuildFromPtr<Reference>(handle, repo);
            }
        }

        /// <summary>
        /// Creates a symbolic reference with the specified name and target
        /// </summary>
        /// <param name="name">The canonical name of the reference to create.</param>
        /// <param name="targetRef">The target reference.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual SymbolicReference Add(string name, Reference targetRef)
        {
            return Add(name, targetRef, null, false);
        }

        /// <summary>
        /// Creates a symbolic reference with the specified name and target
        /// </summary>
        /// <param name="name">The canonical name of the reference to create.</param>
        /// <param name="targetRef">The target reference.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing reference, false otherwise.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual SymbolicReference Add(string name, Reference targetRef, bool allowOverwrite)
        {
            return Add(name, targetRef, null, allowOverwrite);
        }

        /// <summary>
        /// Remove a reference with the specified name
        /// </summary>
        /// <param name="name">The canonical name of the reference to delete.</param>
        public virtual void Remove(string name)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");

            Reference reference = this[name];

            if (reference == null)
            {
                return;
            }

            Remove(reference);
        }

        /// <summary>
        /// Remove a reference from the repository
        /// </summary>
        /// <param name="reference">The reference to delete.</param>
        public virtual void Remove(Reference reference)
        {
            Ensure.ArgumentNotNull(reference, "reference");

            Proxy.git_reference_remove(repo.Handle, reference.CanonicalName);
        }

        /// <summary>
        /// Rename an existing reference with a new name, and update the reflog
        /// </summary>
        /// <param name="reference">The reference to rename.</param>
        /// <param name="newName">The new canonical name.</param>
        /// <param name="logMessage">Message added to the reflog.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference Rename(Reference reference, string newName, string logMessage)
        {
            return Rename(reference, newName, logMessage, false);
        }

        /// <summary>
        /// Rename an existing reference with a new name, and update the reflog
        /// </summary>
        /// <param name="reference">The reference to rename.</param>
        /// <param name="newName">The new canonical name.</param>
        /// <param name="logMessage">Message added to the reflog.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing reference, false otherwise.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference Rename(Reference reference, string newName, string logMessage, bool allowOverwrite)
        {
            Ensure.ArgumentNotNull(reference, "reference");
            Ensure.ArgumentNotNullOrEmptyString(newName, "newName");

            if (logMessage == null)
            {
                logMessage = string.Format(CultureInfo.InvariantCulture,
                                           "{0}: renamed {1} to {2}",
                                           reference.IsLocalBranch
                                               ? "branch"
                                               : "reference",
                                           reference.CanonicalName,
                                           newName);
            }

            using (ReferenceHandle referencePtr = RetrieveReferencePtr(reference.CanonicalName))
            using (ReferenceHandle handle = Proxy.git_reference_rename(referencePtr, newName, allowOverwrite, logMessage))
            {
                return Reference.BuildFromPtr<Reference>(handle, repo);
            }
        }

        /// <summary>
        /// Rename an existing reference with a new name
        /// </summary>
        /// <param name="currentName">The canonical name of the reference to rename.</param>
        /// <param name="newName">The new canonical name.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference Rename(string currentName, string newName)
        {
            return Rename(currentName, newName, null, false);
        }

        /// <summary>
        /// Rename an existing reference with a new name
        /// </summary>
        /// <param name="currentName">The canonical name of the reference to rename.</param>
        /// <param name="newName">The new canonical name.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing reference, false otherwise.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference Rename(string currentName, string newName,
            bool allowOverwrite)
        {
            return Rename(currentName, newName, null, allowOverwrite);
        }

        /// <summary>
        /// Rename an existing reference with a new name
        /// </summary>
        /// <param name="currentName">The canonical name of the reference to rename.</param>
        /// <param name="newName">The new canonical name.</param>
        /// <param name="logMessage">The optional message to log in the <see cref="ReflogCollection"/></param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference Rename(string currentName, string newName,
            string logMessage)
        {
            return Rename(currentName, newName, logMessage, false);
        }

        /// <summary>
        /// Rename an existing reference with a new name
        /// </summary>
        /// <param name="currentName">The canonical name of the reference to rename.</param>
        /// <param name="newName">The new canonical name.</param>
        /// <param name="logMessage">The optional message to log in the <see cref="ReflogCollection"/></param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing reference, false otherwise.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference Rename(string currentName, string newName,
            string logMessage, bool allowOverwrite)
        {
            Ensure.ArgumentNotNullOrEmptyString(currentName, "currentName");

            Reference reference = this[currentName];

            if (reference == null)
            {
                throw new LibGit2SharpException("Reference '{0}' doesn't exist. One cannot move a non existing reference.",
                    currentName);
            }

            return Rename(reference, newName, logMessage, allowOverwrite);
        }

        /// <summary>
        /// Rename an existing reference with a new name
        /// </summary>
        /// <param name="reference">The reference to rename.</param>
        /// <param name="newName">The new canonical name.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference Rename(Reference reference, string newName)
        {
            return Rename(reference, newName, null, false);
        }

        /// <summary>
        /// Rename an existing reference with a new name
        /// </summary>
        /// <param name="reference">The reference to rename.</param>
        /// <param name="newName">The new canonical name.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing reference, false otherwise.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference Rename(Reference reference, string newName, bool allowOverwrite)
        {
            return Rename(reference, newName, null, allowOverwrite);
        }

        internal T Resolve<T>(string name) where T : Reference
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");

            using (ReferenceHandle referencePtr = RetrieveReferencePtr(name, false))
            {
                return referencePtr == null
                    ? null
                    : Reference.BuildFromPtr<T>(referencePtr, repo);
            }
        }

        /// <summary>
        /// Updates the target of a direct reference.
        /// </summary>
        /// <param name="directRef">The direct reference which target should be updated.</param>
        /// <param name="targetId">The new target.</param>
        /// <param name="logMessage">The optional message to log in the <see cref="ReflogCollection"/> of the <paramref name="directRef"/> reference</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference UpdateTarget(Reference directRef, ObjectId targetId, string logMessage)
        {
            Ensure.ArgumentNotNull(directRef, "directRef");
            Ensure.ArgumentNotNull(targetId, "targetId");

            if (directRef.CanonicalName == "HEAD")
            {
                return UpdateHeadTarget(targetId, logMessage);
            }

            return UpdateDirectReferenceTarget(directRef, targetId, logMessage);
        }

        private Reference UpdateDirectReferenceTarget(Reference directRef, ObjectId targetId, string logMessage)
        {
            using (ReferenceHandle referencePtr = RetrieveReferencePtr(directRef.CanonicalName))
            using (ReferenceHandle handle = Proxy.git_reference_set_target(referencePtr, targetId, logMessage))
            {
                return Reference.BuildFromPtr<Reference>(handle, repo);
            }
        }

        /// <summary>
        /// Updates the target of a direct reference.
        /// </summary>
        /// <param name="directRef">The direct reference which target should be updated.</param>
        /// <param name="objectish">The revparse spec of the target.</param>
        /// <param name="logMessage">The optional message to log in the <see cref="ReflogCollection"/></param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference UpdateTarget(Reference directRef, string objectish, string logMessage)
        {
            Ensure.ArgumentNotNull(directRef, "directRef");
            Ensure.ArgumentNotNull(objectish, "objectish");

            GitObject target = repo.Lookup(objectish);

            Ensure.GitObjectIsNotNull(target, objectish);

            return UpdateTarget(directRef, target.Id, logMessage);
        }

        /// <summary>
        /// Updates the target of a direct reference
        /// </summary>
        /// <param name="directRef">The direct reference which target should be updated.</param>
        /// <param name="objectish">The revparse spec of the target.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference UpdateTarget(Reference directRef, string objectish)
        {
            return UpdateTarget(directRef, objectish, null);
        }

        /// <summary>
        /// Updates the target of a reference
        /// </summary>
        /// <param name="name">The canonical name of the reference.</param>
        /// <param name="canonicalRefNameOrObjectish">The target which can be either the canonical name of a reference or a revparse spec.</param>
        /// <param name="logMessage">The optional message to log in the <see cref="ReflogCollection"/> of the <paramref name="name"/> reference.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference UpdateTarget(string name, string canonicalRefNameOrObjectish, string logMessage)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");
            Ensure.ArgumentNotNullOrEmptyString(canonicalRefNameOrObjectish, "canonicalRefNameOrObjectish");

            if (name == "HEAD")
            {
                return UpdateHeadTarget(canonicalRefNameOrObjectish, logMessage);
            }

            Reference reference = this[name];

            var directReference = reference as DirectReference;
            if (directReference != null)
            {
                return UpdateTarget(directReference, canonicalRefNameOrObjectish, logMessage);
            }

            var symbolicReference = reference as SymbolicReference;
            if (symbolicReference != null)
            {
                Reference targetRef;

                RefState refState = TryResolveReference(out targetRef, this, canonicalRefNameOrObjectish);

                if (refState == RefState.DoesNotLookValid)
                {
                    throw new ArgumentException(String.Format(CultureInfo.InvariantCulture, "The reference specified by {0} is a Symbolic reference, you must provide a reference canonical name as the target.", name), "canonicalRefNameOrObjectish");
                }

                return UpdateTarget(symbolicReference, targetRef, logMessage);
            }

            throw new LibGit2SharpException("Reference '{0}' has an unexpected type ('{1}').",
                                            name,
                                            reference.GetType());
        }

        /// <summary>
        /// Updates the target of a reference
        /// </summary>
        /// <param name="name">The canonical name of the reference.</param>
        /// <param name="canonicalRefNameOrObjectish">The target which can be either the canonical name of a reference or a revparse spec.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference UpdateTarget(string name, string canonicalRefNameOrObjectish)
        {
            return UpdateTarget(name, canonicalRefNameOrObjectish, null);
        }

        /// <summary>
        /// Updates the target of a direct reference
        /// </summary>
        /// <param name="directRef">The direct reference which target should be updated.</param>
        /// <param name="targetId">The new target.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference UpdateTarget(Reference directRef, ObjectId targetId)
        {
            return UpdateTarget(directRef, targetId, null);
        }

        /// <summary>
        /// Updates the target of a symbolic reference
        /// </summary>
        /// <param name="symbolicRef">The symbolic reference which target should be updated.</param>
        /// <param name="targetRef">The new target.</param>
        /// <param name="logMessage">The optional message to log in the <see cref="ReflogCollection"/> of the <paramref name="symbolicRef"/> reference.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference UpdateTarget(Reference symbolicRef, Reference targetRef, string logMessage)
        {
            Ensure.ArgumentNotNull(symbolicRef, "symbolicRef");
            Ensure.ArgumentNotNull(targetRef, "targetRef");

            if (symbolicRef.CanonicalName == "HEAD")
            {
                return UpdateHeadTarget(targetRef, logMessage);
            }

            return UpdateSymbolicRefenceTarget(symbolicRef, targetRef, logMessage);
        }

        private Reference UpdateSymbolicRefenceTarget(Reference symbolicRef, Reference targetRef, string logMessage)
        {
            using (ReferenceHandle referencePtr = RetrieveReferencePtr(symbolicRef.CanonicalName))
            using (ReferenceHandle handle = Proxy.git_reference_symbolic_set_target(referencePtr, targetRef.CanonicalName, logMessage))
            {
                return Reference.BuildFromPtr<Reference>(handle, repo);
            }
        }

        /// <summary>
        /// Updates the target of a symbolic reference
        /// </summary>
        /// <param name="symbolicRef">The symbolic reference which target should be updated.</param>
        /// <param name="targetRef">The new target.</param>
        /// <returns>A new <see cref="Reference"/>.</returns>
        public virtual Reference UpdateTarget(Reference symbolicRef, Reference targetRef)
        {
            return UpdateTarget(symbolicRef, targetRef, null);
        }

        internal Reference MoveHeadTarget<T>(T target)
        {
            if (target is ObjectId)
            {
                Proxy.git_repository_set_head_detached(repo.Handle, target as ObjectId);
            }
            else if (target is DirectReference || target is SymbolicReference)
            {
                Proxy.git_repository_set_head(repo.Handle, (target as Reference).CanonicalName);
            }
            else if (target is string)
            {
                var targetIdentifier = target as string;

                if (Reference.IsValidName(targetIdentifier) && targetIdentifier.LooksLikeLocalBranch())
                {
                    Proxy.git_repository_set_head(repo.Handle, targetIdentifier);
                }
                else
                {
                    using (var annotatedCommit = Proxy.git_annotated_commit_from_revspec(repo.Handle, targetIdentifier))
                    {
                        Proxy.git_repository_set_head_detached_from_annotated(repo.Handle, annotatedCommit);
                    }
                }
            }
            else
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture,
                                                          "'{0}' is not a valid target type.",
                                                          typeof(T)));
            }

            return repo.Refs.Head;
        }

        internal Reference UpdateHeadTarget(ObjectId target, string logMessage)
        {
            Add("HEAD", target, logMessage, true);

            return repo.Refs.Head;
        }

        internal Reference UpdateHeadTarget(Reference target, string logMessage)
        {
            Ensure.ArgumentConformsTo(target, r => (r is DirectReference || r is SymbolicReference), "target");

            Add("HEAD", target, logMessage, true);

            return repo.Refs.Head;
        }

        internal Reference UpdateHeadTarget(string target, string logMessage)
        {
            this.Add("HEAD", target, logMessage, true);

            return repo.Refs.Head;
        }

        internal ReferenceHandle RetrieveReferencePtr(string referenceName, bool shouldThrowIfNotFound = true)
        {
            ReferenceHandle reference = Proxy.git_reference_lookup(repo.Handle, referenceName, shouldThrowIfNotFound);

            return reference;
        }

        /// <summary>
        /// Returns the list of references of the repository matching the specified <paramref name="pattern"/>.
        /// </summary>
        /// <param name="pattern">The glob pattern the reference name should match.</param>
        /// <returns>A list of references, ready to be enumerated.</returns>
        public virtual IEnumerable<Reference> FromGlob(string pattern)
        {
            Ensure.ArgumentNotNullOrEmptyString(pattern, "pattern");

            return Proxy.git_reference_foreach_glob(repo.Handle, pattern, LaxUtf8Marshaler.FromNative)
                .Select(n => this[n]);
        }

        /// <summary>
        /// Shortcut to return the HEAD reference.
        /// </summary>
        /// <returns>
        /// A <see cref="DirectReference"/> if the HEAD is detached;
        /// otherwise a <see cref="SymbolicReference"/>.
        /// </returns>
        public virtual Reference Head
        {
            get { return this["HEAD"]; }
        }

        /// <summary>
        /// Find the <see cref="Reference"/>s among <paramref name="refSubset"/>
        /// that can reach at least one <see cref="Commit"/> in the specified <paramref name="targets"/>.
        /// </summary>
        /// <param name="refSubset">The set of <see cref="Reference"/>s to examine.</param>
        /// <param name="targets">The set of <see cref="Commit"/>s that are interesting.</param>
        /// <returns>A subset of <paramref name="refSubset"/> that can reach at least one <see cref="Commit"/> within <paramref name="targets"/>.</returns>
        public virtual IEnumerable<Reference> ReachableFrom(
            IEnumerable<Reference> refSubset,
            IEnumerable<Commit> targets)
        {
            Ensure.ArgumentNotNull(refSubset, "refSubset");
            Ensure.ArgumentNotNull(targets, "targets");

            var refs = new List<Reference>(refSubset);
            if (refs.Count == 0)
            {
                return Enumerable.Empty<Reference>();
            }

            List<ObjectId> targetsSet = targets.Select(c => c.Id).Distinct().ToList();
            if (targetsSet.Count == 0)
            {
                return Enumerable.Empty<Reference>();
            }

            var result = new List<Reference>();

            foreach (var reference in refs)
            {
                var peeledTargetCommit = reference
                                            .ResolveToDirectReference()
                                            .Target.Peel<Commit>(false);

                if (peeledTargetCommit == null)
                {
                    continue;
                }

                var commitId = peeledTargetCommit.Id;

                foreach (var potentialAncestorId in targetsSet)
                {
                    if (potentialAncestorId == commitId)
                    {
                        result.Add(reference);
                        break;
                    }

                    if (Proxy.git_graph_descendant_of(repo.Handle, commitId, potentialAncestorId))
                    {
                        result.Add(reference);
                        break;
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Find the <see cref="Reference"/>s
        /// that can reach at least one <see cref="Commit"/> in the specified <paramref name="targets"/>.
        /// </summary>
        /// <param name="targets">The set of <see cref="Commit"/>s that are interesting.</param>
        /// <returns>The list of <see cref="Reference"/> that can reach at least one <see cref="Commit"/> within <paramref name="targets"/>.</returns>
        public virtual IEnumerable<Reference> ReachableFrom(IEnumerable<Commit> targets)
        {
            return ReachableFrom(this, targets);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "Count = {0}", this.Count());
            }
        }

        /// <summary>
        /// Returns as a <see cref="ReflogCollection"/> the reflog of the <see cref="Reference"/> named <paramref name="canonicalName"/>
        /// </summary>
        /// <param name="canonicalName">The canonical name of the reference</param>
        /// <returns>a <see cref="ReflogCollection"/>, enumerable of <see cref="ReflogEntry"/></returns>
        public virtual ReflogCollection Log(string canonicalName)
        {
            Ensure.ArgumentNotNullOrEmptyString(canonicalName, "canonicalName");

            return new ReflogCollection(repo, canonicalName);
        }

        /// <summary>
        /// Returns as a <see cref="ReflogCollection"/> the reflog of the <see cref="Reference"/> <paramref name="reference"/>
        /// </summary>
        /// <param name="reference">The reference</param>
        /// <returns>a <see cref="ReflogCollection"/>, enumerable of <see cref="ReflogEntry"/></returns>
        public virtual ReflogCollection Log(Reference reference)
        {
            Ensure.ArgumentNotNull(reference, "reference");

            return new ReflogCollection(repo, reference.CanonicalName);
        }

        /// <summary>
        /// Rewrite some of the commits in the repository and all the references that can reach them.
        /// </summary>
        /// <param name="options">Specifies behavior for this rewrite.</param>
        /// <param name="commitsToRewrite">The <see cref="Commit"/> objects to rewrite.</param>
        public virtual void RewriteHistory(RewriteHistoryOptions options, params Commit[] commitsToRewrite)
        {
            Ensure.ArgumentNotNull(commitsToRewrite, "commitsToRewrite");

            RewriteHistory(options, commitsToRewrite.AsEnumerable());
        }

        /// <summary>
        /// Rewrite some of the commits in the repository and all the references that can reach them.
        /// </summary>
        /// <param name="options">Specifies behavior for this rewrite.</param>
        /// <param name="commitsToRewrite">The <see cref="Commit"/> objects to rewrite.</param>
        public virtual void RewriteHistory(RewriteHistoryOptions options, IEnumerable<Commit> commitsToRewrite)
        {
            Ensure.ArgumentNotNull(commitsToRewrite, "commitsToRewrite");
            Ensure.ArgumentNotNull(options, "options");
            Ensure.ArgumentNotNullOrEmptyString(options.BackupRefsNamespace, "options.BackupRefsNamespace");

            IList<Reference> originalRefs = this.ToList();
            if (originalRefs.Count == 0)
            {
                // Nothing to do
                return;
            }

            var historyRewriter = new HistoryRewriter(repo, commitsToRewrite, options);

            historyRewriter.Execute();
        }

        /// <summary>
        /// Ensure that a reflog exists for the given canonical name
        /// </summary>
        /// <param name="canonicalName">Canonical name of the reference</param>
        internal void EnsureHasLog(string canonicalName)
        {
            Proxy.git_reference_ensure_log(repo.Handle, canonicalName);
        }
    }

    /// <summary>
    /// Provides helpers to a <see cref="Reference"/>.
    /// </summary>
    internal static class ReferenceExtensions
    {
        internal static bool LooksLikeLocalBranch(this string canonicalName)
        {
            return canonicalName.IsPrefixedBy(Reference.LocalBranchPrefix);
        }

        internal static bool LooksLikeRemoteTrackingBranch(this string canonicalName)
        {
            return canonicalName.IsPrefixedBy(Reference.RemoteTrackingBranchPrefix);
        }

        internal static bool LooksLikeTag(this string canonicalName)
        {
            return canonicalName.IsPrefixedBy(Reference.TagPrefix);
        }

        internal static bool LooksLikeNote(this string canonicalName)
        {
            return canonicalName.IsPrefixedBy(Reference.NotePrefix);
        }

        private static bool IsPrefixedBy(this string input, string prefix)
        {
            return input.StartsWith(prefix, StringComparison.Ordinal);
        }
    }

    /// <summary>
    /// A base class for things that wrap a <see cref="Reference"/> (branch, tag, etc).
    /// </summary>
    /// <typeparam name="TObject">The type of the referenced Git object.</typeparam>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public abstract class ReferenceWrapper<TObject> : IEquatable<ReferenceWrapper<TObject>>, IBelongToARepository where TObject : GitObject
    {
        /// <summary>
        /// The repository.
        /// </summary>
        protected readonly Repository repo;
        private readonly Reference reference;
        private readonly Lazy<TObject> objectBuilder;

        private static readonly LambdaEqualityHelper<ReferenceWrapper<TObject>> equalityHelper =
            new LambdaEqualityHelper<ReferenceWrapper<TObject>>(x => x.CanonicalName, x => x.reference.TargetIdentifier);

        private readonly string canonicalName;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected ReferenceWrapper()
        { }

        /// <param name="repo">The repository.</param>
        /// <param name="reference">The reference.</param>
        /// <param name="canonicalNameSelector">A function to construct the reference's canonical name.</param>
        protected internal ReferenceWrapper(Repository repo, Reference reference, Func<Reference, string> canonicalNameSelector)
        {
            Ensure.ArgumentNotNull(repo, "repo");
            Ensure.ArgumentNotNull(reference, "reference");
            Ensure.ArgumentNotNull(canonicalNameSelector, "canonicalNameSelector");

            this.repo = repo;
            canonicalName = canonicalNameSelector(reference);
            this.reference = reference;
            objectBuilder = new Lazy<TObject>(() => RetrieveTargetObject(reference));
        }

        /// <summary>
        /// Gets the full name of this reference.
        /// </summary>
        public virtual string CanonicalName
        {
            get { return canonicalName; }
        }

        /// <summary>
        /// Gets the human-friendly name of this reference.
        /// </summary>
        public virtual string FriendlyName
        {
            get { return Shorten(); }
        }

        /// <summary>
        /// The underlying <see cref="Reference"/>
        /// </summary>
        public virtual Reference Reference
        {
            get
            {
                return reference;
            }
        }

        /// <summary>
        /// Returns the <see cref="CanonicalName"/>, a <see cref="string"/> representation of the current reference.
        /// </summary>
        /// <returns>The <see cref="CanonicalName"/> that represents the current reference.</returns>
        public override string ToString()
        {
            return CanonicalName;
        }

        /// <summary>
        /// Gets the <typeparamref name="TObject"/> this <see cref="ReferenceWrapper{TObject}"/> points to.
        /// </summary>
        protected TObject TargetObject
        {
            get { return objectBuilder.Value; }
        }

        /// <summary>
        /// Removes redundent leading namespaces (regarding the kind of
        /// reference being wrapped) from the canonical name.
        /// </summary>
        /// <returns>The friendly shortened name</returns>
        protected abstract string Shorten();

        private TObject RetrieveTargetObject(Reference reference)
        {
            var directReference = reference.ResolveToDirectReference();
            if (directReference == null)
            {
                return null;
            }

            var target = directReference.Target;
            if (target == null)
            {
                return null;
            }

            return repo.Lookup<TObject>(target.Id);
        }

        /// <summary>
        /// Determines whether the specified <see cref="ReferenceWrapper{TObject}"/> is equal to the current <see cref="ReferenceWrapper{TObject}"/>.
        /// </summary>
        /// <param name="other">The <see cref="ReferenceWrapper{TObject}"/> to compare with the current <see cref="ReferenceWrapper{TObject}"/>.</param>
        /// <returns>True if the specified <see cref="ReferenceWrapper{TObject}"/> is equal to the current <see cref="ReferenceWrapper{TObject}"/>; otherwise, false.</returns>
        public bool Equals(ReferenceWrapper<TObject> other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="ReferenceWrapper{TObject}"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="ReferenceWrapper{TObject}"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="ReferenceWrapper{TObject}"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as ReferenceWrapper<TObject>);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="ReferenceWrapper{TObject}"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="ReferenceWrapper{TObject}"/> to compare.</param>
        /// <param name="right">Second <see cref="ReferenceWrapper{TObject}"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(ReferenceWrapper<TObject> left, ReferenceWrapper<TObject> right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="ReferenceWrapper{TObject}"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="ReferenceWrapper{TObject}"/> to compare.</param>
        /// <param name="right">Second <see cref="ReferenceWrapper{TObject}"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(ReferenceWrapper<TObject> left, ReferenceWrapper<TObject> right)
        {
            return !Equals(left, right);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0} => \"{1}\"", CanonicalName,
                                     (TargetObject != null)
                                        ? TargetObject.Id.ToString(7)
                                        : "?");
            }
        }

        IRepository IBelongToARepository.Repository { get { return repo; } }
    }

    /// <summary>
    /// The <see cref="ReflogCollection"/> is the reflog of a given <see cref="Reference"/>, as a enumerable of <see cref="ReflogEntry"/>.
    /// Reflog is a mechanism to record when the tip of a <see cref="Branch"/> is updated.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class ReflogCollection : IEnumerable<ReflogEntry>
    {
        internal readonly Repository repo;

        private readonly string canonicalName;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected ReflogCollection()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReflogCollection"/> class.
        /// </summary>
        /// <param name="repo">The repo.</param>
        /// <param name="canonicalName">the canonical name of the <see cref="Reference"/> to retrieve reflog entries on.</param>
        internal ReflogCollection(Repository repo, string canonicalName)
        {
            Ensure.ArgumentNotNullOrEmptyString(canonicalName, "canonicalName");
            Ensure.ArgumentNotNull(repo, "repo");

            if (!Reference.IsValidName(canonicalName))
            {
                throw new InvalidSpecificationException("The given reference name '{0}' is not valid", canonicalName);
            }

            this.repo = repo;
            this.canonicalName = canonicalName;
        }

        #region Implementation of IEnumerable

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// <para>
        ///   The enumerator returns the <see cref="ReflogEntry"/> by descending order (last reflog entry is returned first).
        /// </para>
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual unsafe IEnumerator<ReflogEntry> GetEnumerator()
        {
            var entries = new List<ReflogEntry>();

            using (ReflogHandle reflog = Proxy.git_reflog_read(repo.Handle, canonicalName))
            {
                var entriesCount = Proxy.git_reflog_entrycount(reflog);

                for (int i = 0; i < entriesCount; i++)
                {
                    git_reflog_entry* handle = Proxy.git_reflog_entry_byindex(reflog, i);
                    entries.Add(new ReflogEntry(handle));
                }
            }

            return entries.GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "Count = {0}", this.Count());
            }
        }
    }

    /// <summary>
    /// As single entry of a <see cref="ReflogCollection"/>
    /// a <see cref="ReflogEntry"/> describes one single update on a particular reference
    /// </summary>
    public class ReflogEntry
    {
        private readonly ObjectId _from;
        private readonly ObjectId _to;
        private readonly Signature _committer;
        private readonly string message;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected ReflogEntry()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReflogEntry"/> class.
        /// </summary>
        /// <param name="entryHandle">a <see cref="SafeHandle"/> to the reflog entry</param>
        internal unsafe ReflogEntry(git_reflog_entry* entryHandle)
        {
            _from = Proxy.git_reflog_entry_id_old(entryHandle);
            _to = Proxy.git_reflog_entry_id_new(entryHandle);
            _committer = Proxy.git_reflog_entry_committer(entryHandle);
            message = Proxy.git_reflog_entry_message(entryHandle);
        }

        /// <summary>
        /// <see cref="ObjectId"/> targeted before the reference update described by this <see cref="ReflogEntry"/>
        /// </summary>
        public virtual ObjectId From
        {
            get { return _from; }
        }

        /// <summary>
        /// <see cref="ObjectId"/> targeted after the reference update described by this <see cref="ReflogEntry"/>
        /// </summary>
        public virtual ObjectId To
        {
            get { return _to; }
        }

        /// <summary>
        /// <see cref="Signature"/> of the committer of this reference update
        /// </summary>
        public virtual Signature Committer
        {
            get { return _committer; }
        }

        /// <summary>
        /// the message assiocated to this reference update
        /// </summary>
        public virtual string Message
        {
            get { return message; }
        }
    }

    /// <summary>
    /// A push or fetch reference specification
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class RefSpec
    {
        // This is here to keep the pointer alive
        #pragma warning disable 0414
        readonly Remote remote;
        #pragma warning restore 0414
        readonly IntPtr handle;

        internal unsafe RefSpec(Remote remote, git_refspec* handle)
        {
            this.remote = remote;
            this.handle = new IntPtr(handle);
        }

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected RefSpec()
        { }

        /// <summary>
        /// Gets the pattern describing the mapping between remote and local references
        /// </summary>
        public virtual string Specification
        {
            get
            {
                return Proxy.git_refspec_string(this.handle);
            }
        }

        /// <summary>
        /// Indicates whether this <see cref="RefSpec"/> is intended to be used during a Push or Fetch operation
        /// </summary>
        public virtual RefSpecDirection Direction
        {
            get
            {
                return Proxy.git_refspec_direction(this.handle);
            }
        }

        /// <summary>
        /// The source reference specifier
        /// </summary>
        public virtual string Source
        {
            get
            {
                return Proxy.git_refspec_src(this.handle);
            }
        }

        /// <summary>
        /// The target reference specifier
        /// </summary>
        public virtual string Destination
        {
            get
            {
                return Proxy.git_refspec_dst(this.handle);
            }
        }

        /// <summary>
        /// Indicates whether the destination will be force-updated if fast-forwarding is not possible
        /// </summary>
        public virtual bool ForceUpdate
        {
            get
            {
                return Proxy.git_refspec_force(this.handle);
            }
        }

        /// <summary>
        /// Check whether the given reference matches the source (lhs) part of
        /// this refspec.
        /// </summary>
        /// <param name="reference">The reference name to check</param>
        public virtual bool SourceMatches(string reference)
        {
            return Proxy.git_refspec_src_matches(handle, reference);
        }

        /// <summary>
        /// Check whether the given reference matches the target (rhs) part of
        /// this refspec.
        /// </summary>
        /// <param name="reference">The reference name to check</param>
        public virtual bool DestinationMatches(string reference)
        {
            return Proxy.git_refspec_dst_matches(handle, reference);
        }

        /// <summary>
        /// Perform the transformation described by this refspec on the given
        /// reference name (from source to destination).
        /// </summary>
        /// <param name="reference">The reference name to transform</param>
        public virtual string Transform(string reference)
        {
            return Proxy.git_refspec_transform(handle, reference);
        }

        /// <summary>
        /// Perform the reverse of the transformation described by this refspec
        /// on the given reference name (from destination to source).
        /// </summary>
        /// <param name="reference">The reference name to transform</param>
        public virtual string ReverseTransform(string reference)
        {
            return Proxy.git_refspec_rtransform(handle, reference);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "{0}", Specification);
            }
        }
    }

    /// <summary>
    /// The collection of <see cref="RefSpec"/>s in a <see cref="Remote"/>
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class RefSpecCollection : IEnumerable<RefSpec>
    {
        // These are here to keep the pointer alive
        #pragma warning disable 0414
        readonly Remote remote;
        readonly RemoteHandle handle;
        #pragma warning restore 0414
        readonly Lazy<IList<RefSpec>> refspecs;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected RefSpecCollection()
        { }

        internal RefSpecCollection(Remote remote, RemoteHandle handle)
        {
            Ensure.ArgumentNotNull(handle, "handle");

            this.remote = remote;
            this.handle = handle;

            refspecs = new Lazy<IList<RefSpec>>(() => RetrieveRefSpecs(remote, handle));
        }

        static unsafe IList<RefSpec> RetrieveRefSpecs(Remote remote, RemoteHandle remoteHandle)
        {
            int count = Proxy.git_remote_refspec_count(remoteHandle);
            List<RefSpec> refSpecs = new List<RefSpec>();

            for (int i = 0; i < count; i++)
            {
                refSpecs.Add(new RefSpec(remote, Proxy.git_remote_get_refspec(remoteHandle, i)));
            }

            return refSpecs;
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<RefSpec> GetEnumerator()
        {
            return refspecs.Value.GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "Count = {0}", this.Count());
            }
        }
    }

    /// <summary>
    /// Indicates whether a refspec is a push refspec or a fetch refspec
    /// </summary>
    public enum RefSpecDirection
    {
        /// <summary>
        /// Indicates that the refspec is a fetch refspec
        /// </summary>
        Fetch,

        /// <summary>
        /// Indicates that the refspec is a push refspec
        /// </summary>
        Push
    }

    /// <summary>
    /// A remote repository whose branches are tracked.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class Remote : IBelongToARepository, IDisposable
    {
        internal readonly Repository repository;

        private readonly RefSpecCollection refSpecs;

        readonly RemoteHandle handle;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Remote()
        { }

        internal Remote(RemoteHandle handle, Repository repository)
        {
            this.repository = repository;
            this.handle = handle;
            refSpecs = new RefSpecCollection(this, handle);
            repository.RegisterForCleanup(this);
        }

        /// <summary>
        /// The finalizer for the <see cref="Remote"/> class.
        /// </summary>
        ~Remote()
        {
            Dispose(false);
        }

        #region IDisposable

        bool disposedValue = false; // To detect redundant calls

        /// <summary>
        /// Release the unmanaged remote object
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (handle != null)
                {
                    handle.Dispose();
                }

                disposedValue = true;
            }
        }

        #endregion

        /// <summary>
        /// Gets the alias of this remote repository.
        /// </summary>
        public virtual string Name
        {
            get { return Proxy.git_remote_name(handle); }
        }

        /// <summary>
        /// Gets the url to use to communicate with this remote repository.
        /// </summary>
        public virtual string Url
        {
            get { return Proxy.git_remote_url(handle); } }

        /// <summary>
        /// Gets the distinct push url for this remote repository, if set.
        /// Defaults to the fetch url (<see cref="Url"/>) if not set.
        /// </summary>
        public virtual string PushUrl
        {
            get { return Proxy.git_remote_pushurl(handle) ?? Url; }
        }

        /// <summary>
        /// Gets the Tag Fetch Mode of the remote - indicating how tags are fetched.
        /// </summary>
        public virtual TagFetchMode TagFetchMode
        {
            get { return Proxy.git_remote_autotag(handle); }
        }

        /// <summary>
        /// Gets the list of <see cref="RefSpec"/>s defined for this <see cref="Remote"/>
        /// </summary>
        public virtual IEnumerable<RefSpec> RefSpecs { get { return refSpecs; } }

        /// <summary>
        /// Gets the list of <see cref="RefSpec"/>s defined for this <see cref="Remote"/>
        /// that are intended to be used during a Fetch operation
        /// </summary>
        public virtual IEnumerable<RefSpec> FetchRefSpecs
        {
            get { return refSpecs.Where(r => r.Direction == RefSpecDirection.Fetch); }
        }

        /// <summary>
        /// Gets the list of <see cref="RefSpec"/>s defined for this <see cref="Remote"/>
        /// that are intended to be used during a Push operation
        /// </summary>
        public virtual IEnumerable<RefSpec> PushRefSpecs
        {
            get { return refSpecs.Where(r => r.Direction == RefSpecDirection.Push); }
        }

        /// <summary>
        /// Transform a reference to its source reference using the <see cref="Remote"/>'s default fetchspec.
        /// </summary>
        /// <param name="reference">The reference to transform.</param>
        /// <returns>The transformed reference.</returns>
        internal unsafe string FetchSpecTransformToSource(string reference)
        {
            using (RemoteHandle remoteHandle = Proxy.git_remote_lookup(repository.Handle, Name, true))
            {
                git_refspec* fetchSpecPtr = Proxy.git_remote_get_refspec(remoteHandle, 0);
                return Proxy.git_refspec_rtransform(new IntPtr(fetchSpecPtr), reference);
            }
        }

        /// <summary>
        /// Determines if the proposed remote name is well-formed.
        /// </summary>
        /// <param name="name">The name to be checked.</param>
        /// <returns>true if the name is valid; false otherwise.</returns>
        public static bool IsValidName(string name)
        {
            return Proxy.git_remote_is_valid_name(name);
        }

        /// <summary>
        /// Gets the configured behavior regarding the deletion
        /// of stale remote tracking branches.
        /// <para>
        ///   If defined, will return the value of the <code>remote.&lt;name&gt;.prune</code> entry.
        ///   Otherwise return the value of <code>fetch.prune</code>.
        /// </para>
        /// </summary>
        public virtual bool AutomaticallyPruneOnFetch
        {
            get
            {
                var remotePrune = repository.Config.Get<bool>("remote", Name, "prune");

                if (remotePrune != null)
                {
                    return remotePrune.Value;
                }

                var fetchPrune = repository.Config.Get<bool>("fetch.prune");

                return fetchPrune != null && fetchPrune.Value;
            }
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "{0} => {1}", Name, Url);
            }
        }

        IRepository IBelongToARepository.Repository { get { return repository; } }
    }

    /// <summary>
    /// Class to translate libgit2 callbacks into delegates exposed by LibGit2Sharp.
    /// Handles generating libgit2 git_remote_callbacks datastructure given a set
    /// of LibGit2Sharp delegates and handles propagating libgit2 callbacks into
    /// corresponding LibGit2Sharp exposed delegates.
    /// </summary>
    internal class RemoteCallbacks
    {
        internal RemoteCallbacks(CredentialsHandler credentialsProvider)
        {
            CredentialsProvider = credentialsProvider;
        }

        internal RemoteCallbacks(PushOptions pushOptions)
        {
            if (pushOptions == null)
            {
                return;
            }

            PushTransferProgress = pushOptions.OnPushTransferProgress;
            PackBuilderProgress = pushOptions.OnPackBuilderProgress;
            CredentialsProvider = pushOptions.CredentialsProvider;
            CertificateCheck = pushOptions.CertificateCheck;
            PushStatusError = pushOptions.OnPushStatusError;
            PrePushCallback = pushOptions.OnNegotiationCompletedBeforePush;
        }

        internal RemoteCallbacks(FetchOptionsBase fetchOptions)
        {
            if (fetchOptions == null)
            {
                return;
            }

            Progress = fetchOptions.OnProgress;
            DownloadTransferProgress = fetchOptions.OnTransferProgress;
            UpdateTips = fetchOptions.OnUpdateTips;
            CredentialsProvider = fetchOptions.CredentialsProvider;
            CertificateCheck = fetchOptions.CertificateCheck;
        }

        #region Delegates

        /// <summary>
        /// Progress callback. Corresponds to libgit2 progress callback.
        /// </summary>
        private readonly ProgressHandler Progress;

        /// <summary>
        /// UpdateTips callback. Corresponds to libgit2 update_tips callback.
        /// </summary>
        private readonly UpdateTipsHandler UpdateTips;

        /// <summary>
        /// PushStatusError callback. It will be called when the libgit2 push_update_reference returns a non null status message,
        /// which means that the update was rejected by the remote server.
        /// </summary>
        private readonly PushStatusErrorHandler PushStatusError;

        /// <summary>
        /// Managed delegate to be called in response to a git_transfer_progress_callback callback from libgit2.
        /// This will in turn call the user provided delegate.
        /// </summary>
        private readonly TransferProgressHandler DownloadTransferProgress;

        /// <summary>
        /// Push transfer progress callback.
        /// </summary>
        private readonly PushTransferProgressHandler PushTransferProgress;

        /// <summary>
        /// Pack builder creation progress callback.
        /// </summary>
        private readonly PackBuilderProgressHandler PackBuilderProgress;

        /// <summary>
        /// Called during remote push operation after negotiation, before upload
        /// </summary>
        private readonly PrePushHandler PrePushCallback;

        #endregion

        /// <summary>
        /// The credentials to use for authentication.
        /// </summary>
        private readonly CredentialsHandler CredentialsProvider;

        /// <summary>
        /// Callback to perform validation on the certificate
        /// </summary>
        private readonly CertificateCheckHandler CertificateCheck;

        internal unsafe GitRemoteCallbacks GenerateCallbacks()
        {
            var callbacks = new GitRemoteCallbacks { version = 1 };

            if (Progress != null)
            {
                callbacks.progress = GitProgressHandler;
            }

            if (UpdateTips != null)
            {
                callbacks.update_tips = GitUpdateTipsHandler;
            }

            if (PushStatusError != null)
            {
                callbacks.push_update_reference = GitPushUpdateReference;
            }

            if (CredentialsProvider != null)
            {
                callbacks.acquire_credentials = GitCredentialHandler;
            }

            if (CertificateCheck != null)
            {
                callbacks.certificate_check = GitCertificateCheck;
            }

            if (DownloadTransferProgress != null)
            {
                callbacks.download_progress = GitDownloadTransferProgressHandler;
            }

            if (PushTransferProgress != null)
            {
                callbacks.push_transfer_progress = GitPushTransferProgressHandler;
            }

            if (PackBuilderProgress != null)
            {
                callbacks.pack_progress = GitPackbuilderProgressHandler;
            }

            if (PrePushCallback != null)
            {
                callbacks.push_negotiation = GitPushNegotiationHandler;
            }

            return callbacks;
        }

        #region Handlers to respond to callbacks raised by libgit2

        /// <summary>
        /// Handler for libgit2 Progress callback. Converts values
        /// received from libgit2 callback to more suitable types
        /// and calls delegate provided by LibGit2Sharp consumer.
        /// </summary>
        /// <param name="str">IntPtr to string from libgit2</param>
        /// <param name="len">length of string</param>
        /// <param name="data">IntPtr to optional payload passed back to the callback.</param>
        /// <returns>0 on success; a negative value to abort the process.</returns>
        private int GitProgressHandler(IntPtr str, int len, IntPtr data)
        {
            ProgressHandler onProgress = Progress;

            bool shouldContinue = true;

            if (onProgress != null)
            {
                string message = LaxUtf8Marshaler.FromNative(str, len);
                shouldContinue = onProgress(message);
            }

            return Proxy.ConvertResultToCancelFlag(shouldContinue);
        }

        /// <summary>
        /// Handler for libgit2 update_tips callback. Converts values
        /// received from libgit2 callback to more suitable types
        /// and calls delegate provided by LibGit2Sharp consumer.
        /// </summary>
        /// <param name="str">IntPtr to string</param>
        /// <param name="oldId">Old reference ID</param>
        /// <param name="newId">New referene ID</param>
        /// <param name="data">IntPtr to optional payload passed back to the callback.</param>
        /// <returns>0 on success; a negative value to abort the process.</returns>
        private int GitUpdateTipsHandler(IntPtr str, ref GitOid oldId, ref GitOid newId, IntPtr data)
        {
            UpdateTipsHandler onUpdateTips = UpdateTips;
            bool shouldContinue = true;

            if (onUpdateTips != null)
            {
                string refName = LaxUtf8Marshaler.FromNative(str);
                shouldContinue = onUpdateTips(refName, oldId, newId);
            }

            return Proxy.ConvertResultToCancelFlag(shouldContinue);
        }

        /// <summary>
        /// The delegate with the signature that matches the native push_update_reference function's signature
        /// </summary>
        /// <param name="str">IntPtr to string, the name of the reference</param>
        /// <param name="status">IntPtr to string, the update status message</param>
        /// <param name="data">IntPtr to optional payload passed back to the callback.</param>
        /// <returns>0 on success; a negative value to abort the process.</returns>
        private int GitPushUpdateReference(IntPtr str, IntPtr status, IntPtr data)
        {
            PushStatusErrorHandler onPushError = PushStatusError;

            if (onPushError != null)
            {
                string reference = LaxUtf8Marshaler.FromNative(str);
                string message = LaxUtf8Marshaler.FromNative(status);
                if (message != null)
                {
                    onPushError(new PushStatusError(reference, message));
                }
            }

            return Proxy.ConvertResultToCancelFlag(true);
        }

        /// <summary>
        /// The delegate with the signature that matches the native git_transfer_progress_callback function's signature.
        /// </summary>
        /// <param name="progress"><see cref="GitTransferProgress"/> structure containing progress information.</param>
        /// <param name="payload">Payload data.</param>
        /// <returns>the result of the wrapped <see cref="TransferProgressHandler"/></returns>
        private int GitDownloadTransferProgressHandler(ref GitTransferProgress progress, IntPtr payload)
        {
            bool shouldContinue = true;

            if (DownloadTransferProgress != null)
            {
                shouldContinue = DownloadTransferProgress(new TransferProgress(progress));
            }

            return Proxy.ConvertResultToCancelFlag(shouldContinue);
        }

        private int GitPushTransferProgressHandler(uint current, uint total, UIntPtr bytes, IntPtr payload)
        {
            bool shouldContinue = true;

            if (PushTransferProgress != null)
            {
                shouldContinue = PushTransferProgress((int)current, (int)total, (long)bytes);
            }

            return Proxy.ConvertResultToCancelFlag(shouldContinue);
        }

        private int GitPackbuilderProgressHandler(int stage, uint current, uint total, IntPtr payload)
        {
            bool shouldContinue = true;

            if (PackBuilderProgress != null)
            {
                shouldContinue = PackBuilderProgress((PackBuilderStage)stage, (int)current, (int)total);
            }

            return Proxy.ConvertResultToCancelFlag(shouldContinue);
        }

        private int GitCredentialHandler(
            out IntPtr ptr,
            IntPtr cUrl,
            IntPtr usernameFromUrl,
            GitCredentialType credTypes,
            IntPtr payload)
        {
            string url = LaxUtf8Marshaler.FromNative(cUrl);
            string username = LaxUtf8Marshaler.FromNative(usernameFromUrl);

            SupportedCredentialTypes types = default(SupportedCredentialTypes);
            if (credTypes.HasFlag(GitCredentialType.UserPassPlaintext))
            {
                types |= SupportedCredentialTypes.UsernamePassword;
            }
            if (credTypes.HasFlag(GitCredentialType.Default))
            {
                types |= SupportedCredentialTypes.Default;
            }

            ptr = IntPtr.Zero;
            try
            {
                var cred = CredentialsProvider(url, username, types);
                if (cred == null)
                {
                    return (int)GitErrorCode.PassThrough;
                }
                return cred.GitCredentialHandler(out ptr);
            }
            catch (Exception exception)
            {
                Proxy.git_error_set_str(GitErrorCategory.Callback, exception);
                return (int)GitErrorCode.Error;
            }
        }

        private unsafe int GitCertificateCheck(git_certificate* certPtr, int valid, IntPtr cHostname, IntPtr payload)
        {
            string hostname = LaxUtf8Marshaler.FromNative(cHostname);
            Certificate cert = null;

            switch (certPtr->type)
            {
                case GitCertificateType.X509:
                    cert = new CertificateX509((git_certificate_x509*) certPtr);
                    break;
                case GitCertificateType.Hostkey:
                    cert = new CertificateSsh((git_certificate_ssh*) certPtr);
                    break;
            }

            bool result = false;
            try
            {
                result = CertificateCheck(cert, valid != 0, hostname);
            }
            catch (Exception exception)
            {
                Proxy.git_error_set_str(GitErrorCategory.Callback, exception);
            }

            return Proxy.ConvertResultToCancelFlag(result);
        }

        private int GitPushNegotiationHandler(IntPtr updates, UIntPtr len, IntPtr payload)
        {
            if (updates == IntPtr.Zero)
            {
                return (int)GitErrorCode.Error;
            }

            bool result = false;
            try
            {

                int length = len.ConvertToInt();
                PushUpdate[] pushUpdates = new PushUpdate[length];

                unsafe
                {
                    IntPtr* ptr = (IntPtr*)updates.ToPointer();

                    for (int i = 0; i < length; i++)
                    {
                        if (ptr[i] == IntPtr.Zero)
                        {
                            throw new NullReferenceException("Unexpected null git_push_update pointer was encountered");
                        }

                        PushUpdate pushUpdate = new PushUpdate((git_push_update*) ptr[i].ToPointer());
                        pushUpdates[i] = pushUpdate;
                    }

                    result = PrePushCallback(pushUpdates);
                }
            }
            catch (Exception exception)
            {
                Log.Write(LogLevel.Error, exception.ToString());
                Proxy.git_error_set_str(GitErrorCategory.Callback, exception);
                result = false;
            }

            return Proxy.ConvertResultToCancelFlag(result);
        }

        #endregion
    }

    /// <summary>
    /// The collection of <see cref="Remote"/> in a <see cref="Repository"/>
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class RemoteCollection : IEnumerable<Remote>
    {
        private readonly Repository repository;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected RemoteCollection()
        { }

        internal RemoteCollection(Repository repository)
        {
            this.repository = repository;
        }

        /// <summary>
        /// Gets the <see cref="Remote"/> with the specified name.
        /// </summary>
        /// <param name="name">The name of the remote to retrieve.</param>
        /// <returns>The retrived <see cref="Remote"/> if it has been found, null otherwise.</returns>
        public virtual Remote this[string name]
        {
            get { return RemoteForName(name, false); }
        }

        internal Remote RemoteForName(string name, bool shouldThrowIfNotFound = true)
        {
            Ensure.ArgumentNotNull(name, "name");

            RemoteHandle handle = Proxy.git_remote_lookup(repository.Handle, name, shouldThrowIfNotFound);
            return handle == null ? null : new Remote(handle, this.repository);
        }

        /// <summary>
        /// Update properties of a remote.
        ///
        /// These updates will be performed as a bulk update at the end of the method.
        /// </summary>
        /// <param name="remote">The name of the remote to update.</param>
        /// <param name="actions">Delegate to perform updates on the remote.</param>
        public virtual void Update(string remote, params Action<RemoteUpdater>[] actions)
        {
            var updater = new RemoteUpdater(repository, remote);

            repository.Config.WithinTransaction(() => {
                foreach (Action<RemoteUpdater> action in actions)
                {
                    action(updater);
                }
            });
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<Remote> GetEnumerator()
        {
            return Proxy
                .git_remote_list(repository.Handle)
                .Select(n => this[n])
                .GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <summary>
        /// Creates a <see cref="Remote"/> with the specified name and for the repository at the specified location.
        /// <para>
        ///   A default fetch refspec will be added for this remote.
        /// </para>
        /// </summary>
        /// <param name="name">The name of the remote to create.</param>
        /// <param name="url">The location of the repository.</param>
        /// <returns>A new <see cref="Remote"/>.</returns>
        public virtual Remote Add(string name, string url)
        {
            Ensure.ArgumentNotNull(name, "name");
            Ensure.ArgumentNotNull(url, "url");

            RemoteHandle handle = Proxy.git_remote_create(repository.Handle, name, url);
            return new Remote(handle, this.repository);
        }

        /// <summary>
        /// Creates a <see cref="Remote"/> with the specified name and for the repository at the specified location.
        /// </summary>
        /// <param name="name">The name of the remote to create.</param>
        /// <param name="url">The location of the repository.</param>
        /// <param name="fetchRefSpec">The refSpec to be used when fetching from this remote.</param>
        /// <returns>A new <see cref="Remote"/>.</returns>
        public virtual Remote Add(string name, string url, string fetchRefSpec)
        {
            Ensure.ArgumentNotNull(name, "name");
            Ensure.ArgumentNotNull(url, "url");
            Ensure.ArgumentNotNull(fetchRefSpec, "fetchRefSpec");

            RemoteHandle handle = Proxy.git_remote_create_with_fetchspec(repository.Handle, name, url, fetchRefSpec);
            return new Remote(handle, this.repository);
        }

        /// <summary>
        /// Deletes the <see cref="Remote"/> with the specified name.
        /// </summary>
        /// <param name="name">The name of the remote to remove.</param>
        /// <returns>A new <see cref="Remote"/>.</returns>
        public virtual void Remove(string name)
        {
            Ensure.ArgumentNotNull(name, "name");

            Proxy.git_remote_delete(repository.Handle, name);
        }

        /// <summary>
        /// Renames an existing <see cref="Remote"/>.
        /// </summary>
        /// <param name="name">The current remote name.</param>
        /// <param name="newName">The new name the existing remote should bear.</param>
        /// <returns>A new <see cref="Remote"/>.</returns>
        public virtual Remote Rename(string name, string newName)
        {
            return Rename(name, newName, null);
        }

        /// <summary>
        /// Renames an existing <see cref="Remote"/>.
        /// </summary>
        /// <param name="name">The current remote name.</param>
        /// <param name="newName">The new name the existing remote should bear.</param>
        /// <param name="callback">The callback to be used when problems with renaming occur. (e.g. non-default fetch refspecs)</param>
        /// <returns>A new <see cref="Remote"/>.</returns>
        public virtual Remote Rename(string name, string newName, RemoteRenameFailureHandler callback)
        {
            Ensure.ArgumentNotNull(name, "name");
            Ensure.ArgumentNotNull(newName, "newName");

            Proxy.git_remote_rename(repository.Handle, name, newName, callback);
            return this[newName];
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "Count = {0}", this.Count());
            }
        }
    }

    /// <summary>
    /// git_remote_completion types.
    /// </summary>
    public enum RemoteCompletionType
    {
        /// <summary>
        /// Download.
        /// </summary>
        Download = 0, /* GIT_REMOTE_COMPLETION_DOWNLOAD */

        /// <summary>
        /// Indexing.
        /// </summary>
        Indexing, /* GIT_REMOTE_COMPLETION_INDEXING */

        /// <summary>
        /// Error.
        /// </summary>
        Error,    /* GIT_REMOTE_COMPLETION_ERROR */
    }

    /// <summary>
    /// Remote redirection settings; whether redirects to another
    /// host are permitted. By default, git will follow a redirect
    /// on the initial request (`/info/refs`) but not subsequent
    /// requests.
    /// </summary>
    public enum RemoteRedirectMode
    {
        /// <summary>
        /// Do not follow any off-site redirects at any stage of
        /// the fetch or push.
        /// </summary>
        None = 1 << 0, // GIT_REMOTE_REDIRECT_NONE

        /// <summary>
        /// Allow off-site redirects only upon the initial
        /// request. This is the default.
        /// </summary>
        Initial = 1 << 1,     // GIT_REMOTE_REDIRECT_INITIAL

        /// <summary>
        /// Allow redirects at any stage in the fetch or push.
        /// </summary>
        All = 1 << 2      // GIT_REMOTE_REDIRECT_ALL
    }

    /// <summary>
    /// Exposes properties of a remote that can be updated.
    /// </summary>
    public class RemoteUpdater
    {
        private readonly UpdatingCollection<string> fetchRefSpecs;
        private readonly UpdatingCollection<string> pushRefSpecs;
        private readonly Repository repo;
        private readonly string remoteName;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected RemoteUpdater()
        { }

        internal RemoteUpdater(Repository repo, Remote remote)
        {
            Ensure.ArgumentNotNull(repo, "repo");
            Ensure.ArgumentNotNull(remote, "remote");

            this.repo = repo;
            this.remoteName = remote.Name;

            fetchRefSpecs = new UpdatingCollection<string>(GetFetchRefSpecs, SetFetchRefSpecs);
            pushRefSpecs = new UpdatingCollection<string>(GetPushRefSpecs, SetPushRefSpecs);
        }

        internal RemoteUpdater(Repository repo, string remote)
        {
            Ensure.ArgumentNotNull(repo, "repo");
            Ensure.ArgumentNotNull(remote, "remote");

            this.repo = repo;
            this.remoteName = remote;

            fetchRefSpecs = new UpdatingCollection<string>(GetFetchRefSpecs, SetFetchRefSpecs);
            pushRefSpecs = new UpdatingCollection<string>(GetPushRefSpecs, SetPushRefSpecs);
        }

        private IEnumerable<string> GetFetchRefSpecs()
        {
            using (RemoteHandle remoteHandle = Proxy.git_remote_lookup(repo.Handle, remoteName, true))
            {
                return Proxy.git_remote_get_fetch_refspecs(remoteHandle);
            }
        }

        private void SetFetchRefSpecs(IEnumerable<string> value)
        {
            repo.Config.UnsetAll(string.Format("remote.{0}.fetch", remoteName), ConfigurationLevel.Local);

            foreach (var url in value)
            {
                Proxy.git_remote_add_fetch(repo.Handle, remoteName, url);
            }
        }

        private IEnumerable<string> GetPushRefSpecs()
        {
            using (RemoteHandle remoteHandle = Proxy.git_remote_lookup(repo.Handle, remoteName, true))
            {
                return Proxy.git_remote_get_push_refspecs(remoteHandle);
            }
        }

        private void SetPushRefSpecs(IEnumerable<string> value)
        {
            repo.Config.UnsetAll(string.Format("remote.{0}.push", remoteName), ConfigurationLevel.Local);

            foreach (var url in value)
            {
                Proxy.git_remote_add_push(repo.Handle, remoteName, url);
            }
        }

        /// <summary>
        /// Set the default TagFetchMode value for the remote.
        /// </summary>
        public virtual TagFetchMode TagFetchMode
        {
            set { Proxy.git_remote_set_autotag(repo.Handle, remoteName, value); }
        }

        /// <summary>
        /// Sets the url defined for this <see cref="Remote"/>
        /// </summary>
        public virtual string Url
        {
            set { Proxy.git_remote_set_url(repo.Handle, remoteName, value); }
        }

        /// <summary>
        /// Sets the push url defined for this <see cref="Remote"/>
        /// </summary>
        public virtual string PushUrl
        {
            set { Proxy.git_remote_set_pushurl(repo.Handle, remoteName, value); }
        }

        /// <summary>
        /// Sets the list of <see cref="RefSpec"/>s defined for this <see cref="Remote"/> that are intended to
        /// be used during a Fetch operation
        /// </summary>
        public virtual ICollection<string> FetchRefSpecs
        {
            get { return fetchRefSpecs; }
            set { fetchRefSpecs.ReplaceAll(value); }
        }

        /// <summary>
        /// Sets or gets the list of <see cref="RefSpec"/>s defined for this <see cref="Remote"/> that are intended to
        /// be used during a Push operation
        /// </summary>
        public virtual ICollection<string> PushRefSpecs
        {
            get { return pushRefSpecs; }
            set { pushRefSpecs.ReplaceAll(value); }
        }

        private class UpdatingCollection<T> : ICollection<T>
        {
            private readonly Lazy<List<T>> list;
            private readonly Action<IEnumerable<T>> setter;

            public UpdatingCollection(Func<IEnumerable<T>> getter,
                Action<IEnumerable<T>> setter)
            {
                list = new Lazy<List<T>>(() => new List<T>(getter()));
                this.setter = setter;
            }

            public void Add(T item)
            {
                list.Value.Add(item);
                Save();
            }

            public void Clear()
            {
                list.Value.Clear();
                Save();
            }

            public bool Contains(T item)
            {
                return list.Value.Contains(item);
            }

            public void CopyTo(T[] array, int arrayIndex)
            {
                list.Value.CopyTo(array, arrayIndex);
            }

            public int Count
            {
                get { return list.Value.Count; }
            }

            public bool IsReadOnly
            {
                get { return false; }
            }

            public bool Remove(T item)
            {
                if (!list.Value.Remove(item))
                {
                    return false;
                }

                Save();
                return true;
            }

            public IEnumerator<T> GetEnumerator()
            {
                return list.Value.GetEnumerator();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return list.Value.GetEnumerator();
            }

            public void ReplaceAll(IEnumerable<T> newValues)
            {
                Ensure.ArgumentNotNull(newValues, "newValues");
                list.Value.Clear();
                list.Value.AddRange(newValues);
                Save();
            }

            private void Save()
            {
                setter(list.Value);
            }
        }
    }

    /// <summary>
    /// The exception that is thrown when a file cannot be removed from the index.
    /// </summary>
    [Serializable]
    public class RemoveFromIndexException : LibGit2SharpException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UnmatchedPathException"/> class.
        /// </summary>
        public RemoveFromIndexException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnmatchedPathException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public RemoveFromIndexException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="RemoveFromIndexException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public RemoveFromIndexException(string format, params object[] args)
            : base(format, args)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnmatchedPathException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public RemoveFromIndexException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnmatchedPathException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected RemoveFromIndexException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }
    }

    /// <summary>
    /// Holds the rename details of a particular file.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class RenameDetails : IEquatable<RenameDetails>
    {
        private readonly string oldFilePath;
        private readonly string newFilePath;
        private readonly int similarity;

        private static readonly LambdaEqualityHelper<RenameDetails> equalityHelper =
            new LambdaEqualityHelper<RenameDetails>(x => x.OldFilePath, x => x.NewFilePath, x => x.Similarity);

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected RenameDetails()
        { }

        internal RenameDetails(string oldFilePath, string newFilePath, int similarity)
        {
            this.oldFilePath = oldFilePath;
            this.newFilePath = newFilePath;
            this.similarity = similarity;
        }

        /// <summary>
        /// Gets the relative filepath to the working directory of the old file (the rename source).
        /// </summary>
        public virtual string OldFilePath
        {
            get { return oldFilePath; }
        }

        /// <summary>
        /// Gets the relative filepath to the working directory of the new file (the rename target).
        /// </summary>
        public virtual string NewFilePath
        {
            get { return newFilePath; }
        }

        /// <summary>
        /// Gets the similarity between the old file an the new file (0-100).
        /// </summary>
        public virtual int Similarity
        {
            get { return similarity; }
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="RenameDetails"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="RenameDetails"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="RenameDetails"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as RenameDetails);
        }

        /// <summary>
        /// Determines whether the specified <see cref="RenameDetails"/> is equal to the current <see cref="RenameDetails"/>.
        /// </summary>
        /// <param name="other">The <see cref="RenameDetails"/> to compare with the current <see cref="RenameDetails"/>.</param>
        /// <returns>True if the specified <see cref="RenameDetails"/> is equal to the current <see cref="RenameDetails"/>; otherwise, false.</returns>
        public bool Equals(RenameDetails other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="RenameDetails"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="RenameDetails"/> to compare.</param>
        /// <param name="right">Second <see cref="RenameDetails"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(RenameDetails left, RenameDetails right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="RenameDetails"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="RenameDetails"/> to compare.</param>
        /// <param name="right">Second <see cref="RenameDetails"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(RenameDetails left, RenameDetails right)
        {
            return !Equals(left, right);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0} -> {1} [{2}%]",
                                     OldFilePath,
                                     NewFilePath,
                                     Similarity);
            }
        }
    }

    /// <summary>
    /// A Repository is the primary interface into a git repository
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public sealed class Repository : IRepository
    {
        private readonly bool isBare;
        private readonly BranchCollection branches;
        private readonly CommitLog commits;
        private readonly Lazy<Configuration> config;
        private readonly RepositoryHandle handle;
        private readonly Lazy<Index> index;
        private readonly ReferenceCollection refs;
        private readonly TagCollection tags;
        private readonly StashCollection stashes;
        private readonly Lazy<RepositoryInformation> info;
        private readonly Diff diff;
        private readonly NoteCollection notes;
        private readonly Lazy<ObjectDatabase> odb;
        private readonly Lazy<Network> network;
        private readonly Lazy<Rebase> rebaseOperation;
        private readonly Stack<IDisposable> toCleanup = new Stack<IDisposable>();
        private readonly Ignore ignore;
        private readonly SubmoduleCollection submodules;
        private readonly WorktreeCollection worktrees;
        private readonly Lazy<PathCase> pathCase;

        [Flags]
        private enum RepositoryRequiredParameter
        {
            None = 0,
            Path = 1,
            Options = 2,
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Repository"/> class
        /// that does not point to an on-disk Git repository.  This is
        /// suitable only for custom, in-memory Git repositories that are
        /// configured with custom object database, reference database and/or
        /// configuration backends.
        /// </summary>
        public Repository()
            : this(null, null, RepositoryRequiredParameter.None)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Repository"/> class.
        /// <para>For a standard repository, <paramref name="path"/> should either point to the ".git" folder or to the working directory. For a bare repository, <paramref name="path"/> should directly point to the repository folder.</para>
        /// </summary>
        /// <param name="path">
        /// The path to the git repository to open, can be either the path to the git directory (for non-bare repositories this
        /// would be the ".git" folder inside the working directory) or the path to the working directory.
        /// </param>
        public Repository(string path)
            : this(path, null, RepositoryRequiredParameter.Path)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Repository"/> class,
        /// providing optional behavioral overrides through the
        /// <paramref name="options"/> parameter.
        /// <para>For a standard repository, <paramref name="path"/> may
        /// either point to the ".git" folder or to the working directory.
        /// For a bare repository, <paramref name="path"/> should directly
        /// point to the repository folder.</para>
        /// </summary>
        /// <param name="path">
        /// The path to the git repository to open, can be either the
        /// path to the git directory (for non-bare repositories this
        /// would be the ".git" folder inside the working directory)
        /// or the path to the working directory.
        /// </param>
        /// <param name="options">
        /// Overrides to the way a repository is opened.
        /// </param>
        public Repository(string path, RepositoryOptions options) :
            this(path, options, RepositoryRequiredParameter.Path | RepositoryRequiredParameter.Options)
        {
        }

        internal Repository(WorktreeHandle worktreeHandle)
        {
            try
            {
                handle = Proxy.git_repository_open_from_worktree(worktreeHandle);
                RegisterForCleanup(handle);
                RegisterForCleanup(worktreeHandle);

                isBare = Proxy.git_repository_is_bare(handle);

                Func<Index> indexBuilder = () => new Index(this);

                string configurationGlobalFilePath = null;
                string configurationXDGFilePath = null;
                string configurationSystemFilePath = null;

                if (!isBare)
                {
                    index = new Lazy<Index>(() => indexBuilder());
                }

                commits = new CommitLog(this);
                refs = new ReferenceCollection(this);
                branches = new BranchCollection(this);
                tags = new TagCollection(this);
                stashes = new StashCollection(this);
                info = new Lazy<RepositoryInformation>(() => new RepositoryInformation(this, isBare));
                config = new Lazy<Configuration>(() => RegisterForCleanup(new Configuration(this,
                                                                                            null,
                                                                                            configurationGlobalFilePath,
                                                                                            configurationXDGFilePath,
                                                                                            configurationSystemFilePath)));
                odb = new Lazy<ObjectDatabase>(() => new ObjectDatabase(this));
                diff = new Diff(this);
                notes = new NoteCollection(this);
                ignore = new Ignore(this);
                network = new Lazy<Network>(() => new Network(this));
                rebaseOperation = new Lazy<Rebase>(() => new Rebase(this));
                pathCase = new Lazy<PathCase>(() => new PathCase(this));
                submodules = new SubmoduleCollection(this);
                worktrees = new WorktreeCollection(this);
            }
            catch
            {
                CleanupDisposableDependencies();
                throw;
            }
        }

        private Repository(string path, RepositoryOptions options, RepositoryRequiredParameter requiredParameter)
        {
            if ((requiredParameter & RepositoryRequiredParameter.Path) == RepositoryRequiredParameter.Path)
            {
                Ensure.ArgumentNotNullOrEmptyString(path, "path");
            }

            if ((requiredParameter & RepositoryRequiredParameter.Options) == RepositoryRequiredParameter.Options)
            {
                Ensure.ArgumentNotNull(options, "options");
            }

            try
            {
                handle = (path != null) ? Proxy.git_repository_open(path) : Proxy.git_repository_new();
                RegisterForCleanup(handle);

                isBare = Proxy.git_repository_is_bare(handle);

                /* TODO: bug in libgit2, update when fixed by
                 * https://github.com/libgit2/libgit2/pull/2970
                 */
                if (path == null)
                {
                    isBare = true;
                }

                Func<Index> indexBuilder = () => new Index(this);

                string configurationGlobalFilePath = null;
                string configurationXDGFilePath = null;
                string configurationSystemFilePath = null;

                if (options != null)
                {
                    bool isWorkDirNull = string.IsNullOrEmpty(options.WorkingDirectoryPath);
                    bool isIndexNull = string.IsNullOrEmpty(options.IndexPath);

                    if (isBare && (isWorkDirNull ^ isIndexNull))
                    {
                        throw new ArgumentException("When overriding the opening of a bare repository, both RepositoryOptions.WorkingDirectoryPath an RepositoryOptions.IndexPath have to be provided.");
                    }

                    if (!isWorkDirNull)
                    {
                        isBare = false;
                    }

                    if (!isIndexNull)
                    {
                        indexBuilder = () => new Index(this, options.IndexPath);
                    }

                    if (!isWorkDirNull)
                    {
                        Proxy.git_repository_set_workdir(handle, options.WorkingDirectoryPath);
                    }

                    if (options.Identity != null)
                    {
                        Proxy.git_repository_set_ident(handle, options.Identity.Name, options.Identity.Email);
                    }
                }

                if (!isBare)
                {
                    index = new Lazy<Index>(() => indexBuilder());
                }

                commits = new CommitLog(this);
                refs = new ReferenceCollection(this);
                branches = new BranchCollection(this);
                tags = new TagCollection(this);
                stashes = new StashCollection(this);
                info = new Lazy<RepositoryInformation>(() => new RepositoryInformation(this, isBare));
                config = new Lazy<Configuration>(() => RegisterForCleanup(new Configuration(this,
                                                                                            null,
                                                                                            configurationGlobalFilePath,
                                                                                            configurationXDGFilePath,
                                                                                            configurationSystemFilePath)));
                odb = new Lazy<ObjectDatabase>(() => new ObjectDatabase(this));
                diff = new Diff(this);
                notes = new NoteCollection(this);
                ignore = new Ignore(this);
                network = new Lazy<Network>(() => new Network(this));
                rebaseOperation = new Lazy<Rebase>(() => new Rebase(this));
                pathCase = new Lazy<PathCase>(() => new PathCase(this));
                submodules = new SubmoduleCollection(this);
                worktrees = new WorktreeCollection(this);

                EagerlyLoadComponentsWithSpecifiedPaths(options);
            }
            catch
            {
                CleanupDisposableDependencies();
                throw;
            }
        }

        /// <summary>
        /// Check if parameter <paramref name="path"/> leads to a valid git repository.
        /// </summary>
        /// <param name="path">
        /// The path to the git repository to check, can be either the path to the git directory (for non-bare repositories this
        /// would be the ".git" folder inside the working directory) or the path to the working directory.
        /// </param>
        /// <returns>True if a repository can be resolved through this path; false otherwise</returns>
        static public bool IsValid(string path)
        {
            Ensure.ArgumentNotNull(path, "path");

            if (string.IsNullOrWhiteSpace(path))
            {
                return false;
            }

            try
            {
                Proxy.git_repository_open_ext(path, RepositoryOpenFlags.NoSearch, null);
            }
            catch (RepositoryNotFoundException)
            {
                return false;
            }

            return true;
        }

        private void EagerlyLoadComponentsWithSpecifiedPaths(RepositoryOptions options)
        {
            if (options == null)
            {
                return;
            }

            if (!string.IsNullOrEmpty(options.IndexPath))
            {
                // Another dirty hack to avoid warnings
                if (Index.Count < 0)
                {
                    throw new InvalidOperationException("Unexpected state.");
                }
            }
        }

        internal RepositoryHandle Handle
        {
            get { return handle; }
        }

        /// <summary>
        /// Shortcut to return the branch pointed to by HEAD
        /// </summary>
        public Branch Head
        {
            get
            {
                Reference reference = Refs.Head;

                if (reference == null)
                {
                    throw new LibGit2SharpException("Corrupt repository. The 'HEAD' reference is missing.");
                }

                if (reference is SymbolicReference)
                {
                    return new Branch(this, reference);
                }

                return new DetachedHead(this, reference);
            }
        }

        /// <summary>
        /// Provides access to the configuration settings for this repository.
        /// </summary>
        public Configuration Config
        {
            get { return config.Value; }
        }

        /// <summary>
        /// Gets the index.
        /// </summary>
        public Index Index
        {
            get
            {
                if (isBare)
                {
                    throw new BareRepositoryException("Index is not available in a bare repository.");
                }

                return index != null ? index.Value : null;
            }
        }

        /// <summary>
        /// Manipulate the currently ignored files.
        /// </summary>
        public Ignore Ignore
        {
            get { return ignore; }
        }

        /// <summary>
        /// Provides access to network functionality for a repository.
        /// </summary>
        public Network Network
        {
            get { return network.Value; }
        }

        /// <summary>
        /// Provides access to rebase functionality for a repository.
        /// </summary>
        public Rebase Rebase
        {
            get
            {
                return rebaseOperation.Value;
            }
        }

        /// <summary>
        /// Gets the database.
        /// </summary>
        public ObjectDatabase ObjectDatabase
        {
            get { return odb.Value; }
        }

        /// <summary>
        /// Lookup and enumerate references in the repository.
        /// </summary>
        public ReferenceCollection Refs
        {
            get { return refs; }
        }

        /// <summary>
        /// Lookup and enumerate commits in the repository.
        /// Iterating this collection directly starts walking from the HEAD.
        /// </summary>
        public IQueryableCommitLog Commits
        {
            get { return commits; }
        }

        /// <summary>
        /// Lookup and enumerate branches in the repository.
        /// </summary>
        public BranchCollection Branches
        {
            get { return branches; }
        }

        /// <summary>
        /// Lookup and enumerate tags in the repository.
        /// </summary>
        public TagCollection Tags
        {
            get { return tags; }
        }

        ///<summary>
        /// Lookup and enumerate stashes in the repository.
        ///</summary>
        public StashCollection Stashes
        {
            get { return stashes; }
        }

        /// <summary>
        /// Provides high level information about this repository.
        /// </summary>
        public RepositoryInformation Info
        {
            get { return info.Value; }
        }

        /// <summary>
        /// Provides access to diffing functionalities to show changes between the working tree and the index or a tree, changes between the index and a tree, changes between two trees, or changes between two files on disk.
        /// </summary>
        public Diff Diff
        {
            get { return diff; }
        }

        /// <summary>
        /// Lookup notes in the repository.
        /// </summary>
        public NoteCollection Notes
        {
            get { return notes; }
        }

        /// <summary>
        /// Submodules in the repository.
        /// </summary>
        public SubmoduleCollection Submodules
        {
            get { return submodules; }
        }

        /// <summary>
        /// Worktrees in the repository.
        /// </summary>
        public WorktreeCollection Worktrees
        {
            get { return worktrees; }
        }

        #region IDisposable Members

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        private void Dispose(bool disposing)
        {
            CleanupDisposableDependencies();
        }

        #endregion

        /// <summary>
        /// Initialize a repository at the specified <paramref name="path"/>.
        /// </summary>
        /// <param name="path">The path to the working folder when initializing a standard ".git" repository. Otherwise, when initializing a bare repository, the path to the expected location of this later.</param>
        /// <returns>The path to the created repository.</returns>
        public static string Init(string path)
        {
            return Init(path, false);
        }

        /// <summary>
        /// Initialize a repository at the specified <paramref name="path"/>.
        /// </summary>
        /// <param name="path">The path to the working folder when initializing a standard ".git" repository. Otherwise, when initializing a bare repository, the path to the expected location of this later.</param>
        /// <param name="isBare">true to initialize a bare repository. False otherwise, to initialize a standard ".git" repository.</param>
        /// <returns>The path to the created repository.</returns>
        public static string Init(string path, bool isBare)
        {
            Ensure.ArgumentNotNullOrEmptyString(path, "path");

            using (RepositoryHandle repo = Proxy.git_repository_init_ext(null, path, isBare))
            {
                FilePath repoPath = Proxy.git_repository_path(repo);
                return repoPath.Native;
            }
        }

        /// <summary>
        /// Initialize a repository by explictly setting the path to both the working directory and the git directory.
        /// </summary>
        /// <param name="workingDirectoryPath">The path to the working directory.</param>
        /// <param name="gitDirectoryPath">The path to the git repository to be created.</param>
        /// <returns>The path to the created repository.</returns>
        public static string Init(string workingDirectoryPath, string gitDirectoryPath)
        {
            Ensure.ArgumentNotNullOrEmptyString(workingDirectoryPath, "workingDirectoryPath");
            Ensure.ArgumentNotNullOrEmptyString(gitDirectoryPath, "gitDirectoryPath");

            // When being passed a relative workdir path, libgit2 will evaluate it from the
            // path to the repository. We pass a fully rooted path in order for the LibGit2Sharp caller
            // to pass a path relatively to his current directory.
            string wd = Path.GetFullPath(workingDirectoryPath);

            // TODO: Shouldn't we ensure that the working folder isn't under the gitDir?

            using (RepositoryHandle repo = Proxy.git_repository_init_ext(wd, gitDirectoryPath, false))
            {
                FilePath repoPath = Proxy.git_repository_path(repo);
                return repoPath.Native;
            }
        }

        /// <summary>
        /// Try to lookup an object by its <see cref="ObjectId"/>. If no matching object is found, null will be returned.
        /// </summary>
        /// <param name="id">The id to lookup.</param>
        /// <returns>The <see cref="GitObject"/> or null if it was not found.</returns>
        public GitObject Lookup(ObjectId id)
        {
            return LookupInternal(id, GitObjectType.Any, null);
        }

        /// <summary>
        /// Try to lookup an object by its sha or a reference canonical name. If no matching object is found, null will be returned.
        /// </summary>
        /// <param name="objectish">A revparse spec for the object to lookup.</param>
        /// <returns>The <see cref="GitObject"/> or null if it was not found.</returns>
        public GitObject Lookup(string objectish)
        {
            return Lookup(objectish, GitObjectType.Any, LookUpOptions.None);
        }

        /// <summary>
        /// Try to lookup an object by its <see cref="ObjectId"/> and <see cref="ObjectType"/>. If no matching object is found, null will be returned.
        /// </summary>
        /// <param name="id">The id to lookup.</param>
        /// <param name="type">The kind of GitObject being looked up</param>
        /// <returns>The <see cref="GitObject"/> or null if it was not found.</returns>
        public GitObject Lookup(ObjectId id, ObjectType type)
        {
            return LookupInternal(id, type.ToGitObjectType(), null);
        }

        /// <summary>
        /// Try to lookup an object by its sha or a reference canonical name and <see cref="ObjectType"/>. If no matching object is found, null will be returned.
        /// </summary>
        /// <param name="objectish">A revparse spec for the object to lookup.</param>
        /// <param name="type">The kind of <see cref="GitObject"/> being looked up</param>
        /// <returns>The <see cref="GitObject"/> or null if it was not found.</returns>
        public GitObject Lookup(string objectish, ObjectType type)
        {
            return Lookup(objectish, type.ToGitObjectType(), LookUpOptions.None);
        }

        internal GitObject LookupInternal(ObjectId id, GitObjectType type, string knownPath)
        {
            Ensure.ArgumentNotNull(id, "id");

            using (ObjectHandle obj = Proxy.git_object_lookup(handle, id, type))
            {
                if (obj == null || obj.IsNull)
                {
                    return null;
                }

                return GitObject.BuildFrom(this, id, Proxy.git_object_type(obj), knownPath);
            }
        }

        private static string PathFromRevparseSpec(string spec)
        {
            if (spec.StartsWith(":/", StringComparison.Ordinal))
            {
                return null;
            }

            if (Regex.IsMatch(spec, @"^:.*:"))
            {
                return null;
            }

            var m = Regex.Match(spec, @"[^@^ ]*:(.*)");
            return (m.Groups.Count > 1) ? m.Groups[1].Value : null;
        }

        internal GitObject Lookup(string objectish, GitObjectType type, LookUpOptions lookUpOptions)
        {
            Ensure.ArgumentNotNullOrEmptyString(objectish, "objectish");

            GitObject obj;
            using (ObjectHandle sh = Proxy.git_revparse_single(handle, objectish))
            {
                if (sh == null)
                {
                    if (lookUpOptions.HasFlag(LookUpOptions.ThrowWhenNoGitObjectHasBeenFound))
                    {
                        Ensure.GitObjectIsNotNull(null, objectish);
                    }

                    return null;
                }

                GitObjectType objType = Proxy.git_object_type(sh);

                if (type != GitObjectType.Any && objType != type)
                {
                    return null;
                }

                obj = GitObject.BuildFrom(this, Proxy.git_object_id(sh), objType, PathFromRevparseSpec(objectish));
            }

            if (lookUpOptions.HasFlag(LookUpOptions.DereferenceResultToCommit))
            {
                return obj.Peel<Commit>(lookUpOptions.HasFlag(LookUpOptions.ThrowWhenCanNotBeDereferencedToACommit));
            }

            return obj;
        }

        internal Commit LookupCommit(string committish)
        {
            return (Commit)Lookup(committish,
                                  GitObjectType.Any,
                                  LookUpOptions.ThrowWhenNoGitObjectHasBeenFound |
                                  LookUpOptions.DereferenceResultToCommit |
                                  LookUpOptions.ThrowWhenCanNotBeDereferencedToACommit);
        }

        /// <summary>
        /// Lists the Remote Repository References.
        /// </summary>
        /// <para>
        /// Does not require a local Repository. The retrieved
        /// <see cref="IBelongToARepository.Repository"/>
        /// throws <see cref="InvalidOperationException"/> in this case.
        /// </para>
        /// <param name="url">The url to list from.</param>
        /// <returns>The references in the remote repository.</returns>
        public static IEnumerable<Reference> ListRemoteReferences(string url)
        {
            return ListRemoteReferences(url, null, new ProxyOptions());
        }

        /// <summary>
        /// Lists the Remote Repository References.
        /// </summary>
        /// <param name="url">The url to list from.</param>
        /// <param name="proxyOptions">Options for connecting through a proxy.</param>
        /// <returns>The references in the remote repository.</returns>
        public static IEnumerable<Reference> ListRemoteReferences(string url, ProxyOptions proxyOptions)
        {
            return ListRemoteReferences(url, null, proxyOptions);
        }

        /// <summary>
        /// Lists the Remote Repository References.
        /// </summary>
        /// <para>
        /// Does not require a local Repository. The retrieved
        /// <see cref="IBelongToARepository.Repository"/>
        /// throws <see cref="InvalidOperationException"/> in this case.
        /// </para>
        /// <param name="url">The url to list from.</param>
        /// <param name="credentialsProvider">The <see cref="Func{Credentials}"/> used to connect to remote repository.</param>
        /// <returns>The references in the remote repository.</returns>
        public static IEnumerable<Reference> ListRemoteReferences(string url, CredentialsHandler credentialsProvider)
        {
            return ListRemoteReferences(url, credentialsProvider, new ProxyOptions());
        }

        /// <summary>
        /// Lists the Remote Repository References.
        /// </summary>
        /// <para>
        /// Does not require a local Repository. The retrieved
        /// <see cref="IBelongToARepository.Repository"/>
        /// throws <see cref="InvalidOperationException"/> in this case.
        /// </para>
        /// <param name="url">The url to list from.</param>
        /// <param name="credentialsProvider">The <see cref="Func{Credentials}"/> used to connect to remote repository.</param>
        /// <param name="proxyOptions">Options for connecting through a proxy.</param>
        /// <returns>The references in the remote repository.</returns>
        public static IEnumerable<Reference> ListRemoteReferences(string url, CredentialsHandler credentialsProvider, ProxyOptions proxyOptions)
        {
            Ensure.ArgumentNotNull(url, "url");

            if (proxyOptions == null) proxyOptions = new ProxyOptions();

            RepositoryHandle repositoryHandle = Proxy.git_repository_new();
            RemoteHandle remoteHandle = Proxy.git_remote_create_anonymous(repositoryHandle, url);
            var proxyOptionsWrapper = new GitProxyOptionsWrapper(proxyOptions.CreateGitProxyOptions());

            var gitCallbacks = new GitRemoteCallbacks { version = 1 };

            if (credentialsProvider != null)
            {
                var callbacks = new RemoteCallbacks(credentialsProvider);
                gitCallbacks = callbacks.GenerateCallbacks();
            }

            var gitProxyOptions = proxyOptionsWrapper.Options;

            Proxy.git_remote_connect(remoteHandle, GitDirection.Fetch, ref gitCallbacks, ref gitProxyOptions);
            return Proxy.git_remote_ls(null, remoteHandle);
        }

        /// <summary>
        /// Probe for a git repository.
        /// <para>The lookup start from <paramref name="startingPath"/> and walk upward parent directories if nothing has been found.</para>
        /// </summary>
        /// <param name="startingPath">The base path where the lookup starts.</param>
        /// <returns>The path to the git repository, or null if no repository was found.</returns>
        public static string Discover(string startingPath)
        {
            FilePath discoveredPath = Proxy.git_repository_discover(startingPath);

            if (discoveredPath == null)
            {
                return null;
            }

            return discoveredPath.Native;
        }

        /// <summary>
        /// Clone using default options.
        /// </summary>
        /// <exception cref="RecurseSubmodulesException">This exception is thrown when there
        /// is an error is encountered while recursively cloning submodules. The inner exception
        /// will contain the original exception. The initially cloned repository would
        /// be reported through the <see cref="RecurseSubmodulesException.InitialRepositoryPath"/>
        /// property.</exception>"
        /// <exception cref="UserCancelledException">Exception thrown when the cancelling
        /// the clone of the initial repository.</exception>"
        /// <param name="sourceUrl">URI for the remote repository</param>
        /// <param name="workdirPath">Local path to clone into</param>
        /// <returns>The path to the created repository.</returns>
        public static string Clone(string sourceUrl, string workdirPath)
        {
            return Clone(sourceUrl, workdirPath, null);
        }

        /// <summary>
        /// Clone with specified options.
        /// </summary>
        /// <exception cref="RecurseSubmodulesException">This exception is thrown when there
        /// is an error is encountered while recursively cloning submodules. The inner exception
        /// will contain the original exception. The initially cloned repository would
        /// be reported through the <see cref="RecurseSubmodulesException.InitialRepositoryPath"/>
        /// property.</exception>"
        /// <exception cref="UserCancelledException">Exception thrown when the cancelling
        /// the clone of the initial repository.</exception>"
        /// <param name="sourceUrl">URI for the remote repository</param>
        /// <param name="workdirPath">Local path to clone into</param>
        /// <param name="options"><see cref="CloneOptions"/> controlling clone behavior</param>
        /// <returns>The path to the created repository.</returns>
        public static string Clone(string sourceUrl, string workdirPath,
            CloneOptions options)
        {
            Ensure.ArgumentNotNull(sourceUrl, "sourceUrl");
            Ensure.ArgumentNotNull(workdirPath, "workdirPath");

            if (options == null) options = new CloneOptions();

            // context variable that contains information on the repository that
            // we are cloning.
            var context = new RepositoryOperationContext(Path.GetFullPath(workdirPath), sourceUrl);

            // Notify caller that we are starting to work with the current repository.
            bool continueOperation = OnRepositoryOperationStarting(options.FetchOptions.RepositoryOperationStarting,
                                                                   context);

            if (!continueOperation)
            {
                throw new UserCancelledException("Clone cancelled by the user.");
            }

            using (var checkoutOptionsWrapper = new GitCheckoutOptsWrapper(options))
            using (var fetchOptionsWrapper = new GitFetchOptionsWrapper())
            {
                var gitCheckoutOptions = checkoutOptionsWrapper.Options;

                var gitFetchOptions = fetchOptionsWrapper.Options;
                gitFetchOptions.ProxyOptions = options.FetchOptions.ProxyOptions.CreateGitProxyOptions();
                gitFetchOptions.RemoteCallbacks = new RemoteCallbacks(options.FetchOptions).GenerateCallbacks();
                if (options.FetchOptions != null && options.FetchOptions.CustomHeaders != null)
                {
                    gitFetchOptions.CustomHeaders =
                        GitStrArrayManaged.BuildFrom(options.FetchOptions.CustomHeaders);
                }

                gitFetchOptions.Depth = options.Depth;

                var cloneOpts = new GitCloneOptions
                {
                    Version = 1,
                    Bare = options.IsBare ? 1 : 0,
                    CheckoutOpts = gitCheckoutOptions,
                    FetchOpts = gitFetchOptions,
                };

                string clonedRepoPath;

                try
                {
                    cloneOpts.CheckoutBranch = StrictUtf8Marshaler.FromManaged(options.BranchName);

                    using (RepositoryHandle repo = Proxy.git_clone(sourceUrl, workdirPath, ref cloneOpts))
                    {
                        clonedRepoPath = Proxy.git_repository_path(repo).Native;
                    }
                }
                finally
                {
                    EncodingMarshaler.Cleanup(cloneOpts.CheckoutBranch);
                }

                // Notify caller that we are done with the current repository.
                OnRepositoryOperationCompleted(options.FetchOptions.RepositoryOperationCompleted,
                                               context);

                // Recursively clone submodules if requested.
                try
                {
                    RecursivelyCloneSubmodules(options, clonedRepoPath, 1);
                }
                catch (Exception ex)
                {
                    throw new RecurseSubmodulesException("The top level repository was cloned, but there was an error cloning its submodules.",
                                                         ex,
                                                         clonedRepoPath);
                }

                return clonedRepoPath;
            }
        }

        /// <summary>
        /// Recursively clone submodules if directed to do so by the clone options.
        /// </summary>
        /// <param name="options">Options controlling clone behavior.</param>
        /// <param name="repoPath">Path of the parent repository.</param>
        /// <param name="recursionDepth">The current depth of the recursion.</param>
        private static void RecursivelyCloneSubmodules(CloneOptions options, string repoPath, int recursionDepth)
        {
            if (options.RecurseSubmodules)
            {
                List<string> submodules = new List<string>();

                using (Repository repo = new Repository(repoPath))
                {
                    var updateOptions = new SubmoduleUpdateOptions()
                    {
                        Init = true,
                        OnCheckoutProgress = options.OnCheckoutProgress,
                        FetchOptions = options.FetchOptions
                    };

                    string parentRepoWorkDir = repo.Info.WorkingDirectory;

                    // Iterate through the submodules (where the submodule is in the index),
                    // and clone them.
                    foreach (var sm in repo.Submodules.Where(sm => sm.RetrieveStatus().HasFlag(SubmoduleStatus.InIndex)))
                    {
                        string fullSubmodulePath = Path.Combine(parentRepoWorkDir, sm.Path);

                        // Resolve the URL in the .gitmodule file to the one actually used
                        // to clone
                        string resolvedUrl = Proxy.git_submodule_resolve_url(repo.Handle, sm.Url);

                        var context = new RepositoryOperationContext(fullSubmodulePath,
                                                                     resolvedUrl,
                                                                     parentRepoWorkDir,
                                                                     sm.Name,
                                                                     recursionDepth);

                        bool continueOperation = OnRepositoryOperationStarting(options.FetchOptions.RepositoryOperationStarting,
                                                                               context);

                        if (!continueOperation)
                        {
                            throw new UserCancelledException("Recursive clone of submodules was cancelled.");
                        }

                        repo.Submodules.Update(sm.Name, updateOptions);

                        OnRepositoryOperationCompleted(options.FetchOptions.RepositoryOperationCompleted,
                                                       context);

                        submodules.Add(Path.Combine(repo.Info.WorkingDirectory, sm.Path));
                    }
                }

                // If we are continuing the recursive operation, then
                // recurse into nested submodules.
                // Check submodules to see if they have their own submodules.
                foreach (string submodule in submodules)
                {
                    RecursivelyCloneSubmodules(options, submodule, recursionDepth + 1);
                }
            }
        }

        /// <summary>
        /// If a callback has been provided to notify callers that we are
        /// either starting to work on a repository.
        /// </summary>
        /// <param name="repositoryChangedCallback">The callback to notify change.</param>
        /// <param name="context">Context of the repository this operation affects.</param>
        /// <returns>true to continue the operation, false to cancel.</returns>
        private static bool OnRepositoryOperationStarting(
            RepositoryOperationStarting repositoryChangedCallback,
            RepositoryOperationContext context)
        {
            bool continueOperation = true;
            if (repositoryChangedCallback != null)
            {
                continueOperation = repositoryChangedCallback(context);
            }

            return continueOperation;
        }

        private static void OnRepositoryOperationCompleted(
            RepositoryOperationCompleted repositoryChangedCallback,
            RepositoryOperationContext context)
        {
            if (repositoryChangedCallback != null)
            {
                repositoryChangedCallback(context);
            }
        }

        /// <summary>
        /// Find where each line of a file originated.
        /// </summary>
        /// <param name="path">Path of the file to blame.</param>
        /// <param name="options">Specifies optional parameters; if null, the defaults are used.</param>
        /// <returns>The blame for the file.</returns>
        public BlameHunkCollection Blame(string path, BlameOptions options)
        {
            return new BlameHunkCollection(this, Handle, path, options ?? new BlameOptions());
        }

        /// <summary>
        /// Checkout the specified tree.
        /// </summary>
        /// <param name="tree">The <see cref="Tree"/> to checkout.</param>
        /// <param name="paths">The paths to checkout.</param>
        /// <param name="options">Collection of parameters controlling checkout behavior.</param>
        public void Checkout(Tree tree, IEnumerable<string> paths, CheckoutOptions options)
        {
            CheckoutTree(tree, paths != null ? paths.ToList() : null, options);
        }

        /// <summary>
        /// Checkout the specified tree.
        /// </summary>
        /// <param name="tree">The <see cref="Tree"/> to checkout.</param>
        /// <param name="paths">The paths to checkout.</param>
        /// <param name="opts">Collection of parameters controlling checkout behavior.</param>
        private void CheckoutTree(Tree tree, IList<string> paths, IConvertableToGitCheckoutOpts opts)
        {

            using (GitCheckoutOptsWrapper checkoutOptionsWrapper = new GitCheckoutOptsWrapper(opts, ToFilePaths(paths)))
            {
                var options = checkoutOptionsWrapper.Options;
                Proxy.git_checkout_tree(Handle, tree.Id, ref options);
            }
        }

        /// <summary>
        /// Sets the current <see cref="Head"/> to the specified commit and optionally resets the <see cref="Index"/> and
        /// the content of the working tree to match.
        /// </summary>
        /// <param name="resetMode">Flavor of reset operation to perform.</param>
        /// <param name="commit">The target commit object.</param>
        public void Reset(ResetMode resetMode, Commit commit)
        {
            Reset(resetMode, commit, new CheckoutOptions());
        }

        /// <summary>
        /// Sets <see cref="Head"/> to the specified commit and optionally resets the <see cref="Index"/> and
        /// the content of the working tree to match.
        /// </summary>
        /// <param name="resetMode">Flavor of reset operation to perform.</param>
        /// <param name="commit">The target commit object.</param>
        /// <param name="opts">Collection of parameters controlling checkout behavior.</param>
        public void Reset(ResetMode resetMode, Commit commit, CheckoutOptions opts)
        {
            Ensure.ArgumentNotNull(commit, "commit");
            Ensure.ArgumentNotNull(opts, "opts");

            using (GitCheckoutOptsWrapper checkoutOptionsWrapper = new GitCheckoutOptsWrapper(opts))
            {
                var options = checkoutOptionsWrapper.Options;
                Proxy.git_reset(handle, commit.Id, resetMode, ref options);
            }
        }

        /// <summary>
        /// Updates specifed paths in the index and working directory with the versions from the specified branch, reference, or SHA.
        /// <para>
        /// This method does not switch branches or update the current repository HEAD.
        /// </para>
        /// </summary>
        /// <param name = "committishOrBranchSpec">A revparse spec for the commit or branch to checkout paths from.</param>
        /// <param name="paths">The paths to checkout. Will throw if null is passed in. Passing an empty enumeration results in nothing being checked out.</param>
        /// <param name="checkoutOptions">Collection of parameters controlling checkout behavior.</param>
        public void CheckoutPaths(string committishOrBranchSpec, IEnumerable<string> paths, CheckoutOptions checkoutOptions)
        {
            Ensure.ArgumentNotNullOrEmptyString(committishOrBranchSpec, "committishOrBranchSpec");
            Ensure.ArgumentNotNull(paths, "paths");

            var listOfPaths = paths.ToList();

            // If there are no paths, then there is nothing to do.
            if (listOfPaths.Count == 0)
            {
                return;
            }

            Commit commit = LookupCommit(committishOrBranchSpec);

            CheckoutTree(commit.Tree, listOfPaths, checkoutOptions ?? new CheckoutOptions());
        }

        /// <summary>
        /// Stores the content of the <see cref="Repository.Index"/> as a new <see cref="LibGit2Sharp.Commit"/> into the repository.
        /// The tip of the <see cref="Repository.Head"/> will be used as the parent of this new Commit.
        /// Once the commit is created, the <see cref="Repository.Head"/> will move forward to point at it.
        /// </summary>
        /// <param name="message">The description of why a change was made to the repository.</param>
        /// <param name="author">The <see cref="Signature"/> of who made the change.</param>
        /// <param name="committer">The <see cref="Signature"/> of who added the change to the repository.</param>
        /// <param name="options">The <see cref="CommitOptions"/> that specify the commit behavior.</param>
        /// <returns>The generated <see cref="LibGit2Sharp.Commit"/>.</returns>
        public Commit Commit(string message, Signature author, Signature committer, CommitOptions options)
        {
            if (options == null)
            {
                options = new CommitOptions();
            }

            bool isHeadOrphaned = Info.IsHeadUnborn;

            if (options.AmendPreviousCommit && isHeadOrphaned)
            {
                throw new UnbornBranchException("Can not amend anything. The Head doesn't point at any commit.");
            }

            var treeId = Proxy.git_index_write_tree(Index.Handle);
            var tree = this.Lookup<Tree>(treeId);

            var parents = RetrieveParentsOfTheCommitBeingCreated(options.AmendPreviousCommit).ToList();

            if (parents.Count == 1 && !options.AllowEmptyCommit)
            {
                var treesame = parents[0].Tree.Id.Equals(treeId);
                var amendMergeCommit = options.AmendPreviousCommit && !isHeadOrphaned && Head.Tip.Parents.Count() > 1;

                if (treesame && !amendMergeCommit)
                {
                    throw (options.AmendPreviousCommit ?
                        new EmptyCommitException("Amending this commit would produce a commit that is identical to its parent (id = {0})", parents[0].Id) :
                        new EmptyCommitException("No changes; nothing to commit."));
                }
            }

            Commit result = ObjectDatabase.CreateCommit(author, committer, message, tree, parents, options.PrettifyMessage, options.CommentaryChar);

            Proxy.git_repository_state_cleanup(handle);

            var logMessage = BuildCommitLogMessage(result, options.AmendPreviousCommit, isHeadOrphaned, parents.Count > 1);
            UpdateHeadAndTerminalReference(result, logMessage);

            return result;
        }

        private static string BuildCommitLogMessage(Commit commit, bool amendPreviousCommit, bool isHeadOrphaned, bool isMergeCommit)
        {
            string kind = string.Empty;
            if (isHeadOrphaned)
            {
                kind = " (initial)";
            }
            else if (amendPreviousCommit)
            {
                kind = " (amend)";
            }
            else if (isMergeCommit)
            {
                kind = " (merge)";
            }

            return string.Format(CultureInfo.InvariantCulture, "commit{0}: {1}", kind, commit.MessageShort);
        }

        private void UpdateHeadAndTerminalReference(Commit commit, string reflogMessage)
        {
            Reference reference = Refs.Head;

            while (true) //TODO: Implement max nesting level
            {
                if (reference is DirectReference)
                {
                    Refs.UpdateTarget(reference, commit.Id, reflogMessage);
                    return;
                }

                var symRef = (SymbolicReference)reference;

                reference = symRef.Target;

                if (reference == null)
                {
                    Refs.Add(symRef.TargetIdentifier, commit.Id, reflogMessage);
                    return;
                }
            }
        }

        private IEnumerable<Commit> RetrieveParentsOfTheCommitBeingCreated(bool amendPreviousCommit)
        {
            if (amendPreviousCommit)
            {
                return Head.Tip.Parents;
            }

            if (Info.IsHeadUnborn)
            {
                return Enumerable.Empty<Commit>();
            }

            var parents = new List<Commit> { Head.Tip };

            if (Info.CurrentOperation == CurrentOperation.Merge)
            {
                parents.AddRange(MergeHeads.Select(mh => mh.Tip));
            }

            return parents;
        }

        /// <summary>
        /// Clean the working tree by removing files that are not under version control.
        /// </summary>
        public unsafe void RemoveUntrackedFiles()
        {
            var options = new GitCheckoutOpts
            {
                version = 1,
                checkout_strategy = CheckoutStrategy.GIT_CHECKOUT_REMOVE_UNTRACKED
                                     | CheckoutStrategy.GIT_CHECKOUT_ALLOW_CONFLICTS,
            };

            Proxy.git_checkout_index(Handle, new ObjectHandle(null, false), ref options);
        }

        private void CleanupDisposableDependencies()
        {
            while (toCleanup.Count > 0)
            {
                toCleanup.Pop().SafeDispose();
            }
        }

        internal T RegisterForCleanup<T>(T disposable) where T : IDisposable
        {
            toCleanup.Push(disposable);
            return disposable;
        }

        /// <summary>
        /// Merges changes from commit into the branch pointed at by HEAD.
        /// </summary>
        /// <param name="commit">The commit to merge into the branch pointed at by HEAD.</param>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <param name="options">Specifies optional parameters controlling merge behavior; if null, the defaults are used.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        public MergeResult Merge(Commit commit, Signature merger, MergeOptions options)
        {
            Ensure.ArgumentNotNull(commit, "commit");
            Ensure.ArgumentNotNull(merger, "merger");

            options = options ?? new MergeOptions();

            using (AnnotatedCommitHandle annotatedCommitHandle = Proxy.git_annotated_commit_lookup(Handle, commit.Id.Oid))
            {
                return Merge(new[] { annotatedCommitHandle }, merger, options);
            }
        }

        /// <summary>
        /// Merges changes from branch into the branch pointed at by HEAD.
        /// </summary>
        /// <param name="branch">The branch to merge into the branch pointed at by HEAD.</param>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <param name="options">Specifies optional parameters controlling merge behavior; if null, the defaults are used.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        public MergeResult Merge(Branch branch, Signature merger, MergeOptions options)
        {
            Ensure.ArgumentNotNull(branch, "branch");
            Ensure.ArgumentNotNull(merger, "merger");

            options = options ?? new MergeOptions();

            using (ReferenceHandle referencePtr = Refs.RetrieveReferencePtr(branch.CanonicalName))
            using (AnnotatedCommitHandle annotatedCommitHandle = Proxy.git_annotated_commit_from_ref(Handle, referencePtr))
            {
                return Merge(new[] { annotatedCommitHandle }, merger, options);
            }
        }

        /// <summary>
        /// Merges changes from the commit into the branch pointed at by HEAD.
        /// </summary>
        /// <param name="committish">The commit to merge into the branch pointed at by HEAD.</param>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <param name="options">Specifies optional parameters controlling merge behavior; if null, the defaults are used.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        public MergeResult Merge(string committish, Signature merger, MergeOptions options)
        {
            Ensure.ArgumentNotNull(committish, "committish");
            Ensure.ArgumentNotNull(merger, "merger");

            options = options ?? new MergeOptions();

            Commit commit = LookupCommit(committish);
            return Merge(commit, merger, options);
        }

        /// <summary>
        /// Merge the reference that was recently fetched. This will merge
        /// the branch on the fetched remote that corresponded to the
        /// current local branch when we did the fetch.  This is the
        /// second step in performing a pull operation (after having
        /// performed said fetch).
        /// </summary>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <param name="options">Specifies optional parameters controlling merge behavior; if null, the defaults are used.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        public MergeResult MergeFetchedRefs(Signature merger, MergeOptions options)
        {
            Ensure.ArgumentNotNull(merger, "merger");

            options = options ?? new MergeOptions();

            // The current FetchHeads that are marked for merging.
            FetchHead[] fetchHeads = Network.FetchHeads.Where(fetchHead => fetchHead.ForMerge).ToArray();

            if (fetchHeads.Length == 0)
            {
                var expectedRef = this.Head.UpstreamBranchCanonicalName;
                throw new MergeFetchHeadNotFoundException("The current branch is configured to merge with the reference '{0}' from the remote, but this reference was not fetched.",
                    expectedRef);
            }

            AnnotatedCommitHandle[] annotatedCommitHandles = fetchHeads.Select(fetchHead =>
                Proxy.git_annotated_commit_from_fetchhead(Handle, fetchHead.RemoteCanonicalName, fetchHead.Url, fetchHead.Target.Id.Oid)).ToArray();

            try
            {
                // Perform the merge.
                return Merge(annotatedCommitHandles, merger, options);
            }
            finally
            {
                // Cleanup.
                foreach (AnnotatedCommitHandle annotatedCommitHandle in annotatedCommitHandles)
                {
                    annotatedCommitHandle.Dispose();
                }
            }
        }

        /// <summary>
        /// Revert the specified commit.
        /// <para>
        ///  If the revert is successful but there are no changes to commit,
        ///  then the <see cref="RevertStatus"/> will be <see cref="RevertStatus.NothingToRevert"/>.
        ///  If the revert is successful and there are changes to revert, then
        ///  the <see cref="RevertStatus"/> will be <see cref="RevertStatus.Reverted"/>.
        ///  If the revert resulted in conflicts, then the <see cref="RevertStatus"/>
        ///  will be <see cref="RevertStatus.Conflicts"/>.
        /// </para>
        /// </summary>
        /// <param name="commit">The <see cref="Commit"/> to revert.</param>
        /// <param name="reverter">The <see cref="Signature"/> of who is performing the revert.</param>
        /// <param name="options"><see cref="RevertOptions"/> controlling revert behavior.</param>
        /// <returns>The result of the revert.</returns>
        public RevertResult Revert(Commit commit, Signature reverter, RevertOptions options)
        {
            Ensure.ArgumentNotNull(commit, "commit");
            Ensure.ArgumentNotNull(reverter, "reverter");

            if (Info.IsHeadUnborn)
            {
                throw new UnbornBranchException("Can not revert the commit. The Head doesn't point at a commit.");
            }

            options = options ?? new RevertOptions();

            RevertResult result = null;

            using (GitCheckoutOptsWrapper checkoutOptionsWrapper = new GitCheckoutOptsWrapper(options))
            {
                var mergeOptions = new GitMergeOpts
                {
                    Version = 1,
                    MergeFileFavorFlags = options.MergeFileFavor,
                    MergeTreeFlags = options.FindRenames ? GitMergeFlag.GIT_MERGE_FIND_RENAMES :
                                                           GitMergeFlag.GIT_MERGE_NORMAL,
                    RenameThreshold = (uint)options.RenameThreshold,
                    TargetLimit = (uint)options.TargetLimit,
                };

                GitRevertOpts gitRevertOpts = new GitRevertOpts()
                {
                    Mainline = (uint)options.Mainline,
                    MergeOpts = mergeOptions,

                    CheckoutOpts = checkoutOptionsWrapper.Options,
                };

                Proxy.git_revert(handle, commit.Id.Oid, gitRevertOpts);

                if (Index.IsFullyMerged)
                {
                    Commit revertCommit = null;

                    // Check if the revert generated any changes
                    // and set the revert status accordingly
                    bool anythingToRevert = RetrieveStatus(
                        new StatusOptions()
                        {
                            DetectRenamesInIndex = false,
                            Show = StatusShowOption.IndexOnly
                        }).Any();

                    RevertStatus revertStatus = anythingToRevert ?
                        RevertStatus.Reverted : RevertStatus.NothingToRevert;

                    if (options.CommitOnSuccess)
                    {
                        if (!anythingToRevert)
                        {
                            // If there were no changes to revert, and we are
                            // asked to commit the changes, then cleanup
                            // the repository state (following command line behavior).
                            Proxy.git_repository_state_cleanup(handle);
                        }
                        else
                        {
                            revertCommit = this.Commit(
                                Info.Message,
                                author: reverter,
                                committer: reverter,
                                options: null);
                        }
                    }

                    result = new RevertResult(revertStatus, revertCommit);
                }
                else
                {
                    result = new RevertResult(RevertStatus.Conflicts);
                }
            }

            return result;
        }

        /// <summary>
        /// Cherry-picks the specified commit.
        /// </summary>
        /// <param name="commit">The <see cref="Commit"/> to cherry-pick.</param>
        /// <param name="committer">The <see cref="Signature"/> of who is performing the cherry pick.</param>
        /// <param name="options"><see cref="CherryPickOptions"/> controlling cherry pick behavior.</param>
        /// <returns>The result of the cherry pick.</returns>
        public CherryPickResult CherryPick(Commit commit, Signature committer, CherryPickOptions options)
        {
            Ensure.ArgumentNotNull(commit, "commit");
            Ensure.ArgumentNotNull(committer, "committer");

            options = options ?? new CherryPickOptions();

            CherryPickResult result = null;

            using (var checkoutOptionsWrapper = new GitCheckoutOptsWrapper(options))
            {
                var mergeOptions = new GitMergeOpts
                {
                    Version = 1,
                    MergeFileFavorFlags = options.MergeFileFavor,
                    MergeTreeFlags = options.FindRenames ? GitMergeFlag.GIT_MERGE_FIND_RENAMES :
                                                           GitMergeFlag.GIT_MERGE_NORMAL,
                    RenameThreshold = (uint)options.RenameThreshold,
                    TargetLimit = (uint)options.TargetLimit,
                };

                var gitCherryPickOpts = new GitCherryPickOptions()
                {
                    Mainline = (uint)options.Mainline,
                    MergeOpts = mergeOptions,

                    CheckoutOpts = checkoutOptionsWrapper.Options,
                };

                Proxy.git_cherrypick(handle, commit.Id.Oid, gitCherryPickOpts);

                if (Index.IsFullyMerged)
                {
                    Commit cherryPickCommit = null;
                    if (options.CommitOnSuccess)
                    {
                        cherryPickCommit = this.Commit(Info.Message, commit.Author, committer, null);
                    }

                    result = new CherryPickResult(CherryPickStatus.CherryPicked, cherryPickCommit);
                }
                else
                {
                    result = new CherryPickResult(CherryPickStatus.Conflicts);
                }
            }

            return result;
        }

        private FastForwardStrategy FastForwardStrategyFromMergePreference(GitMergePreference preference)
        {
            switch (preference)
            {
                case GitMergePreference.GIT_MERGE_PREFERENCE_NONE:
                    return FastForwardStrategy.Default;
                case GitMergePreference.GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY:
                    return FastForwardStrategy.FastForwardOnly;
                case GitMergePreference.GIT_MERGE_PREFERENCE_NO_FASTFORWARD:
                    return FastForwardStrategy.NoFastForward;
                default:
                    throw new InvalidOperationException(String.Format("Unknown merge preference: {0}", preference));
            }
        }

        /// <summary>
        /// Internal implementation of merge.
        /// </summary>
        /// <param name="annotatedCommits">Merge heads to operate on.</param>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <param name="options">Specifies optional parameters controlling merge behavior; if null, the defaults are used.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        private MergeResult Merge(AnnotatedCommitHandle[] annotatedCommits, Signature merger, MergeOptions options)
        {
            GitMergeAnalysis mergeAnalysis;
            GitMergePreference mergePreference;

            Proxy.git_merge_analysis(Handle, annotatedCommits, out mergeAnalysis, out mergePreference);

            MergeResult mergeResult = null;

            if ((mergeAnalysis & GitMergeAnalysis.GIT_MERGE_ANALYSIS_UP_TO_DATE) == GitMergeAnalysis.GIT_MERGE_ANALYSIS_UP_TO_DATE)
            {
                return new MergeResult(MergeStatus.UpToDate);
            }

            FastForwardStrategy fastForwardStrategy = (options.FastForwardStrategy != FastForwardStrategy.Default) ?
                options.FastForwardStrategy : FastForwardStrategyFromMergePreference(mergePreference);

            switch (fastForwardStrategy)
            {
                case FastForwardStrategy.Default:
                    if (mergeAnalysis.HasFlag(GitMergeAnalysis.GIT_MERGE_ANALYSIS_FASTFORWARD))
                    {
                        if (annotatedCommits.Length != 1)
                        {
                            // We should not reach this code unless there is a bug somewhere.
                            throw new LibGit2SharpException("Unable to perform Fast-Forward merge with mith multiple merge heads.");
                        }

                        mergeResult = FastForwardMerge(annotatedCommits[0], options);
                    }
                    else if (mergeAnalysis.HasFlag(GitMergeAnalysis.GIT_MERGE_ANALYSIS_NORMAL))
                    {
                        mergeResult = NormalMerge(annotatedCommits, merger, options);
                    }
                    break;
                case FastForwardStrategy.FastForwardOnly:
                    if (mergeAnalysis.HasFlag(GitMergeAnalysis.GIT_MERGE_ANALYSIS_FASTFORWARD))
                    {
                        if (annotatedCommits.Length != 1)
                        {
                            // We should not reach this code unless there is a bug somewhere.
                            throw new LibGit2SharpException("Unable to perform Fast-Forward merge with mith multiple merge heads.");
                        }

                        mergeResult = FastForwardMerge(annotatedCommits[0], options);
                    }
                    else
                    {
                        // TODO: Maybe this condition should rather be indicated through the merge result
                        //       instead of throwing an exception.
                        throw new NonFastForwardException("Cannot perform fast-forward merge.");
                    }
                    break;
                case FastForwardStrategy.NoFastForward:
                    if (mergeAnalysis.HasFlag(GitMergeAnalysis.GIT_MERGE_ANALYSIS_NORMAL))
                    {
                        mergeResult = NormalMerge(annotatedCommits, merger, options);
                    }
                    break;
                default:
                    throw new NotImplementedException(
                        string.Format(CultureInfo.InvariantCulture, "Unknown fast forward strategy: {0}", fastForwardStrategy));
            }

            if (mergeResult == null)
            {
                throw new NotImplementedException(
                    string.Format(CultureInfo.InvariantCulture, "Unknown merge analysis: {0}", mergeAnalysis));
            }

            return mergeResult;
        }

        /// <summary>
        /// Perform a normal merge (i.e. a non-fast-forward merge).
        /// </summary>
        /// <param name="annotatedCommits">The merge head handles to merge.</param>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <param name="options">Specifies optional parameters controlling merge behavior; if null, the defaults are used.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        private MergeResult NormalMerge(AnnotatedCommitHandle[] annotatedCommits, Signature merger, MergeOptions options)
        {
            MergeResult mergeResult;
            GitMergeFlag treeFlags = options.FindRenames ? GitMergeFlag.GIT_MERGE_FIND_RENAMES
                                                              : GitMergeFlag.GIT_MERGE_NORMAL;

            if (options.FailOnConflict)
            {
                treeFlags |= GitMergeFlag.GIT_MERGE_FAIL_ON_CONFLICT;
            }

            if (options.SkipReuc)
            {
                treeFlags |= GitMergeFlag.GIT_MERGE_SKIP_REUC;
            }

            var fileFlags = options.IgnoreWhitespaceChange
                ? GitMergeFileFlag.GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE
                : GitMergeFileFlag.GIT_MERGE_FILE_DEFAULT;

            var mergeOptions = new GitMergeOpts
            {
                Version = 1,
                MergeFileFavorFlags = options.MergeFileFavor,
                MergeTreeFlags = treeFlags,
                RenameThreshold = (uint)options.RenameThreshold,
                TargetLimit = (uint)options.TargetLimit,
                FileFlags = fileFlags
            };

            bool earlyStop;
            using (GitCheckoutOptsWrapper checkoutOptionsWrapper = new GitCheckoutOptsWrapper(options))
            {
                var checkoutOpts = checkoutOptionsWrapper.Options;

                Proxy.git_merge(Handle, annotatedCommits, mergeOptions, checkoutOpts, out earlyStop);
            }

            if (earlyStop)
            {
                return new MergeResult(MergeStatus.Conflicts);
            }

            if (Index.IsFullyMerged)
            {
                Commit mergeCommit = null;
                if (options.CommitOnSuccess)
                {
                    // Commit the merge
                    mergeCommit = Commit(Info.Message, author: merger, committer: merger, options: null);
                }

                mergeResult = new MergeResult(MergeStatus.NonFastForward, mergeCommit);
            }
            else
            {
                mergeResult = new MergeResult(MergeStatus.Conflicts);
            }

            return mergeResult;
        }

        /// <summary>
        /// Perform a fast-forward merge.
        /// </summary>
        /// <param name="annotatedCommit">The merge head handle to fast-forward merge.</param>
        /// <param name="options">Options controlling merge behavior.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        private MergeResult FastForwardMerge(AnnotatedCommitHandle annotatedCommit, MergeOptions options)
        {
            ObjectId id = Proxy.git_annotated_commit_id(annotatedCommit);
            Commit fastForwardCommit = (Commit)Lookup(id, ObjectType.Commit);
            Ensure.GitObjectIsNotNull(fastForwardCommit, id.Sha);

            CheckoutTree(fastForwardCommit.Tree, null, new FastForwardCheckoutOptionsAdapter(options));

            var reference = Refs.Head.ResolveToDirectReference();

            // TODO: This reflog entry could be more specific
            string refLogEntry = string.Format(
                CultureInfo.InvariantCulture, "merge {0}: Fast-forward", fastForwardCommit.Sha);

            if (reference == null)
            {
                // Reference does not exist, create it.
                Refs.Add(Refs.Head.TargetIdentifier, fastForwardCommit.Id, refLogEntry);
            }
            else
            {
                // Update target reference.
                Refs.UpdateTarget(reference, fastForwardCommit.Id.Sha, refLogEntry);
            }

            return new MergeResult(MergeStatus.FastForward, fastForwardCommit);
        }

        /// <summary>
        /// Gets the references to the tips that are currently being merged.
        /// </summary>
        internal IEnumerable<MergeHead> MergeHeads
        {
            get
            {
                int i = 0;
                return Proxy.git_repository_mergehead_foreach(Handle,
                    commitId => new MergeHead(this, commitId, i++));
            }
        }

        internal StringComparer PathComparer
        {
            get { return pathCase.Value.Comparer; }
        }

        internal FilePath[] ToFilePaths(IEnumerable<string> paths)
        {
            if (paths == null)
            {
                return null;
            }

            var filePaths = new List<FilePath>();

            foreach (string path in paths)
            {
                if (string.IsNullOrEmpty(path))
                {
                    throw new ArgumentException("At least one provided path is either null or empty.", "paths");
                }

                filePaths.Add(this.BuildRelativePathFrom(path));
            }

            if (filePaths.Count == 0)
            {
                throw new ArgumentException("No path has been provided.", "paths");
            }

            return filePaths.ToArray();
        }

        /// <summary>
        /// Retrieves the state of a file in the working directory, comparing it against the staging area and the latest commit.
        /// </summary>
        /// <param name="filePath">The relative path within the working directory to the file.</param>
        /// <returns>A <see cref="FileStatus"/> representing the state of the <paramref name="filePath"/> parameter.</returns>
        public FileStatus RetrieveStatus(string filePath)
        {
            Ensure.ArgumentNotNullOrEmptyString(filePath, "filePath");

            string relativePath = this.BuildRelativePathFrom(filePath);

            return Proxy.git_status_file(Handle, relativePath);
        }

        /// <summary>
        /// Retrieves the state of all files in the working directory, comparing them against the staging area and the latest commit.
        /// </summary>
        /// <param name="options">If set, the options that control the status investigation.</param>
        /// <returns>A <see cref="RepositoryStatus"/> holding the state of all the files.</returns>
        public RepositoryStatus RetrieveStatus(StatusOptions options)
        {
            ReloadFromDisk();

            return new RepositoryStatus(this, options);
        }

        internal void ReloadFromDisk()
        {
            Proxy.git_index_read(Index.Handle);
        }

        internal void AddToIndex(string relativePath)
        {
            if (!Submodules.TryStage(relativePath, true))
            {
                Proxy.git_index_add_bypath(Index.Handle, relativePath);
            }
        }

        internal string RemoveFromIndex(string relativePath)
        {
            Proxy.git_index_remove_bypath(Index.Handle, relativePath);

            return relativePath;
        }

        internal void UpdatePhysicalIndex()
        {
            Proxy.git_index_write(Index.Handle);
        }

        /// <summary>
        /// Finds the most recent annotated tag that is reachable from a commit.
        /// <para>
        ///   If the tag points to the commit, then only the tag is shown. Otherwise,
        ///   it suffixes the tag name with the number of additional commits on top
        ///   of the tagged object and the abbreviated object name of the most recent commit.
        /// </para>
        /// <para>
        ///   Optionally, the <paramref name="options"/> parameter allow to tweak the
        ///   search strategy (considering lightweight tags, or even branches as reference points)
        ///   and the formatting of the returned identifier.
        /// </para>
        /// </summary>
        /// <param name="commit">The commit to be described.</param>
        /// <param name="options">Determines how the commit will be described.</param>
        /// <returns>A descriptive identifier for the commit based on the nearest annotated tag.</returns>
        public string Describe(Commit commit, DescribeOptions options)
        {
            Ensure.ArgumentNotNull(commit, "commit");
            Ensure.ArgumentNotNull(options, "options");

            return Proxy.git_describe_commit(handle, commit.Id, options);
        }

        /// <summary>
        /// Parse an extended SHA-1 expression and retrieve the object and the reference
        /// mentioned in the revision (if any).
        /// </summary>
        /// <param name="revision">An extended SHA-1 expression for the object to look up</param>
        /// <param name="reference">The reference mentioned in the revision (if any)</param>
        /// <param name="obj">The object which the revision resolves to</param>
        public void RevParse(string revision, out Reference reference, out GitObject obj)
        {
            var handles = Proxy.git_revparse_ext(Handle, revision);
            if (handles == null)
            {
                Ensure.GitObjectIsNotNull(null, revision);
            }

            using (var objH = handles.Item1)
            using (var refH = handles.Item2)
            {
                reference = refH.IsNull ? null : Reference.BuildFromPtr<Reference>(refH, this);
                obj = GitObject.BuildFrom(this, Proxy.git_object_id(objH), Proxy.git_object_type(objH), PathFromRevparseSpec(revision));
            }
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0} = \"{1}\"",
                                     Info.IsBare ? "Gitdir" : "Workdir",
                                     Info.IsBare ? Info.Path : Info.WorkingDirectory);
            }
        }
    }

    /// <summary>
    /// Provides helper overloads to a <see cref="Repository"/>.
    /// </summary>
    public static class RepositoryExtensions
    {
        /// <summary>
        /// Try to lookup an object by its sha or a reference name.
        /// </summary>
        /// <typeparam name="T">The kind of <see cref="GitObject"/> to lookup.</typeparam>
        /// <param name="repository">The <see cref="Repository"/> being looked up.</param>
        /// <param name="objectish">The revparse spec for the object to lookup.</param>
        /// <returns>The retrieved <see cref="GitObject"/>, or <c>null</c> if none was found.</returns>
        public static T Lookup<T>(this IRepository repository, string objectish) where T : GitObject
        {
            EnsureNoGitLink<T>();

            if (typeof (T) == typeof (GitObject))
            {
                return (T)repository.Lookup(objectish);
            }

            return (T)repository.Lookup(objectish, GitObject.TypeToKindMap[typeof(T)]);
        }

        /// <summary>
        /// Try to lookup an object by its <see cref="ObjectId"/>.
        /// </summary>
        /// <typeparam name="T">The kind of <see cref="GitObject"/> to lookup.</typeparam>
        /// <param name="repository">The <see cref="Repository"/> being looked up.</param>
        /// <param name="id">The id.</param>
        /// <returns>The retrieved <see cref="GitObject"/>, or <c>null</c> if none was found.</returns>
        public static T Lookup<T>(this IRepository repository, ObjectId id) where T : GitObject
        {
            EnsureNoGitLink<T>();

            if (typeof(T) == typeof(GitObject))
            {
                return (T)repository.Lookup(id);
            }

            return (T)repository.Lookup(id, GitObject.TypeToKindMap[typeof(T)]);
        }

        private static void EnsureNoGitLink<T>() where T : GitObject
        {
            if (typeof(T) != typeof(GitLink))
            {
                return;
            }

            throw new ArgumentException("A GitObject of type 'GitLink' cannot be looked up.");
        }

        /// <summary>
        /// Creates a lightweight tag with the specified name. This tag will point at the commit pointed at by the <see cref="Repository.Head"/>.
        /// </summary>
        /// <param name="repository">The <see cref="Repository"/> being worked with.</param>
        /// <param name="tagName">The name of the tag to create.</param>
        public static Tag ApplyTag(this IRepository repository, string tagName)
        {
            return repository.Tags.Add(tagName, RetrieveHeadCommit(repository));
        }

        /// <summary>
        /// Creates a lightweight tag with the specified name. This tag will point at the <paramref name="objectish"/>.
        /// </summary>
        /// <param name="repository">The <see cref="Repository"/> being worked with.</param>
        /// <param name="tagName">The name of the tag to create.</param>
        /// <param name="objectish">The revparse spec for the target object.</param>
        public static Tag ApplyTag(this IRepository repository, string tagName, string objectish)
        {
            return repository.Tags.Add(tagName, objectish);
        }

        /// <summary>
        /// Creates an annotated tag with the specified name. This tag will point at the commit pointed at by the <see cref="Repository.Head"/>.
        /// </summary>
        /// <param name="repository">The <see cref="Repository"/> being worked with.</param>
        /// <param name="tagName">The name of the tag to create.</param>
        /// <param name="tagger">The identity of the creator of this tag.</param>
        /// <param name="message">The annotation message.</param>
        public static Tag ApplyTag(this IRepository repository, string tagName, Signature tagger, string message)
        {
            return repository.Tags.Add(tagName, RetrieveHeadCommit(repository), tagger, message);
        }

        private static Commit RetrieveHeadCommit(IRepository repository)
        {
            Commit commit = repository.Head.Tip;

            Ensure.GitObjectIsNotNull(commit, "HEAD");

            return commit;
        }

        /// <summary>
        /// Creates an annotated tag with the specified name. This tag will point at the <paramref name="objectish"/>.
        /// </summary>
        /// <param name="repository">The <see cref="Repository"/> being worked with.</param>
        /// <param name="tagName">The name of the tag to create.</param>
        /// <param name="objectish">The revparse spec for the target object.</param>
        /// <param name="tagger">The identity of the creator of this tag.</param>
        /// <param name="message">The annotation message.</param>
        public static Tag ApplyTag(this IRepository repository, string tagName, string objectish, Signature tagger, string message)
        {
            return repository.Tags.Add(tagName, objectish, tagger, message);
        }

        /// <summary>
        /// Creates a branch with the specified name. This branch will point at the commit pointed at by the <see cref="Repository.Head"/>.
        /// </summary>
        /// <param name="repository">The <see cref="Repository"/> being worked with.</param>
        /// <param name="branchName">The name of the branch to create.</param>
        public static Branch CreateBranch(this IRepository repository, string branchName)
        {
            var head = repository.Head;
            var reflogName = head is DetachedHead ? head.Tip.Sha : head.FriendlyName;

            return CreateBranch(repository, branchName, reflogName);
        }

        /// <summary>
        /// Creates a branch with the specified name. This branch will point at <paramref name="target"/>.
        /// </summary>
        /// <param name="repository">The <see cref="Repository"/> being worked with.</param>
        /// <param name="branchName">The name of the branch to create.</param>
        /// <param name="target">The commit which should be pointed at by the Branch.</param>
        public static Branch CreateBranch(this IRepository repository, string branchName, Commit target)
        {
            return repository.Branches.Add(branchName, target);
        }

        /// <summary>
        /// Creates a branch with the specified name. This branch will point at the commit pointed at by the <see cref="Repository.Head"/>.
        /// </summary>
        /// <param name="repository">The <see cref="Repository"/> being worked with.</param>
        /// <param name="branchName">The name of the branch to create.</param>
        /// <param name="committish">The revparse spec for the target commit.</param>
        public static Branch CreateBranch(this IRepository repository, string branchName, string committish)
        {
            return repository.Branches.Add(branchName, committish);
        }

        /// <summary>
        /// Sets the current <see cref="Repository.Head"/> and resets the <see cref="Index"/> and
        /// the content of the working tree to match.
        /// </summary>
        /// <param name="repository">The <see cref="Repository"/> being worked with.</param>
        /// <param name="resetMode">Flavor of reset operation to perform.</param>
        public static void Reset(this IRepository repository, ResetMode resetMode)
        {
            repository.Reset(resetMode, "HEAD");
        }

        /// <summary>
        /// Sets the current <see cref="Repository.Head"/> to the specified commitish and optionally resets the <see cref="Index"/> and
        /// the content of the working tree to match.
        /// </summary>
        /// <param name="repository">The <see cref="Repository"/> being worked with.</param>
        /// <param name="resetMode">Flavor of reset operation to perform.</param>
        /// <param name="committish">A revparse spec for the target commit object.</param>
        public static void Reset(this IRepository repository, ResetMode resetMode, string committish)
        {
            Ensure.ArgumentNotNullOrEmptyString(committish, "committish");

            Commit commit = LookUpCommit(repository, committish);

            repository.Reset(resetMode, commit);
        }

        private static Commit LookUpCommit(IRepository repository, string committish)
        {
            GitObject obj = repository.Lookup(committish);
            Ensure.GitObjectIsNotNull(obj, committish);
            return obj.Peel<Commit>(true);
        }

        /// <summary>
        /// Stores the content of the <see cref="Repository.Index"/> as a new <see cref="LibGit2Sharp.Commit"/> into the repository.
        /// The tip of the <see cref="Repository.Head"/> will be used as the parent of this new Commit.
        /// Once the commit is created, the <see cref="Repository.Head"/> will move forward to point at it.
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name="message">The description of why a change was made to the repository.</param>
        /// <param name="author">The <see cref="Signature"/> of who made the change.</param>
        /// <param name="committer">The <see cref="Signature"/> of who added the change to the repository.</param>
        /// <returns>The generated <see cref="LibGit2Sharp.Commit"/>.</returns>
        public static Commit Commit(this IRepository repository, string message, Signature author, Signature committer)
        {
            return repository.Commit(message, author, committer, default(CommitOptions));
        }

        internal static string BuildRelativePathFrom(this IRepository repo, string path)
        {
            //TODO: To be removed when libgit2 natively implements this
            if (!Path.IsPathRooted(path))
            {
                return path;
            }

            string normalizedPath = Path.GetFullPath(path);

            if (!PathStartsWith(repo, normalizedPath, repo.Info.WorkingDirectory))
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture,
                                                          "Unable to process file '{0}'. This file is not located under the working directory of the repository ('{1}').",
                                                          normalizedPath,
                                                          repo.Info.WorkingDirectory));
            }

            return normalizedPath.Substring(repo.Info.WorkingDirectory.Length);
        }

        internal static bool PathStartsWith(IRepository repository, string path, string value)
        {
            var pathCase = new PathCase(repository);
            return pathCase.StartsWith(path, value);
        }

        private static ObjectId DereferenceToCommit(Repository repo, string identifier)
        {
            var options = LookUpOptions.DereferenceResultToCommit;

            if (!AllowOrphanReference(repo, identifier))
            {
                options |= LookUpOptions.ThrowWhenNoGitObjectHasBeenFound;
            }

            // TODO: Should we check the type? Git-log allows TagAnnotation oid as parameter. But what about Blobs and Trees?
            GitObject commit = repo.Lookup(identifier, GitObjectType.Any, options);

            return commit != null ? commit.Id : null;
        }

        private static bool AllowOrphanReference(IRepository repo, string identifier)
        {
            return string.Equals(identifier, "HEAD", StringComparison.Ordinal)
                   || string.Equals(identifier, repo.Head.CanonicalName, StringComparison.Ordinal);
        }

        private static ObjectId SingleCommittish(this Repository repo, object identifier)
        {
            if (ReferenceEquals(identifier, null))
            {
                return null;
            }

            if (identifier is string)
            {
                return DereferenceToCommit(repo, (string)identifier);
            }

            if (identifier is ObjectId)
            {
                return DereferenceToCommit(repo, ((ObjectId)identifier).Sha);
            }

            if (identifier is Commit)
            {
                return ((Commit)identifier).Id;
            }

            if (identifier is TagAnnotation)
            {
                return DereferenceToCommit(repo, ((TagAnnotation)identifier).Target.Id.Sha);
            }

            if (identifier is Tag)
            {
                return DereferenceToCommit(repo, ((Tag)identifier).Target.Id.Sha);
            }

            var branch = identifier as Branch;
            if (branch != null)
            {
                if (branch.Tip != null || !branch.IsCurrentRepositoryHead)
                {
                    Ensure.GitObjectIsNotNull(branch.Tip, branch.CanonicalName);
                    return branch.Tip.Id;
                }
            }

            if (identifier is Reference)
            {
                return DereferenceToCommit(repo, ((Reference)identifier).CanonicalName);
            }

            return null;
        }

        /// <summary>
        /// Dereferences the passed identifier to a commit. If the identifier is enumerable, all items are dereferenced.
        /// </summary>
        /// <param name="repo">Repository to search</param>
        /// <param name="identifier">Committish to dereference</param>
        /// <param name="throwIfNotFound">If true, allow thrown exceptions to propagate. If false, exceptions will be swallowed and null returned.</param>
        /// <returns>A series of commit <see cref="ObjectId"/>s which identify commit objects.</returns>
        internal static IEnumerable<ObjectId> Committishes(this Repository repo, object identifier, bool throwIfNotFound = false)
        {
            var singleReturnValue = repo.SingleCommittish(identifier);

            if (singleReturnValue != null)
            {
                yield return singleReturnValue;
                yield break;
            }

            if (identifier is IEnumerable)
            {
                foreach (object entry in (IEnumerable)identifier)
                {
                    foreach (ObjectId oid in Committishes(repo, entry))
                    {
                        yield return oid;
                    }
                }

                yield break;
            }

            if (throwIfNotFound)
            {
                throw new LibGit2SharpException("Unexpected kind of identifier '{0}'.", identifier);
            }

            yield return null;
        }

        /// <summary>
        /// Dereference the identifier to a commit. If the identifier is enumerable, dereference the first element.
        /// </summary>
        /// <param name="repo">The <see cref="Repository"/> to search</param>
        /// <param name="identifier">Committish to dereference</param>
        /// <returns>An <see cref="ObjectId"/> for a commit object.</returns>
        internal static ObjectId Committish(this Repository repo, object identifier)
        {
            return repo.Committishes(identifier, true).First();
        }

        /// <summary>
        /// Merges changes from branch into the branch pointed at by HEAD.
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name="branch">The branch to merge into the branch pointed at by HEAD.</param>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        public static MergeResult Merge(this IRepository repository, Branch branch, Signature merger)
        {
            return repository.Merge(branch, merger, null);
        }

        /// <summary>
        /// Merges changes from the commit into the branch pointed at by HEAD.
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name="committish">The commit to merge into the branch pointed at by HEAD.</param>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        public static MergeResult Merge(this IRepository repository, string committish, Signature merger)
        {
            return repository.Merge(committish, merger, null);
        }

        /// <summary>
        /// Updates specifed paths in the index and working directory with the versions from the specified branch, reference, or SHA.
        /// <para>
        /// This method does not switch branches or update the current repository HEAD.
        /// </para>
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name = "committishOrBranchSpec">A revparse spec for the commit or branch to checkout paths from.</param>
        /// <param name="paths">The paths to checkout. Will throw if null is passed in. Passing an empty enumeration results in nothing being checked out.</param>
        public static void CheckoutPaths(this IRepository repository, string committishOrBranchSpec, IEnumerable<string> paths)
        {
            repository.CheckoutPaths(committishOrBranchSpec, paths, null);
        }

        /// <summary>
        /// Sets the current <see cref="IRepository.Head"/> to the specified commit and optionally resets the <see cref="Index"/> and
        /// the content of the working tree to match.
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name="resetMode">Flavor of reset operation to perform.</param>
        /// <param name="commit">The target commit object.</param>
        public static void Reset(this IRepository repository, ResetMode resetMode, Commit commit)
        {
            repository.Reset(resetMode, commit);
        }

        /// <summary>
        /// Find where each line of a file originated.
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name="path">Path of the file to blame.</param>
        /// <returns>The blame for the file.</returns>
        public static BlameHunkCollection Blame(this IRepository repository, string path)
        {
            return repository.Blame(path, null);
        }

        /// <summary>
        /// Cherry-picks the specified commit.
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name="commit">The <see cref="LibGit2Sharp.Commit"/> to cherry-pick.</param>
        /// <param name="committer">The <see cref="Signature"/> of who is performing the cherry pick.</param>
        /// <returns>The result of the cherry pick.</returns>
        public static CherryPickResult CherryPick(this IRepository repository, Commit commit, Signature committer)
        {
            return repository.CherryPick(commit, committer, null);
        }

        /// <summary>
        /// Merges changes from commit into the branch pointed at by HEAD.
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name="commit">The commit to merge into the branch pointed at by HEAD.</param>
        /// <param name="merger">The <see cref="Signature"/> of who is performing the merge.</param>
        /// <returns>The <see cref="MergeResult"/> of the merge.</returns>
        public static MergeResult Merge(this IRepository repository, Commit commit, Signature merger)
        {
            return repository.Merge(commit, merger, null);
        }

        /// <summary>
        /// Revert the specified commit.
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name="commit">The <see cref="LibGit2Sharp.Commit"/> to revert.</param>
        /// <param name="reverter">The <see cref="Signature"/> of who is performing the revert.</param>
        /// <returns>The result of the revert.</returns>
        public static RevertResult Revert(this IRepository repository, Commit commit, Signature reverter)
        {
            return repository.Revert(commit, reverter, null);
        }

        /// <summary>
        /// Retrieves the state of all files in the working directory, comparing them against the staging area and the latest commit.
        /// </summary>
        /// <returns>A <see cref="RepositoryStatus"/> holding the state of all the files.</returns>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        public static RepositoryStatus RetrieveStatus(this IRepository repository)
        {
            Proxy.git_index_read(repository.Index.Handle);
            return new RepositoryStatus((Repository)repository, null);
        }

        /// <summary>
        /// Finds the most recent annotated tag that is reachable from a commit.
        /// <para>
        ///   If the tag points to the commit, then only the tag is shown. Otherwise,
        ///   it suffixes the tag name with the number of additional commits on top
        ///   of the tagged object and the abbreviated object name of the most recent commit.
        /// </para>
        /// </summary>
        /// <param name="repository">The <see cref="IRepository"/> being worked with.</param>
        /// <param name="commit">The commit to be described.</param>
        /// <returns>A descriptive identifier for the commit based on the nearest annotated tag.</returns>
        public static string Describe(this IRepository repository, Commit commit)
        {
            return repository.Describe(commit, new DescribeOptions());
        }
    }

    /// <summary>
    /// Provides high level information about a repository.
    /// </summary>
    public class RepositoryInformation
    {
        private readonly Repository repo;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected RepositoryInformation()
        { }

        internal RepositoryInformation(Repository repo, bool isBare)
        {
            this.repo = repo;
            IsBare = isBare;

            FilePath path = Proxy.git_repository_path(repo.Handle);
            FilePath workingDirectoryPath = Proxy.git_repository_workdir(repo.Handle);

            Path = path == null ? null : path.Native;
            WorkingDirectory = workingDirectoryPath == null ? null : workingDirectoryPath.Native;
            IsShallow = Proxy.git_repository_is_shallow(repo.Handle);
        }

        /// <summary>
        /// Gets the normalized path to the git repository.
        /// </summary>
        public virtual string Path { get; private set; }

        /// <summary>
        /// Gets the normalized path to the working directory.
        /// <para>
        ///   If the repository is bare, null is returned.
        /// </para>
        /// </summary>
        public virtual string WorkingDirectory { get; private set; }

        /// <summary>
        /// Indicates whether the repository has a working directory.
        /// </summary>
        public virtual bool IsBare { get; private set; }

        /// <summary>
        /// Indicates whether the repository is shallow (the result of `git clone --depth ...`)
        /// </summary>
        public virtual bool IsShallow { get; private set; }

        /// <summary>
        /// Indicates whether the Head points to an arbitrary commit instead of the tip of a local branch.
        /// </summary>
        public virtual bool IsHeadDetached
        {
            get { return Proxy.git_repository_head_detached(repo.Handle); }
        }

        /// <summary>
        /// Indicates whether the Head points to a reference which doesn't exist.
        /// </summary>
        public virtual bool IsHeadUnborn
        {
            get { return Proxy.git_repository_head_unborn(repo.Handle); }
        }

        /// <summary>
        /// The pending interactive operation.
        /// </summary>
        public virtual CurrentOperation CurrentOperation
        {
            get { return Proxy.git_repository_state(repo.Handle); }
        }

        /// <summary>
        /// The message for a pending interactive operation.
        /// </summary>
        public virtual string Message
        {
            get { return Proxy.git_repository_message(repo.Handle); }
        }
    }

    /// <summary>
    /// The exception that is thrown when a <see cref="Repository"/> is being built with
    /// a path that doesn't point at a valid Git repository or workdir.
    /// </summary>
    [Serializable]
    public class RepositoryNotFoundException : LibGit2SharpException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryNotFoundException"/> class.
        /// </summary>
        public RepositoryNotFoundException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryNotFoundException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public RepositoryNotFoundException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryNotFoundException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public RepositoryNotFoundException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryNotFoundException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public RepositoryNotFoundException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryNotFoundException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected RepositoryNotFoundException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }
    }

    /// <summary>
    /// Class to convey information about the repository that is being operated on
    /// for operations that can recurse into submodules.
    /// </summary>
    public class RepositoryOperationContext
    {
        /// <summary>
        /// Needed for mocking.
        /// </summary>
        protected RepositoryOperationContext()
        { }

        /// <summary>
        /// Constructor suitable for use on the repository the main
        /// operation is being run on (i.e. the super project, not a submodule).
        /// </summary>
        /// <param name="repositoryPath">The path of the repository being operated on.</param>
        /// <param name="remoteUrl">The URL that this operation will download from.</param>
        internal RepositoryOperationContext(string repositoryPath, string remoteUrl)
            : this(repositoryPath, remoteUrl, string.Empty, string.Empty, 0)
        { }

        /// <summary>
        /// Constructor suitable for use on the sub repositories.
        /// </summary>
        /// <param name="repositoryPath">The path of the repository being operated on.</param>
        /// <param name="remoteUrl">The URL that this operation will download from.</param>
        /// <param name="parentRepositoryPath">The path to the super repository.</param>
        /// <param name="submoduleName">The logical name of this submodule.</param>
        /// <param name="recursionDepth">The depth of this sub repository from the original super repository.</param>
        internal RepositoryOperationContext(
            string repositoryPath,
            string remoteUrl,
            string parentRepositoryPath,
            string submoduleName, int recursionDepth)
        {
            RepositoryPath = repositoryPath;
            RemoteUrl = remoteUrl;
            ParentRepositoryPath = parentRepositoryPath;
            SubmoduleName = submoduleName;
            RecursionDepth = recursionDepth;
        }

        /// <summary>
        /// If this is a submodule repository, the full path to the parent
        /// repository. If this is not a submodule repository, then
        /// this is empty.
        /// </summary>
        public virtual string ParentRepositoryPath { get; private set; }

        /// <summary>
        /// The recursion depth for the current repository being operated on
        /// with respect to the repository the original operation was run
        /// against. The initial repository has a recursion depth of 0,
        /// the 1st level of subrepositories has a recursion depth of 1.
        /// </summary>
        public virtual int RecursionDepth { get; private set; }

        /// <summary>
        /// The remote URL this operation will work against, if any.
        /// </summary>
        public virtual string RemoteUrl { get; private set; }

        /// <summary>
        /// Full path of the repository.
        /// </summary>
        public virtual string RepositoryPath { get; private set; }

        /// <summary>
        /// The submodule's logical name in the parent repository, if this is a
        /// submodule repository. If this is not a submodule repository, then
        /// this is empty.
        /// </summary>
        public virtual string SubmoduleName { get; private set; }
    }

    /// <summary>
    /// Provides optional additional information to the Repository to be opened.
    /// </summary>
    public sealed class RepositoryOptions
    {
        /// <summary>
        /// Overrides the probed location of the working directory of a standard repository,
        /// or, combined with <see cref="IndexPath"/>, would
        /// allow to work against a bare repository as it was a standard one.
        /// <para>
        ///   The path has to lead to an existing directory.
        /// </para>
        /// </summary>
        public string WorkingDirectoryPath { get; set; }

        /// <summary>
        /// Overrides the probed location of the Index file of a standard repository,
        /// or, combined with <see cref="WorkingDirectoryPath"/>, would
        /// allow to work against a bare repository as it was a standard one.
        /// <para>
        ///   The path has either to lead to an existing valid Index file,
        ///   or to a non existent Index file which will be eventually created.
        /// </para>
        /// </summary>
        public string IndexPath { get; set; }

        /// <summary>
        /// Overrides the default identity to be used when creating reflog entries.
        /// <para>
        ///   When unset the identity will be retreived from the repository's configuration.
        ///   When no identity can be found in the repository configuration stores, a fake
        ///   identity ("unknown" as both name and email), will be used.
        /// </para>
        /// </summary>
        public Identity Identity { get; set; }
    }

    /// <summary>
    /// Holds the result of the determination of the state of the working directory.
    /// <para>Only files that differ from the current index and/or commit will be considered.</para>
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class RepositoryStatus : IEnumerable<StatusEntry>
    {
        private readonly ICollection<StatusEntry> statusEntries;
        private readonly List<StatusEntry> added = new List<StatusEntry>();
        private readonly List<StatusEntry> staged = new List<StatusEntry>();
        private readonly List<StatusEntry> removed = new List<StatusEntry>();
        private readonly List<StatusEntry> missing = new List<StatusEntry>();
        private readonly List<StatusEntry> modified = new List<StatusEntry>();
        private readonly List<StatusEntry> untracked = new List<StatusEntry>();
        private readonly List<StatusEntry> ignored = new List<StatusEntry>();
        private readonly List<StatusEntry> renamedInIndex = new List<StatusEntry>();
        private readonly List<StatusEntry> renamedInWorkDir = new List<StatusEntry>();
        private readonly List<StatusEntry> unaltered = new List<StatusEntry>();
        private readonly bool isDirty;

        private readonly IDictionary<FileStatus, Action<RepositoryStatus, StatusEntry>> dispatcher = Build();

        private static IDictionary<FileStatus, Action<RepositoryStatus, StatusEntry>> Build()
        {
            return new Dictionary<FileStatus, Action<RepositoryStatus, StatusEntry>>
            {
                { FileStatus.NewInWorkdir, (rs, s) => rs.untracked.Add(s) },
                { FileStatus.ModifiedInWorkdir, (rs, s) => rs.modified.Add(s) },
                { FileStatus.DeletedFromWorkdir, (rs, s) => rs.missing.Add(s) },
                { FileStatus.NewInIndex, (rs, s) => rs.added.Add(s) },
                { FileStatus.ModifiedInIndex, (rs, s) => rs.staged.Add(s) },
                { FileStatus.DeletedFromIndex, (rs, s) => rs.removed.Add(s) },
                { FileStatus.RenamedInIndex, (rs, s) => rs.renamedInIndex.Add(s) },
                { FileStatus.Ignored, (rs, s) => rs.ignored.Add(s) },
                { FileStatus.RenamedInWorkdir, (rs, s) => rs.renamedInWorkDir.Add(s) },
            };
        }

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected RepositoryStatus()
        { }

        internal unsafe RepositoryStatus(Repository repo, StatusOptions options)
        {
            statusEntries = new List<StatusEntry>();

            using (GitStatusOptions coreOptions = CreateStatusOptions(options ?? new StatusOptions()))
            using (StatusListHandle list = Proxy.git_status_list_new(repo.Handle, coreOptions))
            {
                int count = Proxy.git_status_list_entrycount(list);

                for (int i = 0; i < count; i++)
                {
                    git_status_entry *entry = Proxy.git_status_byindex(list, i);
                    AddStatusEntryForDelta(entry->status, entry->head_to_index, entry->index_to_workdir);
                }

                isDirty = statusEntries.Any(entry => entry.State != FileStatus.Ignored && entry.State != FileStatus.Unaltered);
            }
        }

        private static GitStatusOptions CreateStatusOptions(StatusOptions options)
        {
            var coreOptions = new GitStatusOptions
            {
                Version = 1,
                Show = (GitStatusShow)options.Show,
            };

            if (options.IncludeIgnored)
            {
                coreOptions.Flags |= GitStatusOptionFlags.IncludeIgnored;
            }

            if (options.IncludeUntracked)
            {
                coreOptions.Flags |= GitStatusOptionFlags.IncludeUntracked;
            }

            if (options.DetectRenamesInIndex)
            {
                coreOptions.Flags |=
                    GitStatusOptionFlags.RenamesHeadToIndex |
                    GitStatusOptionFlags.RenamesFromRewrites;
            }

            if (options.DetectRenamesInWorkDir)
            {
                coreOptions.Flags |=
                    GitStatusOptionFlags.RenamesIndexToWorkDir |
                    GitStatusOptionFlags.RenamesFromRewrites;
            }

            if (options.ExcludeSubmodules)
            {
                coreOptions.Flags |=
                    GitStatusOptionFlags.ExcludeSubmodules;
            }

            if (options.RecurseIgnoredDirs)
            {
                coreOptions.Flags |=
                    GitStatusOptionFlags.RecurseIgnoredDirs;
            }

            if (options.RecurseUntrackedDirs)
            {
                coreOptions.Flags |=
                    GitStatusOptionFlags.RecurseUntrackedDirs;
            }

            if (options.PathSpec != null)
            {
                coreOptions.PathSpec = GitStrArrayManaged.BuildFrom(options.PathSpec);
            }

            if (options.DisablePathSpecMatch)
            {
                coreOptions.Flags |=
                    GitStatusOptionFlags.DisablePathspecMatch;
            }

            if (options.IncludeUnaltered)
            {
                coreOptions.Flags |=
                    GitStatusOptionFlags.IncludeUnmodified;
            }

            return coreOptions;
        }

        private unsafe void AddStatusEntryForDelta(FileStatus gitStatus, git_diff_delta* deltaHeadToIndex, git_diff_delta* deltaIndexToWorkDir)
        {
            RenameDetails headToIndexRenameDetails = null;
            RenameDetails indexToWorkDirRenameDetails = null;

            if ((gitStatus & FileStatus.RenamedInIndex) == FileStatus.RenamedInIndex)
            {
                headToIndexRenameDetails =
                    new RenameDetails(LaxUtf8Marshaler.FromNative(deltaHeadToIndex->old_file.Path),
                                      LaxUtf8Marshaler.FromNative(deltaHeadToIndex->new_file.Path),
                                      (int)deltaHeadToIndex->similarity);
            }

            if ((gitStatus & FileStatus.RenamedInWorkdir) == FileStatus.RenamedInWorkdir)
            {
                indexToWorkDirRenameDetails =
                    new RenameDetails(LaxUtf8Marshaler.FromNative(deltaIndexToWorkDir->old_file.Path),
                                      LaxUtf8Marshaler.FromNative(deltaIndexToWorkDir->new_file.Path),
                                      (int)deltaIndexToWorkDir->similarity);
            }

            var filePath = LaxUtf8Marshaler.FromNative(deltaIndexToWorkDir != null ?
                deltaIndexToWorkDir->new_file.Path :
                deltaHeadToIndex->new_file.Path);

            StatusEntry statusEntry = new StatusEntry(filePath, gitStatus, headToIndexRenameDetails, indexToWorkDirRenameDetails);
            if (deltaHeadToIndex != null) statusEntry.Id = new ObjectId(deltaHeadToIndex->new_file.Id.Id);

            if (gitStatus == FileStatus.Unaltered)
            {
                unaltered.Add(statusEntry);
            }
            else
            {
                foreach (KeyValuePair<FileStatus, Action<RepositoryStatus, StatusEntry>> kvp in dispatcher)
                {
                    if (!gitStatus.HasFlag(kvp.Key))
                    {
                        continue;
                    }

                    kvp.Value(this, statusEntry);
                }
            }

            statusEntries.Add(statusEntry);
        }

        /// <summary>
        /// Gets the <see cref="StatusEntry"/> for the specified relative path.
        /// </summary>
        public virtual StatusEntry this[string path]
        {
            get
            {
                Ensure.ArgumentNotNullOrEmptyString(path, "path");

                var entries = statusEntries.Where(e => string.Equals(e.FilePath, path, StringComparison.Ordinal)).ToList();

                Debug.Assert(!(entries.Count > 1));

                if (entries.Count == 0)
                {
                    return new StatusEntry(path, FileStatus.Nonexistent);
                }

                return entries.Single();
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<StatusEntry> GetEnumerator()
        {
            return statusEntries.GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <summary>
        /// List of files added to the index, which are not in the current commit
        /// </summary>
        public virtual IEnumerable<StatusEntry> Added
        {
            get { return added; }
        }

        /// <summary>
        /// List of files added to the index, which are already in the current commit with different content
        /// </summary>
        public virtual IEnumerable<StatusEntry> Staged
        {
            get { return staged; }
        }

        /// <summary>
        /// List of files removed from the index but are existent in the current commit
        /// </summary>
        public virtual IEnumerable<StatusEntry> Removed
        {
            get { return removed; }
        }

        /// <summary>
        /// List of files existent in the index but are missing in the working directory
        /// </summary>
        public virtual IEnumerable<StatusEntry> Missing
        {
            get { return missing; }
        }

        /// <summary>
        /// List of files with unstaged modifications. A file may be modified and staged at the same time if it has been modified after adding.
        /// </summary>
        public virtual IEnumerable<StatusEntry> Modified
        {
            get { return modified; }
        }

        /// <summary>
        /// List of files existing in the working directory but are neither tracked in the index nor in the current commit.
        /// </summary>
        public virtual IEnumerable<StatusEntry> Untracked
        {
            get { return untracked; }
        }

        /// <summary>
        /// List of files existing in the working directory that are ignored.
        /// </summary>
        public virtual IEnumerable<StatusEntry> Ignored
        {
            get { return ignored; }
        }

        /// <summary>
        /// List of files that were renamed and staged.
        /// </summary>
        public virtual IEnumerable<StatusEntry> RenamedInIndex
        {
            get { return renamedInIndex; }
        }

        /// <summary>
        /// List of files that were renamed in the working directory but have not been staged.
        /// </summary>
        public virtual IEnumerable<StatusEntry> RenamedInWorkDir
        {
            get { return renamedInWorkDir; }
        }

        /// <summary>
        /// List of files that were unmodified in the working directory.
        /// </summary>
        public virtual IEnumerable<StatusEntry> Unaltered
        {
            get { return unaltered; }
        }

        /// <summary>
        /// True if the index or the working directory has been altered since the last commit. False otherwise.
        /// </summary>
        public virtual bool IsDirty
        {
            get { return isDirty; }
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "+{0} ~{1} -{2} | +{3} ~{4} -{5} | i{6}",
                                     Added.Count(),
                                     Staged.Count(),
                                     Removed.Count(),
                                     Untracked.Count(),
                                     Modified.Count(),
                                     Missing.Count(),
                                     Ignored.Count());
            }
        }
    }

    /// <summary>
    /// Specifies the kind of operation that <see cref="IRepository.Reset(LibGit2Sharp.ResetMode, Commit)"/> should perform.
    /// </summary>
    public enum ResetMode
    {
        /// <summary>
        /// Moves the branch pointed to by HEAD to the specified commit object.
        /// </summary>
        Soft = 1,

        /// <summary>
        /// Moves the branch pointed to by HEAD to the specified commit object and resets the index
        /// to the tree recorded by the commit.
        /// </summary>
        Mixed,

        /// <summary>
        /// Moves the branch pointed to by HEAD to the specified commit object, resets the index
        /// to the tree recorded by the commit and updates the working directory to match the content
        /// of the index.
        /// </summary>
        Hard,
    }

    /// <summary>
    /// Options controlling Revert behavior.
    /// </summary>
    public sealed class RevertOptions : MergeAndCheckoutOptionsBase
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RevertOptions"/> class.
        /// By default the revert will be committed if there are no conflicts.
        /// </summary>
        public RevertOptions()
        { }

        /// <summary>
        /// When reverting a merge commit, the parent number to consider as
        /// mainline, starting from offset 1.
        /// <para>
        ///  As a merge commit has multiple parents, reverting a merge commit
        ///  will reverse all the changes brought in by the merge except for
        ///  one parent's line of commits. The parent to preserve is called the
        ///  mainline, and must be specified by its number (i.e. offset).
        /// </para>
        /// </summary>
        public int Mainline { get; set; }
    }

    /// <summary>
    /// Class to report the result of a revert.
    /// </summary>
    public class RevertResult
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected RevertResult()
        { }

        internal RevertResult(RevertStatus status, Commit commit = null)
        {
            Commit = commit;
            Status = status;
        }

        /// <summary>
        /// The resulting commit of the revert.
        /// <para>
        ///   This will return <code>null</code> if the revert was not committed.
        ///     This can happen if:
        ///       1) The revert resulted in conflicts.
        ///       2) The option to not commit on success is set.
        ///   </para>
        /// </summary>
        public virtual Commit Commit { get; private set; }

        /// <summary>
        /// The status of the revert.
        /// </summary>
        public virtual RevertStatus Status { get; private set; }
    }

     /// <summary>
    /// The status of what happened as a result of a revert.
    /// </summary>
    public enum RevertStatus
    {
        /// <summary>
        /// The commit was successfully reverted.
        /// </summary>
        Reverted,

        /// <summary>
        /// The revert resulted in conflicts.
        /// </summary>
        Conflicts,

        /// <summary>
        /// Revert was run, but there were no changes to commit.
        /// </summary>
        NothingToRevert,
    }

    /// <summary>
    /// Options for a RewriteHistory operation.
    /// </summary>
    public sealed class RewriteHistoryOptions
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RewriteHistoryOptions"/> class.
        /// </summary>
        public RewriteHistoryOptions()
        {
            BackupRefsNamespace = "refs/original/";
        }

        /// <summary>
        /// Namespace where rewritten references should be stored.
        /// (required; default: "refs/original/")
        /// </summary>
        public string BackupRefsNamespace { get; set; }

        /// <summary>
        /// Rewriter for commit metadata.
        /// </summary>
        public Func<Commit, CommitRewriteInfo> CommitHeaderRewriter { get; set; }

        /// <summary>
        /// Rewriter for mangling parent links.
        /// </summary>
        public Func<Commit, IEnumerable<Commit>> CommitParentsRewriter { get; set; }

        /// <summary>
        /// Rewriter for commit trees.
        /// </summary>
        public Func<Commit, TreeDefinition> CommitTreeRewriter { get; set; }

        /// <summary>
        /// Rewriter for tag names. This is called with
        /// (OldTag.Name, OldTag.IsAnnotated, OldTarget.Identifier).
        /// OldTarget.Identifier is either the SHA of a direct reference,
        /// or the canonical name of a symbolic reference.
        /// </summary>
        public Func<string, bool, string, string> TagNameRewriter { get; set; }

        /// <summary>
        /// Empty commits should be removed while rewriting.
        /// </summary>
        public bool PruneEmptyCommits { get; set; }

        /// <summary>
        /// Action to exectute after rewrite succeeds,
        /// but before it is finalized.
        /// <para>
        /// An exception thrown here will rollback the operation.
        /// This is useful to inspect the new state of the repository
        /// and throw if you need to adjust and try again.
        /// </para>
        /// </summary>
        public Action OnSucceeding { get; set; }

        /// <summary>
        /// Action to execute if an error occurred during rewrite,
        /// before rollback of rewrite progress.
        /// Does not fire for exceptions thrown in <see cref="OnSucceeding" />.
        /// <para>
        /// This is useful to inspect the state of the repository
        /// at the time of the exception for troubleshooting.
        /// It is not meant to be used for general error handling;
        /// for that use <code>try</code>/<code>catch</code>.
        /// </para>
        /// <para>
        /// An exception thrown here will replace the original exception.
        /// You may want to pass the callback exception as an <code>innerException</code>.
        /// </para>
        /// </summary>
        public Action<Exception> OnError { get; set; }

        /// <summary>
        /// Specifies Commit message prettifying behavior during rewrite.
        /// NOTE: Prettifying may result in losing one or multiple lines in the commit message.
        /// As such it is recommended to leave this set to false.
        /// </summary>
        /// <value><c>true</c> if Commit messages are prettified; otherwise, <c>false</c>.</value>
        public bool PrettifyMessages { get; set; }
    }

    /// <summary>
    /// Class that uses <see cref="SecureString"/> to hold username and password credentials for remote repository access.
    /// </summary>
    public sealed class SecureUsernamePasswordCredentials : Credentials
    {
        /// <summary>
        /// Callback to acquire a credential object.
        /// </summary>
        /// <param name="cred">The newly created credential object.</param>
        /// <returns>0 for success, &lt; 0 to indicate an error, &gt; 0 to indicate no credential was acquired.</returns>
        protected internal override int GitCredentialHandler(out IntPtr cred)
        {
            if (Username == null || Password == null)
            {
                throw new InvalidOperationException("UsernamePasswordCredentials contains a null Username or Password.");
            }

            IntPtr passwordPtr = IntPtr.Zero;

            try
            {
                passwordPtr = Marshal.SecureStringToGlobalAllocUnicode(Password);

                return NativeMethods.git_credential_userpass_plaintext_new(out cred, Username, Marshal.PtrToStringUni(passwordPtr));
            }
            finally
            {
                Marshal.ZeroFreeGlobalAllocUnicode(passwordPtr);
            }

        }

        /// <summary>
        /// Username for username/password authentication (as in HTTP basic auth).
        /// </summary>
        public string Username { get; set; }

        /// <summary>
        /// Password for username/password authentication (as in HTTP basic auth).
        /// </summary>
        public SecureString Password { get; set; }
    }

    /// <summary>
    /// A signature
    /// </summary>
    public sealed class Signature : IEquatable<Signature>
    {
        private readonly DateTimeOffset when;
        private readonly string name;
        private readonly string email;

        private static readonly LambdaEqualityHelper<Signature> equalityHelper =
            new LambdaEqualityHelper<Signature>(x => x.Name, x => x.Email, x => x.When);

        internal unsafe Signature(git_signature* sig)
        {
            name = LaxUtf8Marshaler.FromNative(sig->name);
            email = LaxUtf8Marshaler.FromNative(sig->email);
            when = DateTimeOffsetExtensions.FromUnixTimeSeconds(sig->when.time).ToOffset(TimeSpan.FromMinutes(sig->when.offset));
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Signature"/> class.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="email">The email.</param>
        /// <param name="when">The when.</param>
        public Signature(string name, string email, DateTimeOffset when)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");
            Ensure.ArgumentNotNullOrEmptyString(email, "email");
            Ensure.ArgumentDoesNotContainZeroByte(name, "name");
            Ensure.ArgumentDoesNotContainZeroByte(email, "email");

            this.name = name;
            this.email = email;
            this.when = when;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Signature"/> class.
        /// </summary>
        /// <param name="identity">The identity.</param>
        /// <param name="when">The when.</param>
        public Signature(Identity identity, DateTimeOffset when)
        {
            Ensure.ArgumentNotNull(identity, "identity");

            this.name = identity.Name;
            this.email = identity.Email;
            this.when = when;
        }

        internal SignatureHandle BuildHandle()
        {
            return Proxy.git_signature_new(name, email, when);
        }

        /// <summary>
        /// Gets the name.
        /// </summary>
        public string Name
        {
            get { return name; }
        }

        /// <summary>
        /// Gets the email.
        /// </summary>
        public string Email
        {
            get { return email; }
        }

        /// <summary>
        /// Gets the date when this signature happened.
        /// </summary>
        public DateTimeOffset When
        {
            get { return when; }
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="Signature"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="Signature"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="Signature"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as Signature);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Signature"/> is equal to the current <see cref="Signature"/>.
        /// </summary>
        /// <param name="other">The <see cref="Signature"/> to compare with the current <see cref="Signature"/>.</param>
        /// <returns>True if the specified <see cref="Signature"/> is equal to the current <see cref="Signature"/>; otherwise, false.</returns>
        public bool Equals(Signature other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="Signature"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="Signature"/> to compare.</param>
        /// <param name="right">Second <see cref="Signature"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(Signature left, Signature right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="Signature"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="Signature"/> to compare.</param>
        /// <param name="right">Second <see cref="Signature"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(Signature left, Signature right)
        {
            return !Equals(left, right);
        }

        /// <summary>
        /// Returns "<see cref="Name"/> &lt;<see cref="Email"/>&gt;" for the current <see cref="Signature"/>.
        /// </summary>
        /// <returns>The <see cref="Name"/> and <see cref="Email"/> of the current <see cref="Signature"/>.</returns>
        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "{0} <{1}>", Name, Email);
        }
    }

    internal static class SignatureHelpers
    {
        /// <summary>
        /// Build the handle for the Signature, or return a handle
        /// to an empty signature.
        /// </summary>
        /// <param name="signature"></param>
        /// <returns></returns>
        public static unsafe SignatureHandle SafeBuildHandle(this Signature signature)
        {
            if (signature == null)
            {
                return new SignatureHandle(null, false);
            }

            return signature.BuildHandle();
        }
    }

    /// <summary>
    /// Structure for holding a signature extracted from a commit or a tag
    /// </summary>
    public struct SignatureInfo
    {
        /// <summary>
        /// The signature data, PGP/GPG or otherwise.
        /// </summary>
        public string Signature;
        /// <summary>
        /// The data which was signed. The object contents without the signature part.
        /// </summary>
        public string SignedData;
    }

    /// <summary>
    /// Represents a mode for handling whitespace while detecting renames and copies.
    /// </summary>
    public enum WhitespaceMode
    {
        /// <summary>
        /// Don't consider leading whitespace when comparing files
        /// </summary>
        IgnoreLeadingWhitespace,

        /// <summary>
        /// Don't consider any whitespace when comparing files
        /// </summary>
        IgnoreAllWhitespace,

        /// <summary>
        /// Include all whitespace when comparing files
        /// </summary>
        DontIgnoreWhitespace,
    }

    /// <summary>
    /// Represents a mode for detecting renames and copies.
    /// </summary>
    public enum RenameDetectionMode
    {
        /// <summary>
        /// Obey the user's `diff.renames` configuration setting
        /// </summary>
        Default,

        /// <summary>
        /// Attempt no rename or copy detection
        /// </summary>
        None,

        /// <summary>
        /// Detect exact renames and copies (compare SHA hashes only)
        /// </summary>
        Exact,

        /// <summary>
        /// Detect fuzzy renames (use similarity metric)
        /// </summary>
        Renames,

        /// <summary>
        /// Detect renames and copies
        /// </summary>
        Copies,

        /// <summary>
        /// Detect renames, and include unmodified files when looking for copies
        /// </summary>
        CopiesHarder,
    }

    /// <summary>
    /// Options for handling file similarity
    /// </summary>
    public sealed class SimilarityOptions
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SimilarityOptions"/> class.
        /// </summary>
        public SimilarityOptions()
        {
            RenameDetectionMode = RenameDetectionMode.Default;
            WhitespaceMode = WhitespaceMode.IgnoreLeadingWhitespace;
            RenameThreshold = 50;
            RenameFromRewriteThreshold = 50;
            CopyThreshold = 50;
            BreakRewriteThreshold = 60;
            RenameLimit = 200;
        }

        /// <summary>
        /// Get a <see cref="SimilarityOptions"/> instance that does no rename detection
        /// </summary>
        public static SimilarityOptions None
        {
            get { return new SimilarityOptions {RenameDetectionMode = RenameDetectionMode.None}; }
        }

        /// <summary>
        /// Get a <see cref="SimilarityOptions"/> instance that detects renames
        /// </summary>
        public static SimilarityOptions Renames
        {
            get { return new SimilarityOptions {RenameDetectionMode = RenameDetectionMode.Renames}; }
        }

        /// <summary>
        /// Get a <see cref="SimilarityOptions"/> instance that detects exact renames only
        /// </summary>
        public static SimilarityOptions Exact
        {
            get { return new SimilarityOptions {RenameDetectionMode = RenameDetectionMode.Exact}; }
        }

        /// <summary>
        /// Get a <see cref="SimilarityOptions"/> instance that detects renames and copies
        /// </summary>
        public static SimilarityOptions Copies
        {
            get { return new SimilarityOptions {RenameDetectionMode = RenameDetectionMode.Copies}; }
        }

        /// <summary>
        /// Get a <see cref="SimilarityOptions"/> instance that detects renames, and includes unmodified files when detecting copies
        /// </summary>
        public static SimilarityOptions CopiesHarder
        {
            get { return new SimilarityOptions {RenameDetectionMode = RenameDetectionMode.CopiesHarder}; }
        }

        /// <summary>
        /// Get a <see cref="SimilarityOptions"/> instance that obeys the user's `diff.renames` setting
        /// </summary>
        public static SimilarityOptions Default
        {
            get { return new SimilarityOptions {RenameDetectionMode = RenameDetectionMode.Default}; }
        }

        /// <summary>
        /// The mode for detecting renames and copies
        /// </summary>
        public RenameDetectionMode RenameDetectionMode { get; set; }

        /// <summary>
        /// The mode for handling whitespace when comparing files
        /// </summary>
        public WhitespaceMode WhitespaceMode { get; set; }

        /// <summary>
        /// Similarity in order to consider a rename
        /// </summary>
        public int RenameThreshold { get; set; }

        /// <summary>
        /// Similarity of a modified file in order to be eligible as a rename source
        /// </summary>
        public int RenameFromRewriteThreshold { get; set; }

        /// <summary>
        /// Similarity to consider a file a copy
        /// </summary>
        public int CopyThreshold { get; set; }

        /// <summary>
        /// Similarity to split modify into an add/delete pair
        /// </summary>
        public int BreakRewriteThreshold { get; set; }

        /// <summary>
        /// Maximum similarity sources to examine for a file
        /// </summary>
        public int RenameLimit { get; set; }

        // TODO: custom metric
    }

    /// <summary>
    /// An enumeration of the type of connections which a "smart" subtransport
    /// may be asked to create on behalf of libgit2.
    /// </summary>
    public enum GitSmartSubtransportAction
    {
        /// <summary>
        /// For HTTP, this indicates a GET to /info/refs?service=git-upload-pack
        /// </summary>
        UploadPackList = 1,

        /// <summary>
        /// For HTTP, this indicates a POST to /git-upload-pack
        /// </summary>
        UploadPack = 2,

        /// <summary>
        /// For HTTP, this indicates a GET to /info/refs?service=git-receive-pack
        /// </summary>
        ReceivePackList = 3,

        /// <summary>
        /// For HTTP, this indicates a POST to /git-receive-pack
        /// </summary>
        ReceivePack = 4
    }

    /// <summary>
    /// Base class for custom RPC-based subtransports that use the standard
    /// "smart" git protocol.  RPC-based subtransports perform work over
    /// multiple requests, like the http transport.
    /// </summary>
    public abstract class RpcSmartSubtransport : SmartSubtransport
    {
    }

    /// <summary>
    /// Base class for typical custom subtransports for the "smart"
    /// transport that work over a single connection, like the git and ssh
    /// transports.
    /// </summary>
    public abstract class SmartSubtransport
    {
        internal IntPtr Transport { get; set; }

        /// <summary>
        /// Call the certificate check callback
        /// </summary>
        /// <param name="cert">The certificate to send</param>
        /// <param name="valid">Whether we consider the certificate to be valid</param>
        /// <param name="hostname">The hostname we connected to</param>
        public int CertificateCheck(Certificate cert, bool valid, string hostname)
        {
            CertificateSsh sshCert = cert as CertificateSsh;
            CertificateX509 x509Cert = cert as CertificateX509;

            if (sshCert == null && x509Cert == null)
            {
                throw new InvalidOperationException("Unsupported certificate type");
            }

            int ret;
            if (sshCert != null)
            {
                var certPtr = sshCert.ToPointer();
                ret = NativeMethods.git_transport_smart_certificate_check(Transport, certPtr, valid ? 1 : 0, hostname);
                Marshal.FreeHGlobal(certPtr);
            } else {
                IntPtr certPtr, dataPtr;
                certPtr = x509Cert.ToPointers(out dataPtr);
                ret = NativeMethods.git_transport_smart_certificate_check(Transport, certPtr, valid ? 1 : 0, hostname);
                Marshal.FreeHGlobal(dataPtr);
                Marshal.FreeHGlobal(certPtr);
            }

            if (ret > 0 || ret == (int)GitErrorCode.PassThrough)
            {
                ret = valid ? 0 : -1;
            }

            return ret;
        }

        /// <summary>
        /// Acquires credentials.
        /// </summary>
        /// <param name="cred">Receives the credentials if the operation is successful.</param>
        /// <param name="user">The username.</param>
        /// <param name="methods">The credential types allowed. The only supported one is <see cref="UsernamePasswordCredentials"/>. May be empty but should not be null.</param>
        /// <returns>0 if successful; a non-zero error code that came from <see cref="Proxy.git_transport_smart_credentials"/> otherwise.</returns>
        public int AcquireCredentials(out Credentials cred, string user, params Type[] methods)
        {
            // Convert the user-provided types to libgit2's flags
            int allowed = 0;
            foreach (var method in methods)
            {
                if (method == typeof(UsernamePasswordCredentials))
                {
                    allowed |= (int)GitCredentialType.UserPassPlaintext;
                }
                else if (method == typeof(DefaultCredentials))
                {
                    allowed |= (int)GitCredentialType.Default;
                }
                else
                {
                    throw new InvalidOperationException("Unknown type passes as allowed credential");
                }
            }

            IntPtr credHandle = IntPtr.Zero;
            int res = Proxy.git_transport_smart_credentials(out credHandle, Transport, user, allowed);
            if (res != 0)
            {
                cred = null;
                return res;
            }

            if (credHandle == IntPtr.Zero)
            {
                throw new InvalidOperationException("credentials callback indicated success but returned no credentials");
            }

            unsafe
            {
                var baseCred = (GitCredential*) credHandle;
                switch (baseCred->credtype)
                {
                    case GitCredentialType.UserPassPlaintext:
                        cred = UsernamePasswordCredentials.FromNative((GitCredentialUserpass*) credHandle);
                        return 0;
                    case GitCredentialType.Default:
                        cred = new DefaultCredentials();
                        return 0;
                    default:
                        throw new InvalidOperationException("User returned an unkown credential type");
                }
            }
        }

        /// <summary>
        /// libgit2 will call an action back with a null url to indicate that
        /// it should re-use the prior url; store the url so that we can replay.
        /// </summary>
        private string LastActionUrl { get; set; }

        /// <summary>
        /// Invoked by libgit2 to create a connection using this subtransport.
        /// </summary>
        /// <param name="url">The endpoint to connect to</param>
        /// <param name="action">The type of connection to create</param>
        /// <returns>A SmartSubtransportStream representing the connection</returns>
        protected abstract SmartSubtransportStream Action(String url, GitSmartSubtransportAction action);

        /// <summary>
        /// Invoked by libgit2 when this subtransport is no longer needed, but may be re-used in the future.
        /// Override this method to add additional cleanup steps to your subclass. Be sure to call base.Close().
        /// </summary>
        protected virtual void Close()
        { }

        /// <summary>
        /// Invoked by libgit2 when this subtransport is being freed. Override this method to add additional
        /// cleanup steps to your subclass. Be sure to call base.Dispose().
        /// </summary>
        protected virtual void Dispose()
        {
            Close();

            if (IntPtr.Zero != nativeSubtransportPointer)
            {
                GCHandle.FromIntPtr(Marshal.ReadIntPtr(nativeSubtransportPointer, GitSmartSubtransport.GCHandleOffset)).Free();
                Marshal.FreeHGlobal(nativeSubtransportPointer);
                nativeSubtransportPointer = IntPtr.Zero;
            }
        }

        private IntPtr nativeSubtransportPointer;

        internal IntPtr GitSmartSubtransportPointer
        {
            get
            {
                if (IntPtr.Zero == nativeSubtransportPointer)
                {
                    var nativeTransport = new GitSmartSubtransport();

                    nativeTransport.Action = EntryPoints.ActionCallback;
                    nativeTransport.Close = EntryPoints.CloseCallback;
                    nativeTransport.Free = EntryPoints.FreeCallback;

                    nativeTransport.GCHandle = GCHandle.ToIntPtr(GCHandle.Alloc(this));
                    nativeSubtransportPointer = Marshal.AllocHGlobal(Marshal.SizeOf(nativeTransport));
                    Marshal.StructureToPtr(nativeTransport, nativeSubtransportPointer, false);
                }

                return nativeSubtransportPointer;
            }
        }

        private static class EntryPoints
        {
            // Because our GitSmartSubtransport structure exists on the managed heap only for a short time (to be marshaled
            // to native memory with StructureToPtr), we need to bind to static delegates. If at construction time
            // we were to bind to the methods directly, that's the same as newing up a fresh delegate every time.
            // Those delegates won't be rooted in the object graph and can be collected as soon as StructureToPtr finishes.
            public static GitSmartSubtransport.action_callback ActionCallback = new GitSmartSubtransport.action_callback(Action);
            public static GitSmartSubtransport.close_callback CloseCallback = new GitSmartSubtransport.close_callback(Close);
            public static GitSmartSubtransport.free_callback FreeCallback = new GitSmartSubtransport.free_callback(Free);

            private static int Action(
                out IntPtr stream,
                IntPtr subtransport,
                IntPtr url,
                GitSmartSubtransportAction action)
            {
                stream = IntPtr.Zero;

                SmartSubtransport t = GCHandle.FromIntPtr(Marshal.ReadIntPtr(subtransport, GitSmartSubtransport.GCHandleOffset)).Target as SmartSubtransport;
                String urlAsString = LaxUtf8Marshaler.FromNative(url);

                if (t == null)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Net, "no subtransport provided");
                    return (int)GitErrorCode.Error;
                }

                if (String.IsNullOrEmpty(urlAsString))
                {
                    urlAsString = t.LastActionUrl;
                }

                if (String.IsNullOrEmpty(urlAsString))
                {
                    Proxy.git_error_set_str(GitErrorCategory.Net, "no url provided");
                    return (int)GitErrorCode.Error;
                }

                try
                {
                    stream = t.Action(urlAsString, action).GitSmartTransportStreamPointer;
                    t.LastActionUrl = urlAsString;
                    return 0;
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Net, ex);
                    return (int)GitErrorCode.Error;
                }
            }

            private static int Close(IntPtr subtransport)
            {
                SmartSubtransport t = GCHandle.FromIntPtr(Marshal.ReadIntPtr(subtransport, GitSmartSubtransport.GCHandleOffset)).Target as SmartSubtransport;

                if (t == null)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Net, "no subtransport provided");
                    return (int)GitErrorCode.Error;
                }

                try
                {
                    t.Close();

                    return 0;
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Net, ex);
                    return (int)GitErrorCode.Error;
                }
            }

            private static void Free(IntPtr subtransport)
            {
                SmartSubtransport t = GCHandle.FromIntPtr(Marshal.ReadIntPtr(subtransport, GitSmartSubtransport.GCHandleOffset)).Target as SmartSubtransport;

                if (null != t)
                {
                    try
                    {
                        t.Dispose();
                    }
                    catch (Exception ex)
                    {
                        Proxy.git_error_set_str(GitErrorCategory.Net, ex);
                    }
                }
            }
        }
    }

    /// <summary>
    /// An object representing the registration of a SmartSubtransport type with libgit2
    /// under a particular scheme (eg "http").
    /// </summary>
    /// <typeparam name="T">The type of SmartSubtransport to register</typeparam>
    public sealed class SmartSubtransportRegistration<T> : SmartSubtransportRegistrationData
        where T : SmartSubtransport, new()
    {
        /// <summary>
        /// Creates a new native registration for a smart protocol transport
        /// in libgit2.
        /// </summary>
        /// <param name="scheme">The URL scheme (eg "http") to register</param>
        internal SmartSubtransportRegistration(string scheme)
        {
            Scheme = scheme;
            RegistrationPointer = CreateRegistrationPointer();
            FunctionPointer = CreateFunctionPointer();
        }

        private IntPtr CreateRegistrationPointer()
        {
            var registration = new GitSmartSubtransportRegistration();

            registration.SubtransportCallback = Marshal.GetFunctionPointerForDelegate(EntryPoints.SubtransportCallback);
            registration.Rpc = typeof(RpcSmartSubtransport).IsAssignableFrom(typeof(T)) ? (uint)1 : (uint)0;

            var registrationPointer = Marshal.AllocHGlobal(Marshal.SizeOf(registration));
            Marshal.StructureToPtr(registration, registrationPointer, false);

            return registrationPointer;
        }

        private IntPtr CreateFunctionPointer()
        {
            return Marshal.GetFunctionPointerForDelegate(EntryPoints.TransportCallback);
        }

        internal void Free()
        {
            Marshal.FreeHGlobal(RegistrationPointer);
            RegistrationPointer = IntPtr.Zero;
        }

        private static class EntryPoints
        {
            // Because our GitSmartSubtransportRegistration structure exists on the managed heap only for a short time (to be marshaled
            // to native memory with StructureToPtr), we need to bind to static delegates. If at construction time
            // we were to bind to the methods directly, that's the same as newing up a fresh delegate every time.
            // Those delegates won't be rooted in the object graph and can be collected as soon as StructureToPtr finishes.
            public static GitSmartSubtransportRegistration.create_callback SubtransportCallback = new GitSmartSubtransportRegistration.create_callback(Subtransport);
            public static NativeMethods.git_transport_cb TransportCallback = new NativeMethods.git_transport_cb(Transport);

            private static int Subtransport(
                out IntPtr subtransport,
                IntPtr transport,
                IntPtr payload)
            {
                subtransport = IntPtr.Zero;

                try
                {
                    var obj = new T();
                    obj.Transport = transport;
                    subtransport = obj.GitSmartSubtransportPointer;

                    return 0;
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Net, ex);
                }

                return (int)GitErrorCode.Error;
            }

            private static int Transport(
                out IntPtr transport,
                IntPtr remote,
                IntPtr payload)
            {
                transport = IntPtr.Zero;

                try
                {
                    return NativeMethods.git_transport_smart(out transport, remote, payload);
                }
                catch (Exception ex)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Net, ex);
                }

                return (int)GitErrorCode.Error;
            }
        }
    }

    /// <summary>
    /// Information about a smart subtransport registration.
    /// </summary>
    public abstract class SmartSubtransportRegistrationData
    {
        /// <summary>
        /// The URI scheme for this transport, for example "http" or "ssh".
        /// </summary>
        public string Scheme { get; internal set; }

        internal IntPtr RegistrationPointer { get; set; }

        internal IntPtr FunctionPointer { get; set; }
    }

    /// <summary>
    /// A stream that represents a two-way connection (socket) for a SmartSubtransport.
    /// </summary>
    public abstract class SmartSubtransportStream
    {
        /// <summary>
        /// This is to quiet the MetaFixture.TypesInLibGit2SharpMustBeExtensibleInATestingContext test.
        /// Do not use this constructor.
        /// </summary>
        protected internal SmartSubtransportStream()
        {
            throw new InvalidOperationException();
        }

        /// <summary>
        /// Base constructor for SmartTransportStream. Make sure that your derived class calls this base constructor.
        /// </summary>
        /// <param name="subtransport">The subtransport that this stream represents a connection over.</param>
        protected SmartSubtransportStream(SmartSubtransport subtransport)
        {
            this.subtransport = subtransport;
        }

        /// <summary>
        /// Invoked by libgit2 when this stream is no longer needed.
        /// Override this method to add additional cleanup steps to your subclass. Be sure
        /// to call base.Free().
        /// </summary>
        protected virtual void Free()
        {
            if (IntPtr.Zero != nativeStreamPointer)
            {
                GCHandle.FromIntPtr(Marshal.ReadIntPtr(nativeStreamPointer, GitSmartSubtransportStream.GCHandleOffset)).Free();
                Marshal.FreeHGlobal(nativeStreamPointer);
                nativeStreamPointer = IntPtr.Zero;
            }
        }

        /// <summary>
        /// Reads from the transport into the provided <paramref name="dataStream"/> object.
        /// </summary>
        /// <param name="dataStream">The stream to copy the read bytes into.</param>
        /// <param name="length">The number of bytes expected from the underlying transport.</param>
        /// <param name="bytesRead">Receives the number of bytes actually read.</param>
        /// <returns>The error code to propagate back to the native code that requested this operation. 0 is expected, and exceptions may be thrown.</returns>
        public abstract int Read(Stream dataStream, long length, out long bytesRead);

        /// <summary>
        /// Writes the content of a given stream to the transport.
        /// </summary>
        /// <param name="dataStream">The stream with the data to write to the transport.</param>
        /// <param name="length">The number of bytes to read from <paramref name="dataStream"/>.</param>
        /// <returns>The error code to propagate back to the native code that requested this operation. 0 is expected, and exceptions may be thrown.</returns>
        public abstract int Write(Stream dataStream, long length);

        /// <summary>
        /// The smart transport that this stream represents a connection over.
        /// </summary>
        public virtual SmartSubtransport SmartTransport
        {
            get { return this.subtransport; }
        }

        private Exception StoredError { get; set; }

        internal void SetError(Exception ex)
        {
            StoredError = ex;
        }

        private SmartSubtransport subtransport;
        private IntPtr nativeStreamPointer;

        internal IntPtr GitSmartTransportStreamPointer
        {
            get
            {
                if (IntPtr.Zero == nativeStreamPointer)
                {
                    var nativeTransportStream = new GitSmartSubtransportStream();

                    nativeTransportStream.SmartTransport = this.subtransport.GitSmartSubtransportPointer;
                    nativeTransportStream.Read = EntryPoints.ReadCallback;
                    nativeTransportStream.Write = EntryPoints.WriteCallback;
                    nativeTransportStream.Free = EntryPoints.FreeCallback;

                    nativeTransportStream.GCHandle = GCHandle.ToIntPtr(GCHandle.Alloc(this));
                    nativeStreamPointer = Marshal.AllocHGlobal(Marshal.SizeOf(nativeTransportStream));
                    Marshal.StructureToPtr(nativeTransportStream, nativeStreamPointer, false);
                }

                return nativeStreamPointer;
            }
        }

        private static class EntryPoints
        {
            // Because our GitSmartSubtransportStream structure exists on the managed heap only for a short time (to be marshaled
            // to native memory with StructureToPtr), we need to bind to static delegates. If at construction time
            // we were to bind to the methods directly, that's the same as newing up a fresh delegate every time.
            // Those delegates won't be rooted in the object graph and can be collected as soon as StructureToPtr finishes.
            public static GitSmartSubtransportStream.read_callback ReadCallback = new GitSmartSubtransportStream.read_callback(Read);
            public static GitSmartSubtransportStream.write_callback WriteCallback = new GitSmartSubtransportStream.write_callback(Write);
            public static GitSmartSubtransportStream.free_callback FreeCallback = new GitSmartSubtransportStream.free_callback(Free);

            private static int SetError(SmartSubtransportStream stream, Exception caught)
            {
                Exception ret = (stream.StoredError != null) ? stream.StoredError : caught;
                GitErrorCode errorCode = GitErrorCode.Error;

                if (ret is NativeException)
                {
                    errorCode = ((NativeException)ret).ErrorCode;
                }

                return (int)errorCode;
            }

            private unsafe static int Read(
                IntPtr stream,
                IntPtr buffer,
                UIntPtr buf_size,
                out UIntPtr bytes_read)
            {
                bytes_read = UIntPtr.Zero;

                SmartSubtransportStream transportStream =
                    GCHandle.FromIntPtr(Marshal.ReadIntPtr(stream, GitSmartSubtransportStream.GCHandleOffset)).Target as SmartSubtransportStream;

                if (transportStream == null)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Net, "no transport stream provided");
                    return (int)GitErrorCode.Error;
                }

                if (buf_size.ToUInt64() >= (ulong)long.MaxValue)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Net, "buffer size is too large");
                    return (int)GitErrorCode.Error;
                }

                try
                {
                    using (UnmanagedMemoryStream memoryStream = new UnmanagedMemoryStream((byte*)buffer, 0,
                                                                                          (long)buf_size.ToUInt64(),
                                                                                          FileAccess.ReadWrite))
                    {
                        long longBytesRead;

                        int toReturn = transportStream.Read(memoryStream, (long)buf_size.ToUInt64(), out longBytesRead);

                        bytes_read = new UIntPtr((ulong)Math.Max(0, longBytesRead));

                        return toReturn;
                    }
                }
                catch (Exception ex)
                {
                    return SetError(transportStream, ex);
                }
            }

            private static unsafe int Write(IntPtr stream, IntPtr buffer, UIntPtr len)
            {
                SmartSubtransportStream transportStream =
                    GCHandle.FromIntPtr(Marshal.ReadIntPtr(stream, GitSmartSubtransportStream.GCHandleOffset)).Target as SmartSubtransportStream;

                if (transportStream == null)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Net, "no transport stream provided");
                    return (int)GitErrorCode.Error;
                }

                if (len.ToUInt64() >= (ulong)long.MaxValue)
                {
                    Proxy.git_error_set_str(GitErrorCategory.Net, "write length is too large");
                    return (int)GitErrorCode.Error;
                }

                try
                {
                    long length = (long)len.ToUInt64();

                    using (UnmanagedMemoryStream dataStream = new UnmanagedMemoryStream((byte*)buffer, length))
                    {
                        return transportStream.Write(dataStream, length);
                    }
                }
                catch (Exception ex)
                {
                    return SetError(transportStream, ex);
                }
            }

            private static void Free(IntPtr stream)
            {
                SmartSubtransportStream transportStream =
                    GCHandle.FromIntPtr(Marshal.ReadIntPtr(stream, GitSmartSubtransportStream.GCHandleOffset)).Target as SmartSubtransportStream;

                if (transportStream != null)
                {
                    try
                    {
                        transportStream.Free();
                    }
                    catch (Exception ex)
                    {
                        Proxy.git_error_set_str(GitErrorCategory.Net, ex);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Disambiguates the different versions of an index entry during a merge.
    /// </summary>
    public enum StageLevel
    {
        /// <summary>
        /// The standard fully merged state for an index entry.
        /// </summary>
        Staged = 0,

        /// <summary>
        /// Version of the entry as it was in the common base merge commit.
        /// </summary>
        Ancestor = 1,

        /// <summary>
        /// Version of the entry as it is in the commit of the Head.
        /// </summary>
        Ours = 2,

        /// <summary>
        /// Version of the entry as it is in the commit being merged.
        /// </summary>
        Theirs = 3,
    }

    /// <summary>
    /// Options to define file staging behavior.
    /// </summary>
    public sealed class StageOptions
    {
        /// <summary>
        /// Stage ignored files. (Default = false)
        /// </summary>
        public bool IncludeIgnored { get; set; }

        /// <summary>
        /// If set, the passed paths will be treated as explicit paths.
        /// Use these options to determine how unmatched explicit paths
        /// should be handled. (Default = null)
        /// </summary>
        public ExplicitPathsOptions ExplicitPathsOptions { get; set; }
    }

    ///<summary>
    /// A Stash
    /// <para>A stash is a snapshot of the dirty state of the working directory (i.e. the modified tracked files and staged changes)</para>
    ///</summary>
    public class Stash : ReferenceWrapper<Commit>
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Stash()
        { }

        internal Stash(Repository repo, ObjectId targetId, int index)
            : base(repo, new DirectReference(string.Format(CultureInfo.InvariantCulture, "stash@{{{0}}}", index), repo, targetId), r => r.CanonicalName)
        { }

        /// <summary>
        /// Gets the <see cref="Commit"/> that contains to the captured content of the worktree when the
        /// stash was created.
        /// </summary>
        public virtual Commit WorkTree
        {
            get { return TargetObject; }
        }

        /// <summary>
        /// Gets the base <see cref="Commit"/> (i.e. the HEAD when the stash was
        /// created).
        /// </summary>
        public virtual Commit Base
        {
            get { return TargetObject.Parents.First(); }
        }

        /// <summary>
        /// Gets the <see cref="Commit"/> that contains the captured content of the index when the stash was
        /// created.
        /// </summary>
        public virtual Commit Index
        {
            get { return GetParentAtOrDefault(1); }
        }

        /// <summary>
        /// Gets the <see cref="Commit"/> that contains the list of either the untracked files, the ignored files, or both,
        /// depending on the <see cref="StashModifiers"/> options passed when the stash was created.
        /// </summary>
        public virtual Commit Untracked
        {
            get { return GetParentAtOrDefault(2); }
        }

        private Commit GetParentAtOrDefault(int parentIndex)
        {
            return TargetObject.Parents.ElementAtOrDefault(parentIndex);
        }

        /// <summary>
        /// Gets the message associated to this <see cref="Stash"/>.
        /// </summary>
        public virtual string Message
        {
            get { return WorkTree.Message; }
        }

        /// <summary>
        /// Returns "stash@{i}", where i is the index of this <see cref="Stash"/>.
        /// </summary>
        protected override string Shorten()
        {
            return CanonicalName;
        }
    }

    /// <summary>
    /// The options to be used for stash application.
    /// </summary>
    public sealed class StashApplyOptions
    {
        /// <summary>
        /// <see cref="StashApplyModifiers"/> for controlling checkout index reinstating./>
        /// </summary>
        /// <value>The flags.</value>
        public StashApplyModifiers ApplyModifiers { get; set; }

        /// <summary>
        /// <see cref="CheckoutOptions"/> controlling checkout behavior.
        /// </summary>
        /// <value>The checkout options.</value>
        public CheckoutOptions CheckoutOptions { get; set; }

        /// <summary>
        /// <see cref="StashApplyProgressHandler"/> for controlling stash application progress./>
        /// </summary>
        /// <value>The progress handler.</value>
        public StashApplyProgressHandler ProgressHandler { get; set; }
    }

    /// <summary>
    /// The flags which control whether the index should be reinstated.
    /// </summary>
    [Flags]
    public enum StashApplyModifiers
    {
        /// <summary>
        /// Default. Will apply the stash and result in an index with conflicts
        /// if any arise.
        /// </summary>
        Default = 0,

        /// <summary>
        /// In case any conflicts arise, this will not apply the stash.
        /// </summary>
        ReinstateIndex = (1 << 0),
    }

    /// <summary>
    /// The current progress of the stash application.
    /// </summary>
    public enum StashApplyProgress
    {
        /// <summary>
        /// Not passed by the callback. Used as dummy value.
        /// </summary>
        None = 0,

        /// <summary>
        /// Loading the stashed data from the object database.
        /// </summary>
        LoadingStash,

        /// <summary>
        /// The stored index is being analyzed.
        /// </summary>
        AnalyzeIndex,

        /// <summary>
        /// The modified files are being analyzed.
        /// </summary>
        AnalyzeModified,

        /// <summary>
        /// The untracked and ignored files are being analyzed.
        /// </summary>
        AnalyzeUntracked,

        /// <summary>
        /// The untracked files are being written to disk.
        /// </summary>
        CheckoutUntracked,

        /// <summary>
        /// The modified files are being written to disk.
        /// </summary>
        CheckoutModified,

        /// <summary>
        /// The stash was applied successfully.
        /// </summary>
        Done,
    }

    /// <summary>
    /// The result of a stash application operation.
    /// </summary>
    public enum StashApplyStatus
    {
        /// <summary>
        /// The stash application was successful.
        /// </summary>
        Applied,

        /// <summary>
        /// The stash application ended up with conflicts.
        /// </summary>
        Conflicts,

        /// <summary>
        /// The stash index given was not found.
        /// </summary>
        NotFound,

        /// <summary>
        /// The stash application was aborted due to uncommitted changes in the index.
        /// </summary>
        UncommittedChanges,
    }

    /// <summary>
    /// The collection of <see cref="Stash"/>es in a <see cref="Repository"/>
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class StashCollection : IEnumerable<Stash>
    {
        internal readonly Repository repo;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected StashCollection()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="StashCollection"/> class.
        /// </summary>
        /// <param name="repo">The repo.</param>
        internal StashCollection(Repository repo)
        {
            this.repo = repo;
        }

        #region Implementation of IEnumerable

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// <para>
        ///   The enumerator returns the stashes by descending order (last stash is returned first).
        /// </para>
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<Stash> GetEnumerator()
        {
            Func<int, IntPtr, GitOid, Stash> resultSelector = (index, message, commitId) => new Stash(repo, new ObjectId(commitId), index);

            return Proxy.git_stash_foreach(repo.Handle, resultSelector).GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        /// <summary>
        /// Gets the <see cref="Stash"/> corresponding to the specified index (0 being the most recent one).
        /// </summary>
        public virtual Stash this[int index]
        {
            get
            {
                if (index < 0)
                {
                    throw new ArgumentOutOfRangeException("index", "The passed index must be a positive integer.");
                }

                GitObject stashCommit = repo.Lookup(string.Format(CultureInfo.InvariantCulture,
                                                                  "stash@{{{0}}}",
                                                                  index),
                                                    GitObjectType.Commit,
                                                    LookUpOptions.None);

                return stashCommit == null
                    ? null
                    : new Stash(repo, stashCommit.Id, index);
            }
        }

        /// <summary>
        /// Creates a stash with the specified message.
        /// </summary>
        /// <param name="stasher">The <see cref="Signature"/> of the user who stashes </param>
        /// <returns>the newly created <see cref="Stash"/></returns>
        public virtual Stash Add(Signature stasher)
        {
            return Add(stasher, null, StashModifiers.Default);
        }
        /// <summary>
        /// Creates a stash with the specified message.
        /// </summary>
        /// <param name="stasher">The <see cref="Signature"/> of the user who stashes </param>
        /// <param name="options">A combination of <see cref="StashModifiers"/> flags</param>
        /// <returns>the newly created <see cref="Stash"/></returns>
        public virtual Stash Add(Signature stasher, StashModifiers options)
        {
            return Add(stasher, null, options);
        }

        /// <summary>
        /// Creates a stash with the specified message.
        /// </summary>
        /// <param name="stasher">The <see cref="Signature"/> of the user who stashes </param>
        /// <param name="message">The message of the stash.</param>
        /// <returns>the newly created <see cref="Stash"/></returns>
        public virtual Stash Add(Signature stasher, string message)
        {
            return Add(stasher, message, StashModifiers.Default);
        }

        /// <summary>
        /// Creates a stash with the specified message.
        /// </summary>
        /// <param name="stasher">The <see cref="Signature"/> of the user who stashes </param>
        /// <param name="message">The message of the stash.</param>
        /// <param name="options">A combination of <see cref="StashModifiers"/> flags</param>
        /// <returns>the newly created <see cref="Stash"/></returns>
        public virtual Stash Add(Signature stasher, string message, StashModifiers options)
        {
            Ensure.ArgumentNotNull(stasher, "stasher");

            string prettifiedMessage = Proxy.git_message_prettify(string.IsNullOrEmpty(message) ? string.Empty : message, null);

            ObjectId oid = Proxy.git_stash_save(repo.Handle, stasher, prettifiedMessage, options);

            // in case there is nothing to stash
            if (oid == null)
            {
                return null;
            }

            return new Stash(repo, oid, 0);
        }

        /// <summary>
        /// Applies a single stashed state from the stash list
        /// </summary>
        /// <param name="index">the index of the stash to remove (0 being the most recent one).</param>
        /// <param name="options">the options to use for checking out the stash.</param>
        public virtual StashApplyStatus Apply(int index, StashApplyOptions options)
        {
            if (index < 0)
            {
                throw new ArgumentException("The passed index must be a positive integer.", "index");
            }

            if (options == null)
            {
                options = new StashApplyOptions();
            }

            using (GitCheckoutOptsWrapper checkoutOptionsWrapper = new GitCheckoutOptsWrapper(options.CheckoutOptions ?? new CheckoutOptions()))
            {
                var opts = new GitStashApplyOpts
                {
                    CheckoutOptions = checkoutOptionsWrapper.Options,
                    Flags = options.ApplyModifiers,
                };

                if (options.ProgressHandler != null)
                {
                    opts.ApplyProgressCallback = (progress, payload) => options.ProgressHandler(progress) ? 0 : -1;
                }

                return Proxy.git_stash_apply(repo.Handle, index, opts);
            }
        }

        /// <summary>
        /// Applies a single stashed state from the stash list using the default options.
        /// </summary>
        /// <param name="index">the index of the stash to remove (0 being the most recent one).</param>
        public virtual StashApplyStatus Apply(int index)
        {
            return Apply(index, null);
        }

        /// <summary>
        /// Pops a single stashed state from the stash list
        /// </summary>
        /// <param name="index">the index of the stash to remove (0 being the most recent one).</param>
        /// <param name="options">the options to use for checking out the stash.</param>
        public virtual StashApplyStatus Pop(int index, StashApplyOptions options)
        {
            if (index < 0)
            {
                throw new ArgumentException("The passed index must be a positive integer.", "index");
            }

            if (options == null)
            {
                options = new StashApplyOptions();
            }

            using (GitCheckoutOptsWrapper checkoutOptionsWrapper = new GitCheckoutOptsWrapper(options.CheckoutOptions ?? new CheckoutOptions()))
            {
                var opts = new GitStashApplyOpts
                {
                    CheckoutOptions = checkoutOptionsWrapper.Options,
                    Flags = options.ApplyModifiers,
                };

                if (options.ProgressHandler != null)
                {
                    opts.ApplyProgressCallback = (progress, payload) => options.ProgressHandler(progress) ? 0 : -1;
                }

                return Proxy.git_stash_pop(repo.Handle, index, opts);
            }
        }

        /// <summary>
        /// Pops a single stashed state from the stash list using the default options.
        /// </summary>
        /// <param name="index">the index of the stash to remove (0 being the most recent one).</param>
        public virtual StashApplyStatus Pop(int index)
        {
            return Pop(index, null);
        }

        /// <summary>
        /// Remove a single stashed state from the stash list.
        /// </summary>
        /// <param name="index">The index of the stash to remove (0 being the most recent one).</param>
        public virtual void Remove(int index)
        {
            if (index < 0)
            {
                throw new ArgumentException("The passed index must be a positive integer.", "index");
            }

            Proxy.git_stash_drop(repo.Handle, index);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "Count = {0}", this.Count());
            }
        }
    }

    ///<summary>
    /// Options controlling Stash behavior.
    ///</summary>
    [Flags]
    public enum StashModifiers
    {
        /// <summary>
        /// Default
        /// </summary>
        Default = 0,

        /// <summary>
        /// All changes already added to the index
        /// are left intact in the working directory
        /// </summary>
        KeepIndex = (1 << 0),

        /// <summary>
        /// All untracked files are also stashed and then
        /// cleaned up from the working directory
        /// </summary>
        IncludeUntracked = (1 << 1),

        /// <summary>
        /// All ignored files are also stashed and then
        /// cleaned up from the working directory
        /// </summary>
        IncludeIgnored = (1 << 2),
    }

    /// <summary>
    /// Holds the calculated status of a particular file at a particular instant.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class StatusEntry : IEquatable<StatusEntry>
    {
        private readonly string filePath;
        private readonly FileStatus state;
        private readonly RenameDetails headToIndexRenameDetails;
        private readonly RenameDetails indexToWorkDirRenameDetails;
        public ObjectId Id;

        private static readonly LambdaEqualityHelper<StatusEntry> equalityHelper =
            new LambdaEqualityHelper<StatusEntry>(x => x.FilePath, x => x.State, x => x.HeadToIndexRenameDetails, x => x.IndexToWorkDirRenameDetails);

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected StatusEntry()
        { }

        internal StatusEntry(string filePath, FileStatus state, RenameDetails headToIndexRenameDetails = null, RenameDetails indexToWorkDirRenameDetails = null)
        {
            this.filePath = filePath;
            this.state = state;
            this.headToIndexRenameDetails = headToIndexRenameDetails;
            this.indexToWorkDirRenameDetails = indexToWorkDirRenameDetails;
        }

        /// <summary>
        /// Gets the <see cref="FileStatus"/> of the file.
        /// </summary>
        public virtual FileStatus State
        {
            get { return state; }
        }

        /// <summary>
        /// Gets the relative new filepath to the working directory of the file.
        /// </summary>
        public virtual string FilePath
        {
            get { return filePath; }
        }

        /// <summary>
        /// Gets the rename details from the HEAD to the Index, if this <see cref="FileStatus"/> contains <see cref="FileStatus.RenamedInIndex"/>
        /// </summary>
        public virtual RenameDetails HeadToIndexRenameDetails
        {
            get { return headToIndexRenameDetails; }
        }

        /// <summary>
        /// Gets the rename details from the Index to the working directory, if this <see cref="FileStatus"/> contains <see cref="FileStatus.RenamedInWorkdir"/>
        /// </summary>
        public virtual RenameDetails IndexToWorkDirRenameDetails
        {
            get { return indexToWorkDirRenameDetails; }
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="StatusEntry"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="StatusEntry"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="StatusEntry"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as StatusEntry);
        }

        /// <summary>
        /// Determines whether the specified <see cref="StatusEntry"/> is equal to the current <see cref="StatusEntry"/>.
        /// </summary>
        /// <param name="other">The <see cref="StatusEntry"/> to compare with the current <see cref="StatusEntry"/>.</param>
        /// <returns>True if the specified <see cref="StatusEntry"/> is equal to the current <see cref="StatusEntry"/>; otherwise, false.</returns>
        public bool Equals(StatusEntry other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="StatusEntry"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="StatusEntry"/> to compare.</param>
        /// <param name="right">Second <see cref="StatusEntry"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(StatusEntry left, StatusEntry right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="StatusEntry"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="StatusEntry"/> to compare.</param>
        /// <param name="right">Second <see cref="StatusEntry"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(StatusEntry left, StatusEntry right)
        {
            return !Equals(left, right);
        }

        private string DebuggerDisplay
        {
            get
            {
                if ((State & FileStatus.RenamedInIndex) == FileStatus.RenamedInIndex ||
                    (State & FileStatus.RenamedInWorkdir) == FileStatus.RenamedInWorkdir)
                {
                    string oldFilePath = ((State & FileStatus.RenamedInIndex) != 0)
                        ? HeadToIndexRenameDetails.OldFilePath
                        : IndexToWorkDirRenameDetails.OldFilePath;

                    return string.Format(CultureInfo.InvariantCulture, "{0}: {1} -> {2}", State, oldFilePath, FilePath);
                }

                return string.Format(CultureInfo.InvariantCulture, "{0}: {1}", State, FilePath);
            }
        }
    }

    /// <summary>
    /// Flags controlling what files are reported by status.
    /// </summary>
    public enum StatusShowOption
    {
        /// <summary>
        /// Both the index and working directory are examined for changes
        /// </summary>
        IndexAndWorkDir = 0,

        /// <summary>
        /// Only the index is examined for changes
        /// </summary>
        IndexOnly = 1,

        /// <summary>
        /// Only the working directory is examined for changes
        /// </summary>
        WorkDirOnly = 2
    }

    /// <summary>
    /// Options controlling the status behavior.
    /// </summary>
    public sealed class StatusOptions
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StatusOptions"/> class.
        /// By default, both the index and the working directory will be scanned
        /// for status, and renames will be detected from changes staged in the
        /// index only.
        /// </summary>
        public StatusOptions()
        {
            DetectRenamesInIndex = true;
            IncludeIgnored = true;
            IncludeUntracked = true;
            RecurseUntrackedDirs = true;
        }

        /// <summary>
        /// Which files should be scanned and returned
        /// </summary>
        public StatusShowOption Show { get; set; }

        /// <summary>
        /// Examine the staged changes for renames.
        /// </summary>
        public bool DetectRenamesInIndex { get; set; }

        /// <summary>
        /// Examine unstaged changes in the working directory for renames.
        /// </summary>
        public bool DetectRenamesInWorkDir { get; set; }

        /// <summary>
        /// Exclude submodules from being scanned for status
        /// </summary>
        public bool ExcludeSubmodules { get; set; }

        /// <summary>
        /// Recurse into ignored directories
        /// </summary>
        public bool RecurseIgnoredDirs { get; set; }

        /// <summary>
        /// Recurse into untracked directories
        /// </summary>
        public bool RecurseUntrackedDirs { get; set; }

        /// <summary>
        /// Limit the scope of paths to consider to the provided pathspecs
        /// </summary>
        /// <remarks>
        /// If a PathSpec is given, the results from rename detection may
        /// not be accurate.
        /// </remarks>
        public string[] PathSpec { get; set; }

        /// <summary>
        /// When set to <c>true</c>, the PathSpec paths will be considered
        /// as explicit paths, and NOT as pathspecs containing globs.
        /// </summary>
        public bool DisablePathSpecMatch { get; set; }

        /// <summary>
        /// Include unaltered files when scanning for status
        /// </summary>
        /// <remarks>
        /// Unaltered meaning the file is identical in the working directory, the index and HEAD.
        /// </remarks>
        public bool IncludeUnaltered { get; set; }

        /// <summary>
        /// Include ignored files when scanning for status
        /// </summary>
        /// <remarks>
        /// ignored meaning present in .gitignore. Defaults to true for back compat but may improve perf to not include if you have thousands of ignored files.
        /// </remarks>
        public bool IncludeIgnored { get; set; }

        /// <summary>
        /// Include untracked files when scanning for status
        /// </summary>
        public bool IncludeUntracked { get; set; }
    }

    /// <summary>
    /// A Submodule.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class Submodule : IEquatable<Submodule>, IBelongToARepository
    {
        private static readonly LambdaEqualityHelper<Submodule> equalityHelper =
            new LambdaEqualityHelper<Submodule>(x => x.Name, x => x.HeadCommitId);

        private readonly Repository repo;
        private readonly string name;
        private readonly string path;
        private readonly string url;
        private readonly ILazy<ObjectId> headCommitId;
        private readonly ILazy<ObjectId> indexCommitId;
        private readonly ILazy<ObjectId> workdirCommitId;
        private readonly ILazy<SubmoduleRecurse> fetchRecurseSubmodulesRule;
        private readonly ILazy<SubmoduleIgnore> ignoreRule;
        private readonly ILazy<SubmoduleUpdate> updateRule;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Submodule()
        { }

        internal Submodule(Repository repo, string name, string path, string url)
        {
            this.repo = repo;
            this.name = name;
            this.path = path;
            this.url = url;

            var commitIds = new SubmoduleLazyGroup(repo, name);
            headCommitId = commitIds.AddLazy(Proxy.git_submodule_head_id);
            indexCommitId = commitIds.AddLazy(Proxy.git_submodule_index_id);
            workdirCommitId = commitIds.AddLazy(Proxy.git_submodule_wd_id);

            var rules = new SubmoduleLazyGroup(repo, name);
            fetchRecurseSubmodulesRule = rules.AddLazy(Proxy.git_submodule_fetch_recurse_submodules);
            ignoreRule = rules.AddLazy(Proxy.git_submodule_ignore);
            updateRule = rules.AddLazy(Proxy.git_submodule_update_strategy);
        }

        /// <summary>
        /// The name of the submodule.
        /// </summary>
        public virtual string Name { get { return name; } }

        /// <summary>
        /// The path of the submodule.
        /// </summary>
        public virtual string Path { get { return path; } }

        /// <summary>
        /// The URL of the submodule.
        /// </summary>
        public virtual string Url { get { return url; } }

        /// <summary>
        /// The commit ID for this submodule in the current HEAD tree.
        /// </summary>
        public virtual ObjectId HeadCommitId { get { return headCommitId.Value; } }

        /// <summary>
        /// The commit ID for this submodule in the index.
        /// </summary>
        public virtual ObjectId IndexCommitId { get { return indexCommitId.Value; } }

        /// <summary>
        /// The commit ID for this submodule in the current working directory.
        /// </summary>
        public virtual ObjectId WorkDirCommitId { get { return workdirCommitId.Value; } }

        /// <summary>
        /// The fetchRecurseSubmodules rule for the submodule.
        ///
        /// Note that at this time, LibGit2Sharp does not honor this setting and the
        /// fetch functionality current ignores submodules.
        /// </summary>
        public virtual SubmoduleRecurse FetchRecurseSubmodulesRule { get { return fetchRecurseSubmodulesRule.Value; } }

        /// <summary>
        /// The ignore rule of the submodule.
        /// </summary>
        public virtual SubmoduleIgnore IgnoreRule { get { return ignoreRule.Value; } }

        /// <summary>
        /// The update rule of the submodule.
        /// </summary>
        public virtual SubmoduleUpdate UpdateRule { get { return updateRule.Value; } }

        /// <summary>
        /// Retrieves the state of this submodule in the working directory compared to the staging area and the latest commit.
        /// </summary>
        /// <returns>The <see cref="SubmoduleStatus"/> of this submodule.</returns>
        public virtual SubmoduleStatus RetrieveStatus()
        {
            return Proxy.git_submodule_status(repo.Handle, Name);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="Submodule"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="Submodule"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="Submodule"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as Submodule);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Submodule"/> is equal to the current <see cref="Submodule"/>.
        /// </summary>
        /// <param name="other">The <see cref="Submodule"/> to compare with the current <see cref="Submodule"/>.</param>
        /// <returns>True if the specified <see cref="Submodule"/> is equal to the current <see cref="Submodule"/>; otherwise, false.</returns>
        public bool Equals(Submodule other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Returns the <see cref="Name"/>, a <see cref="String"/> representation of the current <see cref="Submodule"/>.
        /// </summary>
        /// <returns>The <see cref="Name"/> that represents the current <see cref="Submodule"/>.</returns>
        public override string ToString()
        {
            return Name;
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "{0} => {1}", Name, Url);
            }
        }

        IRepository IBelongToARepository.Repository { get { return repo; } }
    }

    /// <summary>
    /// The collection of submodules in a <see cref="Repository"/>
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class SubmoduleCollection : IEnumerable<Submodule>
    {
        internal readonly Repository repo;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected SubmoduleCollection()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.SubmoduleCollection"/> class.
        /// </summary>
        /// <param name="repo">The repo.</param>
        internal SubmoduleCollection(Repository repo)
        {
            this.repo = repo;
        }

        /// <summary>
        /// Gets the <see cref="LibGit2Sharp.Submodule"/> with the specified name.
        /// </summary>
        public virtual Submodule this[string name]
        {
            get
            {
                Ensure.ArgumentNotNullOrEmptyString(name, "name");

                return Lookup(name, handle => new Submodule(repo, name,
                                                            Proxy.git_submodule_path(handle),
                                                            Proxy.git_submodule_url(handle)));
            }
        }

        /// <summary>
        /// Initialize specified submodule.
        /// <para>
        /// Existing entries in the config file for this submodule are not be
        /// modified unless <paramref name="overwrite"/> is true.
        /// </para>
        /// </summary>
        /// <param name="name">The name of the submodule to update.</param>
        /// <param name="overwrite">Overwrite existing entries.</param>
        public virtual void Init(string name, bool overwrite)
        {
            using (var handle = Proxy.git_submodule_lookup(repo.Handle, name))
            {
                if (handle == null)
                {
                    throw new NotFoundException("Submodule lookup failed for '{0}'.",
                                                name);
                }

                Proxy.git_submodule_init(handle, overwrite);
            }
        }

        /// <summary>
        /// Update specified submodule.
        /// <para>
        ///   This will:
        ///   1) Optionally initialize the if it not already initialized,
        ///   2) clone the sub repository if it has not already been cloned, and
        ///   3) checkout the commit ID for the submodule in the sub repository.
        /// </para>
        /// </summary>
        /// <param name="name">The name of the submodule to update.</param>
        /// <param name="options">Options controlling submodule update behavior and callbacks.</param>
        public virtual void Update(string name, SubmoduleUpdateOptions options)
        {
            if (options == null) options = new SubmoduleUpdateOptions();

            var handle = Proxy.git_submodule_lookup(repo.Handle, name);
            if (handle == null) throw new NotFoundException("Submodule lookup failed for '{0}'.", name);
            var checkoutOptionsWrapper = new GitCheckoutOptsWrapper(options);
            var fetchOptionsWrapper = new GitFetchOptionsWrapper();

            var gitCheckoutOptions = checkoutOptionsWrapper.Options;

            var gitFetchOptions = fetchOptionsWrapper.Options;
            gitFetchOptions.ProxyOptions = options.FetchOptions.ProxyOptions.CreateGitProxyOptions();
            gitFetchOptions.RemoteCallbacks = new RemoteCallbacks(options.FetchOptions).GenerateCallbacks();

            if (options.FetchOptions != null && options.FetchOptions.CustomHeaders != null)
            {
                gitFetchOptions.CustomHeaders =
                    GitStrArrayManaged.BuildFrom(options.FetchOptions.CustomHeaders);
            }

            var gitSubmoduleUpdateOpts = new GitSubmoduleUpdateOptions
            {
                Version = 1,
                CheckoutOptions = gitCheckoutOptions,
                FetchOptions = gitFetchOptions
            };

            Proxy.git_submodule_update(handle, options.Init, ref gitSubmoduleUpdateOpts);
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<Submodule> GetEnumerator()
        {
            return Proxy.git_submodule_foreach(repo.Handle, (h, n) => LaxUtf8Marshaler.FromNative(n))
                        .Select(n => this[n])
                        .GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        internal bool TryStage(string relativePath, bool writeIndex)
        {
            return Lookup(relativePath,
                          handle =>
                          {
                              if (handle == null)
                                  return false;

                              Proxy.git_submodule_add_to_index(handle, writeIndex);
                              return true;
                          });
        }

        internal T Lookup<T>(string name, Func<SubmoduleHandle, T> selector, bool throwIfNotFound = false)
        {
            using (var handle = Proxy.git_submodule_lookup(repo.Handle, name))
            {
                if (handle != null)
                {
                    Proxy.git_submodule_reload(handle);
                    return selector(handle);
                }

                if (throwIfNotFound)
                {
                    throw new LibGit2SharpException("Submodule lookup failed for '{0}'.", name);
                }

                return default(T);
            }
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "Count = {0}", this.Count());
            }
        }
    }

    /// <summary>
    /// Extensions related to submodules
    /// </summary>
    public static class SubmoduleExtensions
    {
        private const SubmoduleStatus UnmodifiedMask = ~(SubmoduleStatus.InConfig | SubmoduleStatus.InHead | SubmoduleStatus.InIndex | SubmoduleStatus.InWorkDir);
        private const SubmoduleStatus WorkDirDirtyMask = SubmoduleStatus.WorkDirFilesIndexDirty | SubmoduleStatus.WorkDirFilesModified | SubmoduleStatus.WorkDirFilesUntracked;

        /// <summary>
        /// The submodule is unmodified.
        /// </summary>
        public static bool IsUnmodified(this SubmoduleStatus @this)
        {
            return (@this & UnmodifiedMask) == SubmoduleStatus.Unmodified;
        }

        /// <summary>
        /// The submodule working directory is dirty.
        /// </summary>
        public static bool IsWorkingDirectoryDirty(this SubmoduleStatus @this)
        {
            return (@this & WorkDirDirtyMask) != SubmoduleStatus.Unmodified;
        }
    }

    /// <summary>
    /// Values that could be specified for how closely to examine the
    /// working directory when getting submodule status.
    /// </summary>
    public enum SubmoduleIgnore
    {
        /// <summary>
        /// Reset to the last saved ignore rule.
        /// </summary>
        Reset = -1,

        /// <summary>
        /// Any change or untracked == dirty
        /// </summary>
        None = 1,

        /// <summary>
        /// Dirty if tracked files change
        /// </summary>
        Untracked = 2,

        /// <summary>
        /// Only dirty if HEAD moved
        /// </summary>
        Dirty = 3,

        /// <summary>
        /// Never dirty
        /// </summary>
        All = 4,
    }

    /// <summary>
    /// Submodule recurse rule options.
    /// </summary>
    public enum SubmoduleRecurse
    {
        /// <summary>
        /// Reset to the value in the config.
        /// </summary>
        Reset = -1,
        /// <summary>
        /// Do not recurse into submodules.
        /// </summary>
        No = 0,
        /// <summary>
        /// Recurse into submodules.
        /// </summary>
        Yes = 1,
        /// <summary>
        /// Recurse into submodules only when commit not already in local clone.
        /// </summary>
        OnDemand = 2,
    }

    /// <summary>
    /// Calculated status of a submodule in the working directory considering the current <see cref="Repository.Index"/> and the <see cref="Repository.Head"/>.
    /// </summary>
    [Flags]
    public enum SubmoduleStatus
    {
        /// <summary>
        /// No submodule changes detected.
        /// </summary>
        Unmodified = 0,

        /// <summary>
        /// Superproject head contains submodule.
        /// </summary>
        /// <remarks>Can be returned even if ignore is set to "ALL".</remarks>
        InHead = (1 << 0),
        /// <summary>
        /// Superproject index contains submodule.
        /// </summary>
        /// <remarks>Can be returned even if ignore is set to "ALL".</remarks>
        InIndex = (1 << 1),
        /// <summary>
        /// Superproject gitmodules has submodule.
        /// </summary>
        /// <remarks>Can be returned even if ignore is set to "ALL".</remarks>
        InConfig = (1 << 2),
        /// <summary>
        /// Superproject working directory has submodule.
        /// </summary>
        /// <remarks>Can be returned even if ignore is set to "ALL".</remarks>
        InWorkDir = (1 << 3),

        /// <summary>
        /// Submodule is in index, but not in head.
        /// </summary>
        /// <remarks>Can be returned unless ignore is set to "ALL".</remarks>
        IndexAdded = (1 << 4),
        /// <summary>
        /// Submodule is in head, but not in index.
        /// </summary>
        /// <remarks>Can be returned unless ignore is set to "ALL".</remarks>
        IndexDeleted = (1 << 5),
        /// <summary>
        /// Submodule in index and head don't match.
        /// </summary>
        /// <remarks>Can be returned unless ignore is set to "ALL".</remarks>
        IndexModified = (1 << 6),
        /// <summary>
        /// Submodule in working directory is not initialized.
        /// </summary>
        /// <remarks>Can be returned unless ignore is set to "ALL".</remarks>
        WorkDirUninitialized = (1 << 7),
        /// <summary>
        /// Submodule is in working directory, but not index.
        /// </summary>
        /// <remarks>Can be returned unless ignore is set to "ALL".</remarks>
        WorkDirAdded = (1 << 8),
        /// <summary>
        /// Submodule is in index, but not working directory.
        /// </summary>
        /// <remarks>Can be returned unless ignore is set to "ALL".</remarks>
        WorkDirDeleted = (1 << 9),
        /// <summary>
        /// Submodule in index and working directory head don't match.
        /// </summary>
        /// <remarks>Can be returned unless ignore is set to "ALL".</remarks>
        WorkDirModified = (1 << 10),

        /// <summary>
        /// Submodule working directory index is dirty.
        /// </summary>
        /// <remarks>Can only be returned if ignore is "NONE" or "UNTRACKED".</remarks>
        WorkDirFilesIndexDirty = (1 << 11),
        /// <summary>
        /// Submodule working directory has modified files.
        /// </summary>
        /// <remarks>Can only be returned if ignore is "NONE" or "UNTRACKED".</remarks>
        WorkDirFilesModified = (1 << 12),

        /// <summary>
        /// Working directory contains untracked files.
        /// </summary>
        /// <remarks>Can only be returned if ignore is "NONE".</remarks>
        WorkDirFilesUntracked = (1 << 13),
    }

    /// <summary>
    /// Submodule update rule options.
    /// </summary>
    public enum SubmoduleUpdate
    {
        /// <summary>
        /// Reset to the last saved update rule.
        /// </summary>
        Reset = -1,
        /// <summary>
        /// Only used when you don't want to specify any particular update
        /// rule.
        /// </summary>
        Unspecified = 0,
        /// <summary>
        /// This is the default - checkout the commit recorded in the superproject.
        /// </summary>
        Checkout = 1,
        /// <summary>
        /// Rebase the current branch of the submodule onto the commit recorded in the superproject.
        /// </summary>
        Rebase = 2,
        /// <summary>
        /// Merge the commit recorded in the superproject into the current branch of the submodule.
        /// </summary>
        Merge = 3,
        /// <summary>
        /// Do not update the submodule.
        /// </summary>
        None = 4,
    }

    /// <summary>
    /// Options controlling Submodule Update behavior and callbacks.
    /// </summary>
    public sealed class SubmoduleUpdateOptions : IConvertableToGitCheckoutOpts
    {
        /// <summary>
        /// Initialize the submodule if it is not already initialized.
        /// </summary>
        public bool Init { get; set; }

        /// <summary>
        /// Delegate to be called during checkout for files that match
        /// desired filter specified with the NotifyFlags property.
        /// </summary>
        public CheckoutNotifyHandler OnCheckoutNotify { get; set; }

        /// Delegate through which checkout will notify callers of
        /// certain conditions. The conditions that are reported is
        /// controlled with the CheckoutNotifyFlags property.
        public CheckoutProgressHandler OnCheckoutProgress { get; set; }

        /// <summary>
        /// The flags specifying what conditions are
        /// reported through the OnCheckoutNotify delegate.
        /// </summary>
        public CheckoutNotifyFlags CheckoutNotifyFlags { get; set; }

        /// <summary>
        /// Collection of parameters controlling Fetch behavior.
        /// </summary>
        public FetchOptions FetchOptions = new FetchOptions();

        CheckoutCallbacks IConvertableToGitCheckoutOpts.GenerateCallbacks()
        {
            return CheckoutCallbacks.From(OnCheckoutProgress, OnCheckoutNotify);
        }

        CheckoutStrategy IConvertableToGitCheckoutOpts.CheckoutStrategy
        {
            get { return CheckoutStrategy.GIT_CHECKOUT_SAFE; }
        }

        CheckoutNotifyFlags IConvertableToGitCheckoutOpts.CheckoutNotifyFlags
        {
            get { return CheckoutNotifyFlags; }
        }
    }

    /// <summary>
    /// Credential types supported by the server. If the server supports a particular type of
    /// authentication, it will be set to true.
    /// </summary>
    [Flags]
    public enum SupportedCredentialTypes
    {
        /// <summary>
        /// Plain username and password combination
        /// </summary>
        UsernamePassword = (1 << 0),

        /// <summary>
        /// Ask Windows to provide its default credentials for the current user (e.g. NTLM)
        /// </summary>
        Default = (1 << 1),
    }

    /// <summary>
    /// A SymbolicReference is a reference that points to another reference
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class SymbolicReference : Reference
    {
        private readonly Reference target;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected SymbolicReference()
        { }

        internal SymbolicReference(IRepository repo, string canonicalName, string targetIdentifier, Reference target)
            : base(repo, canonicalName, targetIdentifier)
        {
            this.target = target;
        }

        /// <summary>
        /// Gets the target of this <see cref="SymbolicReference"/>
        /// </summary>
        public virtual Reference Target
        {
            get { return target; }
        }

        /// <summary>
        /// Recursively peels the target of the reference until a direct reference is encountered.
        /// </summary>
        /// <returns>The <see cref="DirectReference"/> this <see cref="SymbolicReference"/> points to.</returns>
        public override DirectReference ResolveToDirectReference()
        {
            return (Target == null) ? null : Target.ResolveToDirectReference();
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0} => {1} => \"{2}\"",
                                     CanonicalName,
                                     TargetIdentifier,
                                     (Target != null)
                                         ? Target.TargetIdentifier
                                         : "?");
            }
        }
    }

    /// <summary>
    /// A Tag
    /// </summary>
    public class Tag : ReferenceWrapper<GitObject>
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Tag()
        { }

        internal Tag(Repository repo, Reference reference, string canonicalName)
            : base(repo, reference, _ => canonicalName)
        { }

        /// <summary>
        /// Gets the optional information associated to this tag.
        /// <para>When the <see cref="Tag"/> is a lightweight tag, <c>null</c> is returned.</para>
        /// </summary>
        public virtual TagAnnotation Annotation
        {
            get { return TargetObject as TagAnnotation; }
        }

        /// <summary>
        /// Gets the <see cref="GitObject"/> that this tag points to.
        /// </summary>
        public virtual GitObject Target
        {
            get
            {
                GitObject target = TargetObject;

                var annotation = target as TagAnnotation;

                return annotation == null ? target : annotation.Target;
            }
        }

        /// <summary>
        /// Gets the peeled <see cref="GitObject"/> that this tag points to.
        /// </summary>
        public virtual GitObject PeeledTarget
        {
            get
            {
                GitObject target = TargetObject;

                var annotation = target as TagAnnotation;

                while (annotation != null)
                {
                    target = annotation.Target;
                    annotation = target as TagAnnotation;
                }

                return target;
            }
        }

        /// <summary>
        /// Indicates whether the tag holds any metadata.
        /// </summary>
        public virtual bool IsAnnotated
        {
            get { return Annotation != null; }
        }

        /// <summary>
        /// Removes redundent leading namespaces (regarding the kind of
        /// reference being wrapped) from the canonical name.
        /// </summary>
        /// <returns>The friendly shortened name</returns>
        protected override string Shorten()
        {
            return CanonicalName.Substring(Reference.TagPrefix.Length);
        }
    }

    /// <summary>
    /// A TagAnnotation
    /// </summary>
    public class TagAnnotation : GitObject
    {
        private readonly GitObjectLazyGroup group;
        private readonly ILazy<GitObject> lazyTarget;
        private readonly ILazy<string> lazyName;
        private readonly ILazy<string> lazyMessage;
        private readonly ILazy<Signature> lazyTagger;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected TagAnnotation()
        { }

        internal TagAnnotation(Repository repo, ObjectId id)
            : base(repo, id)
        {
            lazyName = GitObjectLazyGroup.Singleton(repo, id, Proxy.git_tag_name);
            lazyTarget = GitObjectLazyGroup.Singleton(repo,
                                                      id,
                                                      obj => BuildFrom(repo,
                                                                       Proxy.git_tag_target_id(obj),
                                                                       Proxy.git_tag_target_type(obj),
                                                                       null));

            group = new GitObjectLazyGroup(repo, id);
            lazyTagger = group.AddLazy(Proxy.git_tag_tagger);
            lazyMessage = group.AddLazy(Proxy.git_tag_message);
        }

        /// <summary>
        /// Gets the name of this tag.
        /// </summary>
        public virtual string Name { get { return lazyName.Value; } }

        /// <summary>
        /// Gets the message of this tag.
        /// </summary>
        public virtual string Message { get { return lazyMessage.Value; } }

        /// <summary>
        /// Gets the <see cref="GitObject"/> that this tag annotation points to.
        /// </summary>
        public virtual GitObject Target { get { return lazyTarget.Value; } }

        /// <summary>
        /// Gets the tagger.
        /// </summary>
        public virtual Signature Tagger { get { return lazyTagger.Value; } }
    }

    /// <summary>
    /// The collection of <see cref="Tag"/>s in a <see cref="Repository"/>
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class TagCollection : IEnumerable<Tag>
    {
        internal readonly Repository repo;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected TagCollection()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="TagCollection"/> class.
        /// </summary>
        /// <param name="repo">The repo.</param>
        internal TagCollection(Repository repo)
        {
            this.repo = repo;
        }

        /// <summary>
        /// Gets the <see cref="Tag"/> with the specified name.
        /// </summary>
        public virtual Tag this[string name]
        {
            get
            {
                Ensure.ArgumentNotNullOrEmptyString(name, "name");
                var canonicalName = NormalizeToCanonicalName(name);
                var reference = repo.Refs.Resolve<Reference>(canonicalName);
                return reference == null ? null : new Tag(repo, reference, canonicalName);
            }
        }

        #region IEnumerable<Tag> Members

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<Tag> GetEnumerator()
        {
            return Proxy
                .git_tag_list(repo.Handle)
                .Select(n => this[n])
                .GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        /// <summary>
        /// Creates an annotated tag with the specified name.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="objectish">Revparse spec for the target object.</param>
        /// <param name="tagger">The tagger.</param>
        /// <param name="message">The message.</param>
        public virtual Tag Add(string name, string objectish, Signature tagger, string message)
        {
            return Add(name, objectish, tagger, message, false);
        }

        /// <summary>
        /// Creates an annotated tag with the specified name.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="objectish">Revparse spec for the target object.</param>
        /// <param name="tagger">The tagger.</param>
        /// <param name="message">The message.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing tag, false otherwise.</param>
        public virtual Tag Add(string name, string objectish, Signature tagger, string message, bool allowOverwrite)
        {
            Ensure.ArgumentNotNullOrEmptyString(objectish, "target");

            GitObject objectToTag = repo.Lookup(objectish, GitObjectType.Any, LookUpOptions.ThrowWhenNoGitObjectHasBeenFound);

            return Add(name, objectToTag, tagger, message, allowOverwrite);
        }

        /// <summary>
        /// Creates a lightweight tag with the specified name.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="objectish">Revparse spec for the target object.</param>
        public virtual Tag Add(string name, string objectish)
        {
            return Add(name, objectish, false);
        }

        /// <summary>
        /// Creates a lightweight tag with the specified name.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="objectish">Revparse spec for the target object.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing tag, false otherwise.</param>
        public virtual Tag Add( string name, string objectish, bool allowOverwrite)
        {
            Ensure.ArgumentNotNullOrEmptyString(objectish, "objectish");

            GitObject objectToTag = repo.Lookup(objectish, GitObjectType.Any, LookUpOptions.ThrowWhenNoGitObjectHasBeenFound);

            return Add(name, objectToTag, allowOverwrite);
        }

        /// <summary>
        /// Creates an annotated tag with the specified name.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="target">The target <see cref="GitObject"/>.</param>
        /// <param name="tagger">The tagger.</param>
        /// <param name="message">The message.</param>
        /// <returns>The added <see cref="Tag"/>.</returns>
        public virtual Tag Add(string name, GitObject target, Signature tagger, string message)
        {
            return Add(name, target, tagger, message, false);
        }

        /// <summary>
        /// Creates an annotated tag with the specified name.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="target">The target <see cref="GitObject"/>.</param>
        /// <param name="tagger">The tagger.</param>
        /// <param name="message">The message.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing tag, false otherwise.</param>
        /// <returns>The added <see cref="Tag"/>.</returns>
        public virtual Tag Add(string name, GitObject target, Signature tagger, string message, bool allowOverwrite)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");
            Ensure.ArgumentNotNull(target, "target");
            Ensure.ArgumentNotNull(tagger, "tagger");
            Ensure.ArgumentNotNull(message, "message");

            string prettifiedMessage = Proxy.git_message_prettify(message, null);

            Proxy.git_tag_create(repo.Handle, name, target, tagger, prettifiedMessage, allowOverwrite);

            return this[name];
        }

        /// <summary>
        /// Creates a lightweight tag with the specified name.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="target">The target <see cref="GitObject"/>.</param>
        /// <returns>The added <see cref="Tag"/>.</returns>
        public virtual Tag Add(string name, GitObject target)
        {
            return Add(name, target, false);
        }

        /// <summary>
        /// Creates a lightweight tag with the specified name.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="target">The target <see cref="GitObject"/>.</param>
        /// <param name="allowOverwrite">True to allow silent overwriting a potentially existing tag, false otherwise.</param>
        /// <returns>The added <see cref="Tag"/>.</returns>
        public virtual Tag Add(string name, GitObject target, bool allowOverwrite)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");
            Ensure.ArgumentNotNull(target, "target");

            Proxy.git_tag_create_lightweight(repo.Handle, name, target, allowOverwrite);

            return this[name];
        }

        /// <summary>
        /// Deletes the tag with the specified name.
        /// </summary>
        /// <param name="name">The short or canonical name of the tag to delete.</param>
        public virtual void Remove(string name)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");

            Proxy.git_tag_delete(repo.Handle, UnCanonicalizeName(name));
        }

        /// <summary>
        /// Deletes the tag with the specified name.
        /// </summary>
        /// <param name="tag">The tag to delete.</param>
        public virtual void Remove(Tag tag)
        {
            Ensure.ArgumentNotNull(tag, "tag");

            Remove(tag.CanonicalName);
        }

        private static string NormalizeToCanonicalName(string name)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");

            if (name.LooksLikeTag())
            {
                return name;
            }

            return string.Concat(Reference.TagPrefix, name);
        }

        private static string UnCanonicalizeName(string name)
        {
            Ensure.ArgumentNotNullOrEmptyString(name, "name");

            if (!name.LooksLikeTag())
            {
                return name;
            }

            return name.Substring(Reference.TagPrefix.Length);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "Count = {0}", this.Count());
            }
        }
    }

    /// <summary>
    /// Describe the expected tag retrieval behavior
    /// when a fetch operation is being performed.
    /// </summary>
    public enum TagFetchMode
    {
        /// <summary>
        /// Use the setting from the configuration
        /// or, when there isn't any, fallback to default behavior.
        /// </summary>
        FromConfigurationOrDefault = 0,  // GIT_REMOTE_DOWNLOAD_TAGS_FALLBACK

        /// <summary>
        /// Will automatically retrieve tags that
        /// point to objects retrieved during this fetch.
        /// </summary>
        Auto,  // GIT_REMOTE_DOWNLOAD_TAGS_AUTO

        /// <summary>
        /// No tag will be retrieved.
        /// </summary>
        None,  // GIT_REMOTE_DOWNLOAD_TAGS_NONE

        /// <summary>
        /// All tags will be downloaded, but _only_ tags, along with
        /// all the objects these tags are pointing to.
        /// </summary>
        All,   // GIT_REMOTE_DOWNLOAD_TAGS_ALL
    }

    /// <summary>
    /// Expose progress values from a fetch operation.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class TransferProgress
    {
        private GitTransferProgress gitTransferProgress;

        /// <summary>
        /// Empty constructor.
        /// </summary>
        protected TransferProgress()
        { }

        /// <summary>
        /// Constructor.
        /// </summary>
        internal TransferProgress(GitTransferProgress gitTransferProgress)
        {
            this.gitTransferProgress = gitTransferProgress;
        }

        /// <summary>
        /// Total number of objects.
        /// </summary>
        public virtual int TotalObjects
        {
            get { return (int)gitTransferProgress.total_objects; }
        }

        /// <summary>
        /// Number of objects indexed.
        /// </summary>
        public virtual int IndexedObjects
        {
            get { return (int)gitTransferProgress.indexed_objects; }
        }

        /// <summary>
        /// Number of objects received.
        /// </summary>
        public virtual int ReceivedObjects
        {
            get { return (int)gitTransferProgress.received_objects; }
        }

        /// <summary>
        /// Number of bytes received.
        /// </summary>
        public virtual long ReceivedBytes
        {
            get { return (long)gitTransferProgress.received_bytes; }
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0}/{1}, {2} bytes",
                                     ReceivedObjects,
                                     TotalObjects,
                                     ReceivedBytes);
            }
        }
    }

    /// <summary>
    /// An implementation of <see cref="Index"/> with disposal managed by the caller
    /// (instead of automatically disposing when the repository is disposed)
    /// </summary>
    public class TransientIndex: Index, IDisposable
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected TransientIndex()
        { }

        internal TransientIndex(IndexHandle handle, Repository repo)
            : base(handle, repo)
        {
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            this.Handle.SafeDispose();
        }
    }

    /// <summary>
    /// A container which references a list of other <see cref="Tree"/>s and <see cref="Blob"/>s.
    /// </summary>
    /// <remarks>
    /// Since the introduction of partially cloned repositories, trees might be missing on your local repository (see https://git-scm.com/docs/partial-clone)
    /// </remarks>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class Tree : GitObject, IEnumerable<TreeEntry>
    {
        private readonly string path;

        private readonly ILazy<int> lazyCount;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Tree()
        { }

        internal Tree(Repository repo, ObjectId id, string path)
            : base(repo, id)
        {
            this.path = path ?? "";

            lazyCount = GitObjectLazyGroup.Singleton(repo, id, Proxy.git_tree_entrycount, throwIfMissing: true);
        }

        /// <summary>
        /// Gets the number of <see cref="TreeEntry"/> immediately under this <see cref="Tree"/>.
        /// </summary>
        /// <exception cref="NotFoundException">Throws if tree is missing</exception>
        public virtual int Count { get { return lazyCount.Value; } }

        /// <summary>
        /// Gets the <see cref="TreeEntry"/> pointed at by the <paramref name="relativePath"/> in this <see cref="Tree"/> instance.
        /// </summary>
        /// <param name="relativePath">The relative path to the <see cref="TreeEntry"/> from this instance.</param>
        /// <returns><c>null</c> if nothing has been found, the <see cref="TreeEntry"/> otherwise.</returns>
        /// <exception cref="NotFoundException">Throws if tree is missing</exception>
        public virtual TreeEntry this[string relativePath]
        {
            get { return RetrieveFromPath(relativePath); }
        }

        private unsafe TreeEntry RetrieveFromPath(string relativePath)
        {
            if (string.IsNullOrEmpty(relativePath))
            {
                return null;
            }

            using (TreeEntryHandle treeEntry = Proxy.git_tree_entry_bypath(repo.Handle, Id, relativePath))
            {
                if (treeEntry == null)
                {
                    return null;
                }

                string filename = relativePath.Split('/').Last();
                string parentPath = relativePath.Substring(0, relativePath.Length - filename.Length);
                return new TreeEntry(treeEntry, Id, repo, Tree.CombinePath(path, parentPath));
            }
        }

        internal string Path { get { return path; } }

        #region IEnumerable<TreeEntry> Members

        unsafe TreeEntry byIndex(ObjectSafeWrapper obj, uint i, ObjectId parentTreeId, Repository repo, string parentPath)
        {
            using (var entryHandle = Proxy.git_tree_entry_byindex(obj.ObjectPtr, i))
            {
                return new TreeEntry(entryHandle, parentTreeId, repo, parentPath);
            }
        }

        internal static string CombinePath(string a, string b)
        {
            var bld = new StringBuilder();
            bld.Append(a);
            if (!String.IsNullOrEmpty(a) &&
                !a.EndsWith("/", StringComparison.Ordinal) &&
                !b.StartsWith("/", StringComparison.Ordinal))
            {
                bld.Append('/');
            }
            bld.Append(b);

            return bld.ToString();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        /// <exception cref="NotFoundException">Throws if tree is missing</exception>
        public virtual IEnumerator<TreeEntry> GetEnumerator()
        {
            using (var obj = new ObjectSafeWrapper(Id, repo.Handle, throwIfMissing: true))
            {
                for (uint i = 0; i < Count; i++) {
                    yield return byIndex(obj, i, Id, repo, path);
                }
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        /// <exception cref="NotFoundException">Throws if tree is missing</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0}, Count = {1}",
                                     Id.ToString(7),
                                     Count);
            }
        }
    }

    /// <summary>
    /// Holds the result of a diff between two trees.
    /// <para>Changes at the granularity of the file can be obtained through the different sub-collections <see cref="Added"/>, <see cref="Deleted"/> and <see cref="Modified"/>.</para>
    /// <para>To obtain the actual patch of the diff, use the <see cref="Patch"/> class when calling Compare.</para>.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class TreeChanges : IEnumerable<TreeEntryChanges>, IDiffResult
    {
        private readonly DiffHandle diff;
        private readonly Lazy<int> count;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected TreeChanges()
        { }

        internal unsafe TreeChanges(DiffHandle diff)
        {
            this.diff = diff;
            this.count = new Lazy<int>(() => Proxy.git_diff_num_deltas(diff));
        }

        /// <summary>
        /// Enumerates the diff and yields deltas with the specified change kind.
        /// </summary>
        /// <param name="changeKind">Change type to filter on.</param>
        private IEnumerable<TreeEntryChanges> GetChangesOfKind(ChangeKind changeKind)
        {
            TreeEntryChanges entry;
            for (int i = 0; i < Count; i++)
            {
                if (TryGetEntryWithChangeTypeAt(i, changeKind, out entry))
                {
                    yield return entry;
                }
            }
        }

        /// <summary>
        /// This is method exists to work around .net not allowing unsafe code
        /// in iterators.
        /// </summary>
        private unsafe bool TryGetEntryWithChangeTypeAt(int index, ChangeKind changeKind, out TreeEntryChanges entry)
        {
            if (index < 0 || index > count.Value)
                throw new ArgumentOutOfRangeException("index", "Index was out of range. Must be non-negative and less than the size of the collection.");

            var delta = Proxy.git_diff_get_delta(diff, index);

            if (TreeEntryChanges.GetStatusFromChangeKind(delta->status) == changeKind)
            {
                entry = new TreeEntryChanges(delta);
                return true;
            }

            entry = null;
            return false;
        }

        #region IEnumerable<TreeEntryChanges> Members

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<TreeEntryChanges> GetEnumerator()
        {
            for (int i = 0; i < Count; i++)
            {
                yield return GetEntryAt(i);
            }
        }

        /// <summary>
        /// This is method exists to work around .net not allowing unsafe code
        /// in iterators.
        /// </summary>
        private unsafe TreeEntryChanges GetEntryAt(int index)
        {
            if (index < 0 || index > count.Value)
                throw new ArgumentOutOfRangeException("index", "Index was out of range. Must be non-negative and less than the size of the collection.");

            return new TreeEntryChanges(Proxy.git_diff_get_delta(diff, index));
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        /// <summary>
        /// List of <see cref="TreeEntryChanges"/> that have been been added.
        /// </summary>
        public virtual IEnumerable<TreeEntryChanges> Added
        {
            get { return GetChangesOfKind(ChangeKind.Added); }
        }

        /// <summary>
        /// List of <see cref="TreeEntryChanges"/> that have been deleted.
        /// </summary>
        public virtual IEnumerable<TreeEntryChanges> Deleted
        {
            get { return GetChangesOfKind(ChangeKind.Deleted); }
        }

        /// <summary>
        /// List of <see cref="TreeEntryChanges"/> that have been modified.
        /// </summary>
        public virtual IEnumerable<TreeEntryChanges> Modified
        {
            get { return GetChangesOfKind(ChangeKind.Modified); }
        }

        /// <summary>
        /// List of <see cref="TreeEntryChanges"/> which type have been changed.
        /// </summary>
        public virtual IEnumerable<TreeEntryChanges> TypeChanged
        {
            get { return GetChangesOfKind(ChangeKind.TypeChanged); }
        }

        /// <summary>
        /// List of <see cref="TreeEntryChanges"/> which have been renamed
        /// </summary>
        public virtual IEnumerable<TreeEntryChanges> Renamed
        {
            get { return GetChangesOfKind(ChangeKind.Renamed); }
        }

        /// <summary>
        /// List of <see cref="TreeEntryChanges"/> which have been copied
        /// </summary>
        public virtual IEnumerable<TreeEntryChanges> Copied
        {
            get { return GetChangesOfKind(ChangeKind.Copied); }
        }

        /// <summary>
        /// List of <see cref="TreeEntryChanges"/> which are unmodified
        /// </summary>
        public virtual IEnumerable<TreeEntryChanges> Unmodified
        {
            get { return GetChangesOfKind(ChangeKind.Unmodified); }
        }

        /// <summary>
        /// List of <see cref="TreeEntryChanges"/> which are conflicted
        /// </summary>
        public virtual IEnumerable<TreeEntryChanges> Conflicted
        {
            get { return GetChangesOfKind(ChangeKind.Conflicted); }
        }

        /// <summary>
        /// Gets the number of <see cref="TreeEntryChanges"/> in this comparison.
        /// </summary>
        public virtual int Count
        {
            get { return count.Value; }
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "+{0} ~{1} -{2} \u00B1{3} R{4} C{5}",
                                     Added.Count(),
                                     Modified.Count(),
                                     Deleted.Count(),
                                     TypeChanged.Count(),
                                     Renamed.Count(),
                                     Copied.Count());
            }
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources.
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            diff.SafeDispose();
        }
    }

    /// <summary>
    /// Holds the meta data of a <see cref="Tree"/>.
    /// </summary>
    public class TreeDefinition
    {
        private readonly Dictionary<string, TreeEntryDefinition> entries = new Dictionary<string, TreeEntryDefinition>();
        private readonly Dictionary<string, TreeDefinition> unwrappedTrees = new Dictionary<string, TreeDefinition>();

        /// <summary>
        /// Builds a <see cref="TreeDefinition"/> from an existing <see cref="Tree"/>.
        /// </summary>
        /// <param name="tree">The <see cref="Tree"/> to be processed.</param>
        /// <returns>A new <see cref="TreeDefinition"/> holding the meta data of the <paramref name="tree"/>.</returns>
        public static TreeDefinition From(Tree tree)
        {
            Ensure.ArgumentNotNull(tree, "tree");

            var td = new TreeDefinition();

            foreach (TreeEntry treeEntry in tree)
            {
                td.Add(treeEntry.Name, treeEntry);
            }

            return td;
        }

        /// <summary>
        /// Builds a <see cref="TreeDefinition"/> from a <see cref="Commit"/>'s <see cref="Tree"/>.
        /// </summary>
        /// <param name="commit">The <see cref="Commit"/> whose tree is to be processed</param>
        /// <returns>A new <see cref="TreeDefinition"/> holding the meta data of the <paramref name="commit"/>'s <see cref="Tree"/>.</returns>
        public static TreeDefinition From(Commit commit)
        {
            Ensure.ArgumentNotNull(commit, "commit");

            return From(commit.Tree);
        }

        private void AddEntry(string targetTreeEntryName, TreeEntryDefinition treeEntryDefinition)
        {
            if (entries.ContainsKey(targetTreeEntryName))
            {
                WrapTree(targetTreeEntryName, treeEntryDefinition);
                return;
            }

            entries.Add(targetTreeEntryName, treeEntryDefinition);
        }

        /// <summary>
        /// Removes the <see cref="TreeEntryDefinition"/> located at each of the
        /// specified <paramref name="treeEntryPaths"/>.
        /// </summary>
        /// <param name="treeEntryPaths">The paths within this <see cref="TreeDefinition"/>.</param>
        /// <returns>The current <see cref="TreeDefinition"/>.</returns>
        public virtual TreeDefinition Remove(IEnumerable<string> treeEntryPaths)
        {
            Ensure.ArgumentNotNull(treeEntryPaths, "treeEntryPaths");

            foreach (var treeEntryPath in treeEntryPaths)
            {
                Remove(treeEntryPath);
            }

            return this;
        }

        /// <summary>
        /// Removes a <see cref="TreeEntryDefinition"/> located the specified <paramref name="treeEntryPath"/> path.
        /// </summary>
        /// <param name="treeEntryPath">The path within this <see cref="TreeDefinition"/>.</param>
        /// <returns>The current <see cref="TreeDefinition"/>.</returns>
        public virtual TreeDefinition Remove(string treeEntryPath)
        {
            Ensure.ArgumentNotNullOrEmptyString(treeEntryPath, "treeEntryPath");

            if (this[treeEntryPath] == null)
            {
                return this;
            }

            Tuple<string, string> segments = ExtractPosixLeadingSegment(treeEntryPath);

            if (segments.Item2 == null)
            {
                entries.Remove(segments.Item1);
            }

            if (!unwrappedTrees.ContainsKey(segments.Item1))
            {
                return this;
            }

            if (segments.Item2 != null)
            {
                unwrappedTrees[segments.Item1].Remove(segments.Item2);
            }

            if (unwrappedTrees[segments.Item1].entries.Count == 0)
            {
                unwrappedTrees.Remove(segments.Item1);
                entries.Remove(segments.Item1);
            }

            return this;
        }

        /// <summary>
        /// Adds or replaces a <see cref="TreeEntryDefinition"/> at the specified <paramref name="targetTreeEntryPath"/> location.
        /// </summary>
        /// <param name="targetTreeEntryPath">The path within this <see cref="TreeDefinition"/>.</param>
        /// <param name="treeEntryDefinition">The <see cref="TreeEntryDefinition"/> to be stored at the described location.</param>
        /// <returns>The current <see cref="TreeDefinition"/>.</returns>
        public virtual TreeDefinition Add(string targetTreeEntryPath, TreeEntryDefinition treeEntryDefinition)
        {
            Ensure.ArgumentNotNullOrEmptyString(targetTreeEntryPath, "targetTreeEntryPath");
            Ensure.ArgumentNotNull(treeEntryDefinition, "treeEntryDefinition");

            if (treeEntryDefinition is TransientTreeTreeEntryDefinition)
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture,
                                                                  "The {0} references a target which hasn't been created in the {1} yet. " +
                                                                  "This situation can occur when the target is a whole new {2} being created, " +
                                                                  "or when an existing {2} is being updated because some of its children were added/removed.",
                                                                  typeof(TreeEntryDefinition).Name,
                                                                  typeof(ObjectDatabase).Name,
                                                                  typeof(Tree).Name));
            }

            Tuple<string, string> segments = ExtractPosixLeadingSegment(targetTreeEntryPath);

            if (segments.Item2 != null)
            {
                TreeDefinition td = RetrieveOrBuildTreeDefinition(segments.Item1, true);
                td.Add(segments.Item2, treeEntryDefinition);
            }
            else
            {
                AddEntry(segments.Item1, treeEntryDefinition);
            }

            return this;
        }

        /// <summary>
        /// Adds or replaces a <see cref="TreeEntryDefinition"/>, built from the provided <see cref="TreeEntry"/>, at the specified <paramref name="targetTreeEntryPath"/> location.
        /// </summary>
        /// <param name="targetTreeEntryPath">The path within this <see cref="TreeDefinition"/>.</param>
        /// <param name="treeEntry">The <see cref="TreeEntry"/> to be stored at the described location.</param>
        /// <returns>The current <see cref="TreeDefinition"/>.</returns>
        public virtual TreeDefinition Add(string targetTreeEntryPath, TreeEntry treeEntry)
        {
            Ensure.ArgumentNotNull(treeEntry, "treeEntry");

            TreeEntryDefinition ted = TreeEntryDefinition.From(treeEntry);

            return Add(targetTreeEntryPath, ted);
        }

        /// <summary>
        /// Adds or replaces a <see cref="TreeEntryDefinition"/>, dynamically built from the provided <see cref="Blob"/>, at the specified <paramref name="targetTreeEntryPath"/> location.
        /// </summary>
        /// <param name="targetTreeEntryPath">The path within this <see cref="TreeDefinition"/>.</param>
        /// <param name="blob">The <see cref="Blob"/> to be stored at the described location.</param>
        /// <param name="mode">The file related <see cref="Mode"/> attributes.</param>
        /// <returns>The current <see cref="TreeDefinition"/>.</returns>
        public virtual TreeDefinition Add(string targetTreeEntryPath, Blob blob, Mode mode)
        {
            Ensure.ArgumentNotNull(blob, "blob");
            Ensure.ArgumentConformsTo(mode, m => m.HasAny(TreeEntryDefinition.BlobModes), "mode");

            TreeEntryDefinition ted = TreeEntryDefinition.From(blob, mode);

            return Add(targetTreeEntryPath, ted);
        }

        /// <summary>
        /// Adds or replaces a <see cref="TreeEntryDefinition"/>, dynamically built from the content of the file, at the specified <paramref name="targetTreeEntryPath"/> location.
        /// </summary>
        /// <param name="targetTreeEntryPath">The path within this <see cref="TreeDefinition"/>.</param>
        /// <param name="filePath">The path to the file from which a <see cref="Blob"/> will be built and stored at the described location. A relative path is allowed to be passed if the target
        /// <see cref="Repository"/> is a standard, non-bare, repository. The path will then be considered as a path relative to the root of the working directory.</param>
        /// <param name="mode">The file related <see cref="Mode"/> attributes.</param>
        /// <returns>The current <see cref="TreeDefinition"/>.</returns>
        public virtual TreeDefinition Add(string targetTreeEntryPath, string filePath, Mode mode)
        {
            Ensure.ArgumentNotNullOrEmptyString(filePath, "filePath");

            TreeEntryDefinition ted = TreeEntryDefinition.TransientBlobFrom(filePath, mode);

            return Add(targetTreeEntryPath, ted);
        }

        /// <summary>
        /// Adds or replaces a <see cref="TreeEntryDefinition"/> from an existing blob specified by its Object ID at the specified <paramref name="targetTreeEntryPath"/> location.
        /// </summary>
        /// <param name="targetTreeEntryPath">The path within this <see cref="TreeDefinition"/>.</param>
        /// <param name="id">The object ID for this entry.</param>
        /// <param name="mode">The file related <see cref="Mode"/> attributes.</param>
        /// <returns>The current <see cref="TreeDefinition"/>.</returns>
        public virtual TreeDefinition Add(string targetTreeEntryPath, ObjectId id, Mode mode)
        {
            Ensure.ArgumentNotNull(id, "id");
            Ensure.ArgumentConformsTo(mode, m => m.HasAny(TreeEntryDefinition.BlobModes), "mode");

            TreeEntryDefinition ted = TreeEntryDefinition.From(id, mode);

            return Add(targetTreeEntryPath, ted);
        }

        /// <summary>
        /// Adds or replaces a <see cref="TreeEntryDefinition"/>, dynamically built from the provided <see cref="Tree"/>, at the specified <paramref name="targetTreeEntryPath"/> location.
        /// </summary>
        /// <param name="targetTreeEntryPath">The path within this <see cref="TreeDefinition"/>.</param>
        /// <param name="tree">The <see cref="Tree"/> to be stored at the described location.</param>
        /// <returns>The current <see cref="TreeDefinition"/>.</returns>
        public virtual TreeDefinition Add(string targetTreeEntryPath, Tree tree)
        {
            Ensure.ArgumentNotNull(tree, "tree");

            TreeEntryDefinition ted = TreeEntryDefinition.From(tree);

            return Add(targetTreeEntryPath, ted);
        }

        /// <summary>
        /// Adds or replaces a gitlink <see cref="TreeEntryDefinition"/> equivalent to <paramref name="submodule"/>.
        /// </summary>
        /// <param name="submodule">The <see cref="Submodule"/> to be linked.</param>
        /// <returns>The current <see cref="TreeDefinition"/>.</returns>
        public virtual TreeDefinition Add(Submodule submodule)
        {
            Ensure.ArgumentNotNull(submodule, "submodule");

            return AddGitLink(submodule.Path, submodule.HeadCommitId);
        }

        /// <summary>
        /// Adds or replaces a gitlink <see cref="TreeEntryDefinition"/>,
        /// referencing the commit identified by <paramref name="objectId"/>,
        /// at the specified <paramref name="targetTreeEntryPath"/> location.
        /// </summary>
        /// <param name="targetTreeEntryPath">The path within this <see cref="TreeDefinition"/>.</param>
        /// <param name="objectId">The <see cref="ObjectId"/> of the commit to be linked at the described location.</param>
        /// <returns>The current <see cref="TreeDefinition"/>.</returns>
        public virtual TreeDefinition AddGitLink(string targetTreeEntryPath, ObjectId objectId)
        {
            Ensure.ArgumentNotNull(objectId, "objectId");

            var ted = TreeEntryDefinition.From(objectId);

            return Add(targetTreeEntryPath, ted);
        }

        private TreeDefinition RetrieveOrBuildTreeDefinition(string treeName, bool shouldOverWrite)
        {
            TreeDefinition td;

            if (unwrappedTrees.TryGetValue(treeName, out td))
            {
                return td;
            }

            TreeEntryDefinition treeEntryDefinition;
            bool hasAnEntryBeenFound = entries.TryGetValue(treeName, out treeEntryDefinition);

            if (hasAnEntryBeenFound)
            {
                switch (treeEntryDefinition.TargetType)
                {
                    case TreeEntryTargetType.Tree:
                        td = From(treeEntryDefinition.Target as Tree);
                        break;

                    case TreeEntryTargetType.Blob:
                    case TreeEntryTargetType.GitLink:
                        if (shouldOverWrite)
                        {
                            td = new TreeDefinition();
                            break;
                        }

                        return null;

                    default:
                        throw new NotImplementedException();
                }
            }
            else
            {
                if (!shouldOverWrite)
                {
                    return null;
                }

                td = new TreeDefinition();
            }

            entries[treeName] = new TransientTreeTreeEntryDefinition();

            unwrappedTrees.Add(treeName, td);
            return td;
        }

        internal Tree Build(Repository repository)
        {
            WrapAllTreeDefinitions(repository);

            using (var builder = new TreeBuilder(repository))
            {
                var builtTreeEntryDefinitions = new List<Tuple<string, TreeEntryDefinition>>(entries.Count);

                foreach (KeyValuePair<string, TreeEntryDefinition> kvp in entries)
                {
                    string name = kvp.Key;
                    TreeEntryDefinition ted = kvp.Value;

                    var transient = ted as TransientBlobTreeEntryDefinition;

                    if (transient == null)
                    {
                        builder.Insert(name, ted);
                        continue;
                    }

                    Blob blob = transient.Builder(repository.ObjectDatabase);
                    TreeEntryDefinition ted2 = TreeEntryDefinition.From(blob, ted.Mode);
                    builtTreeEntryDefinitions.Add(new Tuple<string, TreeEntryDefinition>(name, ted2));

                    builder.Insert(name, ted2);
                }

                builtTreeEntryDefinitions.ForEach(t => entries[t.Item1] = t.Item2);

                ObjectId treeId = builder.Write();
                var result = repository.Lookup<Tree>(treeId);
                if (result == null)
                {
                    throw new LibGit2SharpException("Unable to read created tree");
                }
                return result;
            }
        }

        private void WrapAllTreeDefinitions(Repository repository)
        {
            foreach (KeyValuePair<string, TreeDefinition> pair in unwrappedTrees)
            {
                Tree tree = pair.Value.Build(repository);
                entries[pair.Key] = TreeEntryDefinition.From(tree);
            }

            unwrappedTrees.Clear();
        }

        private void WrapTree(string entryName, TreeEntryDefinition treeEntryDefinition)
        {
            entries[entryName] = treeEntryDefinition;
            unwrappedTrees.Remove(entryName);
        }

        /// <summary>
        /// Retrieves the <see cref="TreeEntryDefinition"/> located the specified <paramref name="treeEntryPath"/> path.
        /// </summary>
        /// <param name="treeEntryPath">The path within this <see cref="TreeDefinition"/>.</param>
        /// <returns>The found <see cref="TreeEntryDefinition"/> if any; null otherwise.</returns>
        public virtual TreeEntryDefinition this[string treeEntryPath]
        {
            get
            {
                Ensure.ArgumentNotNullOrEmptyString(treeEntryPath, "treeEntryPath");

                Tuple<string, string> segments = ExtractPosixLeadingSegment(treeEntryPath);

                if (segments.Item2 != null)
                {
                    TreeDefinition td = RetrieveOrBuildTreeDefinition(segments.Item1, false);
                    return td == null
                        ? null
                        : td[segments.Item2];
                }

                TreeEntryDefinition treeEntryDefinition;
                return !entries.TryGetValue(segments.Item1, out treeEntryDefinition) ? null : treeEntryDefinition;
            }
        }

        private static Tuple<string, string> ExtractPosixLeadingSegment(string targetPath)
        {
            string[] segments = targetPath.Split(new[] { '/' }, 2);

            if (segments[0] == string.Empty || (segments.Length == 2 && (segments[1] == string.Empty || segments[1].StartsWith("/", StringComparison.Ordinal))))
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "'{0}' is not a valid path.", targetPath));
            }

            return new Tuple<string, string>(segments[0], segments.Length == 2 ? segments[1] : null);
        }

        private class TreeBuilder : IDisposable
        {
            private readonly TreeBuilderHandle handle;

            public TreeBuilder(Repository repo)
            {
                handle = Proxy.git_treebuilder_new(repo.Handle);
            }

            public void Insert(string name, TreeEntryDefinition treeEntryDefinition)
            {
                Proxy.git_treebuilder_insert(handle, name, treeEntryDefinition);
            }

            public ObjectId Write()
            {
                return Proxy.git_treebuilder_write(handle);
            }

            public void Dispose()
            {
                handle.SafeDispose();
            }
        }
    }

    /// <summary>
    /// Representation of an entry in a <see cref="Tree"/>.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class TreeEntry : IEquatable<TreeEntry>
    {
        private readonly ObjectId parentTreeId;
        private readonly Repository repo;
        private readonly Lazy<GitObject> target;
        private readonly ObjectId targetOid;
        private readonly Lazy<string> path;

        private static readonly LambdaEqualityHelper<TreeEntry> equalityHelper =
            new LambdaEqualityHelper<TreeEntry>(x => x.Name, x => x.parentTreeId);

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected TreeEntry()
        { }

        internal unsafe TreeEntry(TreeEntryHandle entry, ObjectId parentTreeId, Repository repo, string parentPath)
        {
            this.parentTreeId = parentTreeId;
            this.repo = repo;
            targetOid = Proxy.git_tree_entry_id(entry);

            GitObjectType treeEntryTargetType = Proxy.git_tree_entry_type(entry);
            TargetType = treeEntryTargetType.ToTreeEntryTargetType();

            target = new Lazy<GitObject>(RetrieveTreeEntryTarget);

            Mode = Proxy.git_tree_entry_attributes(entry);
            Name = Proxy.git_tree_entry_name(entry);
            path = new Lazy<string>(() => Tree.CombinePath(parentPath, Name));
        }

        /// <summary>
        /// Gets the file mode.
        /// </summary>
        public virtual Mode Mode { get; private set; }

        /// <summary>
        /// Gets the filename.
        /// </summary>
        public virtual string Name { get; private set; }

        /// <summary>
        /// Gets the path.
        /// <para>The path is expressed in a relative form from the latest known <see cref="Tree"/>. Path segments are separated with a forward or backslash, depending on the OS the libray is being run on."/></para>
        /// </summary>
        public virtual string Path { get { return path.Value; } }

        /// <summary>
        /// Gets the <see cref="GitObject"/> being pointed at.
        /// </summary>
        public virtual GitObject Target { get { return target.Value; } }

        internal ObjectId TargetId
        {
            get { return targetOid; }
        }

        /// <summary>
        /// Gets the <see cref="TreeEntryTargetType"/> of the <see cref="Target"/> being pointed at.
        /// </summary>
        public virtual TreeEntryTargetType TargetType { get; private set; }

        private GitObject RetrieveTreeEntryTarget()
        {
            switch (TargetType)
            {
                case TreeEntryTargetType.GitLink:
                    return new GitLink(repo, targetOid);

                case TreeEntryTargetType.Blob:
                case TreeEntryTargetType.Tree:
                    return GitObject.BuildFrom(repo, targetOid, TargetType.ToGitObjectType(), Path);

                default:
                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture,
                                                                      "TreeEntry target of type '{0}' is not supported.",
                                                                      TargetType));
            }
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="TreeEntry"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="TreeEntry"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="TreeEntry"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as TreeEntry);
        }

        /// <summary>
        /// Determines whether the specified <see cref="TreeEntry"/> is equal to the current <see cref="TreeEntry"/>.
        /// </summary>
        /// <param name="other">The <see cref="TreeEntry"/> to compare with the current <see cref="TreeEntry"/>.</param>
        /// <returns>True if the specified <see cref="TreeEntry"/> is equal to the current <see cref="TreeEntry"/>; otherwise, false.</returns>
        public bool Equals(TreeEntry other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="TreeEntry"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="TreeEntry"/> to compare.</param>
        /// <param name="right">Second <see cref="TreeEntry"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(TreeEntry left, TreeEntry right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="TreeEntry"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="TreeEntry"/> to compare.</param>
        /// <param name="right">Second <see cref="TreeEntry"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(TreeEntry left, TreeEntry right)
        {
            return !Equals(left, right);
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "TreeEntry: {0} => {1}",
                                     Path,
                                     TargetId);
            }
        }
    }

    /// <summary>
    /// Holds the changes between two versions of a tree entry.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class TreeEntryChanges
    {
        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected TreeEntryChanges()
        { }

        internal unsafe TreeEntryChanges(git_diff_delta* delta)
        {
            Path = LaxUtf8Marshaler.FromNative(delta->new_file.Path);
            OldPath = LaxUtf8Marshaler.FromNative(delta->old_file.Path);

            Mode = (Mode)delta->new_file.Mode;
            OldMode = (Mode)delta->old_file.Mode;
            Oid = ObjectId.BuildFromPtr(&delta->new_file.Id);
            OldOid = ObjectId.BuildFromPtr(&delta->old_file.Id);
            Exists = (delta->new_file.Flags & GitDiffFlags.GIT_DIFF_FLAG_EXISTS) != 0;
            OldExists = (delta->old_file.Flags & GitDiffFlags.GIT_DIFF_FLAG_EXISTS) != 0;

            Status = GetStatusFromChangeKind(delta->status);
        }

        // This treatment of change kind was apparently introduced in order to be able
        // to compare a tree against the index, see commit fdc972b. It's extracted
        // here so that TreeEntry can use the same rules without having to instantiate
        // a TreeEntryChanges object.
        internal static ChangeKind GetStatusFromChangeKind(ChangeKind changeKind)
        {
            switch (changeKind)
            {
                case ChangeKind.Untracked:
                case ChangeKind.Ignored:
                    return ChangeKind.Added;
                default:
                    return changeKind;
            }
        }

        /// <summary>
        /// The new path.
        /// </summary>
        public virtual string Path { get; private set; }

        /// <summary>
        /// The new <see cref="Mode"/>.
        /// </summary>
        public virtual Mode Mode { get; private set; }

        /// <summary>
        /// The new content hash.
        /// </summary>
        public virtual ObjectId Oid { get; private set; }

        /// <summary>
        /// The file exists in the new side of the diff.
        /// This is useful in determining if you have content in
        /// the ours or theirs side of a conflict.  This will
        /// be false during a conflict that deletes both the
        /// "ours" and "theirs" sides, or when the diff is a
        /// delete and the status is
        /// <see cref="ChangeKind.Deleted"/>.
        /// </summary>
        public virtual bool Exists { get; private set; }

        /// <summary>
        /// The kind of change that has been done (added, deleted, modified ...).
        /// </summary>
        public virtual ChangeKind Status { get; private set; }

        /// <summary>
        /// The old path.
        /// </summary>
        public virtual string OldPath { get; private set; }

        /// <summary>
        /// The old <see cref="Mode"/>.
        /// </summary>
        public virtual Mode OldMode { get; private set; }

        /// <summary>
        /// The old content hash.
        /// </summary>
        public virtual ObjectId OldOid { get; private set; }

        /// <summary>
        /// The file exists in the old side of the diff.
        /// This is useful in determining if you have an ancestor
        /// side to a conflict.  This will be false during a
        /// conflict that involves both the "ours" and "theirs"
        /// side being added, or when the diff is an add and the
        /// status is <see cref="ChangeKind.Added"/>.
        /// </summary>
        public virtual bool OldExists { get; private set; }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "Path = {0}, File {1}",
                                     !string.IsNullOrEmpty(Path)
                                         ? Path
                                         : OldPath,
                                     Status);
            }
        }
    }

    /// <summary>
    /// Holds the meta data of a <see cref="TreeEntry"/>.
    /// </summary>
    public class TreeEntryDefinition : IEquatable<TreeEntryDefinition>
    {
        private Lazy<GitObject> target;

        private static readonly LambdaEqualityHelper<TreeEntryDefinition> equalityHelper =
            new LambdaEqualityHelper<TreeEntryDefinition>(x => x.Mode, x => x.TargetType, x => x.TargetId);

        internal static readonly Enum[] BlobModes = new Enum[] { Mode.NonExecutableFile, Mode.ExecutableFile, Mode.NonExecutableGroupWritableFile, Mode.SymbolicLink };

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected TreeEntryDefinition()
        { }

        /// <summary>
        /// Gets file mode.
        /// </summary>
        public virtual Mode Mode { get; private set; }

        /// <summary>
        /// Gets the <see cref="TreeEntryTargetType"/> of the target being pointed at.
        /// </summary>
        public virtual TreeEntryTargetType TargetType { get; private set; }

        /// <summary>
        /// Gets the <see cref="ObjectId"/> of the target being pointed at.
        /// </summary>
        public virtual ObjectId TargetId { get; private set; }

        internal virtual GitObject Target
        {
            get { return target.Value; }
        }

        internal static TreeEntryDefinition From(TreeEntry treeEntry)
        {
            return new TreeEntryDefinition
            {
                Mode = treeEntry.Mode,
                TargetType = treeEntry.TargetType,
                TargetId = treeEntry.TargetId,
                target = new Lazy<GitObject>(() => treeEntry.Target)
            };
        }

        internal static TreeEntryDefinition From(Blob blob, Mode mode)
        {
            Ensure.ArgumentNotNull(blob, "blob");

            return new TreeEntryDefinition
            {
                Mode = mode,
                TargetType = TreeEntryTargetType.Blob,
                TargetId = blob.Id,
                target = new Lazy<GitObject>(() => blob)
            };
        }

        internal static TreeEntryDefinition From(ObjectId id, Mode mode)
        {
            Ensure.ArgumentNotNull(id, "id");
            Ensure.ArgumentNotNull(mode, "mode");

            return new TreeEntryDefinition
            {
                Mode = mode,
                TargetType = TreeEntryTargetType.Blob,
                TargetId = id
            };
        }

        internal static TreeEntryDefinition TransientBlobFrom(string filePath, Mode mode)
        {
            Ensure.ArgumentConformsTo(mode, m => m.HasAny(BlobModes), "mode");

            return new TransientBlobTreeEntryDefinition
            {
                Builder = odb => odb.CreateBlob(filePath),
                Mode = mode,
            };
        }

        internal static TreeEntryDefinition From(ObjectId objectId)
        {
            return new TreeEntryDefinition
            {
                Mode = Mode.GitLink,
                TargetType = TreeEntryTargetType.GitLink,
                TargetId = objectId,
                target = new Lazy<GitObject>(() => { throw new InvalidOperationException("Shouldn't be necessary."); }),
            };
        }

        internal static TreeEntryDefinition From(Tree tree)
        {
            return new TreeEntryDefinition
            {
                Mode = Mode.Directory,
                TargetType = TreeEntryTargetType.Tree,
                TargetId = tree.Id,
                target = new Lazy<GitObject>(() => tree)
            };
        }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="TreeEntryDefinition"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="TreeEntryDefinition"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="TreeEntryDefinition"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as TreeEntryDefinition);
        }

        /// <summary>
        /// Determines whether the specified <see cref="TreeEntryDefinition"/> is equal to the current <see cref="TreeEntryDefinition"/>.
        /// </summary>
        /// <param name="other">The <see cref="TreeEntryDefinition"/> to compare with the current <see cref="TreeEntryDefinition"/>.</param>
        /// <returns>True if the specified <see cref="TreeEntryDefinition"/> is equal to the current <see cref="TreeEntryDefinition"/>; otherwise, false.</returns>
        public bool Equals(TreeEntryDefinition other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Tests if two <see cref="TreeEntryDefinition"/> are equal.
        /// </summary>
        /// <param name="left">First <see cref="TreeEntryDefinition"/> to compare.</param>
        /// <param name="right">Second <see cref="TreeEntryDefinition"/> to compare.</param>
        /// <returns>True if the two objects are equal; false otherwise.</returns>
        public static bool operator ==(TreeEntryDefinition left, TreeEntryDefinition right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Tests if two <see cref="TreeEntryDefinition"/> are different.
        /// </summary>
        /// <param name="left">First <see cref="TreeEntryDefinition"/> to compare.</param>
        /// <param name="right">Second <see cref="TreeEntryDefinition"/> to compare.</param>
        /// <returns>True if the two objects are different; false otherwise.</returns>
        public static bool operator !=(TreeEntryDefinition left, TreeEntryDefinition right)
        {
            return !Equals(left, right);
        }
    }

    internal abstract class TransientTreeEntryDefinition : TreeEntryDefinition
    {
        public override ObjectId TargetId
        {
            get { return ObjectId.Zero; }
        }

        internal override GitObject Target
        {
            get { return null; }
        }
    }

    internal class TransientTreeTreeEntryDefinition : TransientTreeEntryDefinition
    {
        public override Mode Mode
        {
            get { return Mode.Directory; }
        }

        public override TreeEntryTargetType TargetType
        {
            get { return TreeEntryTargetType.Tree; }
        }
    }

    internal class TransientBlobTreeEntryDefinition : TransientTreeEntryDefinition
    {
        public override TreeEntryTargetType TargetType
        {
            get { return TreeEntryTargetType.Blob; }
        }

        public Func<ObjectDatabase, Blob> Builder { get; set; }
    }

    /// <summary>
    /// Underlying type of the target a <see cref="TreeEntry"/>
    /// </summary>
    public enum TreeEntryTargetType
    {
        /// <summary>
        /// A file revision object.
        /// </summary>
        Blob,

        /// <summary>
        /// A tree object.
        /// </summary>
        Tree,

        /// <summary>
        /// A pointer to a commit object in another repository.
        /// </summary>
        GitLink,
    }

    internal static class TreeEntryTargetTypeExtensions
    {
        public static GitObjectType ToGitObjectType(this TreeEntryTargetType type)
        {
            switch (type)
            {
                case TreeEntryTargetType.Tree:
                    return GitObjectType.Tree;

                case TreeEntryTargetType.Blob:
                    return GitObjectType.Blob;

                default:
                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture,
                                                                      "Cannot map {0} to a GitObjectType.",
                                                                      type));
            }
        }
    }

    /// <summary>
    /// The exception that is thrown when a operation requiring an existing
    /// branch is performed against an unborn branch.
    /// </summary>
    [Serializable]
    public class UnbornBranchException : LibGit2SharpException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UnbornBranchException"/> class.
        /// </summary>
        public UnbornBranchException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnbornBranchException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public UnbornBranchException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnbornBranchException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public UnbornBranchException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnbornBranchException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public UnbornBranchException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnbornBranchException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected UnbornBranchException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }
    }

    /// <summary>
    /// The exception that is thrown when an explicit path or a list of explicit paths could not be matched.
    /// </summary>
    [Serializable]
    public class UnmatchedPathException : LibGit2SharpException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UnmatchedPathException"/> class.
        /// </summary>
        public UnmatchedPathException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnmatchedPathException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public UnmatchedPathException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnmatchedPathException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public UnmatchedPathException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnmatchedPathException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public UnmatchedPathException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnmatchedPathException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected UnmatchedPathException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }
    }

    /// <summary>
    /// The exception that is thrown when an operation that requires a fully merged index
    /// is performed against an index with unmerged entries
    /// </summary>
    [Serializable]
    public class UnmergedIndexEntriesException : NativeException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UnmergedIndexEntriesException"/> class.
        /// </summary>
        public UnmergedIndexEntriesException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnmergedIndexEntriesException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public UnmergedIndexEntriesException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnmergedIndexEntriesException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public UnmergedIndexEntriesException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnmergedIndexEntriesException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public UnmergedIndexEntriesException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnmergedIndexEntriesException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected UnmergedIndexEntriesException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal UnmergedIndexEntriesException(string message, GitErrorCategory category)
            : base(message, category)
        { }

        internal override GitErrorCode ErrorCode
        {
            get
            {
                return GitErrorCode.UnmergedEntries;
            }
        }
    }

    /// <summary>
    /// The exception that is thrown when an operation is canceled.
    /// </summary>
    [Serializable]
    public class UserCancelledException : NativeException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.UserCancelledException"/> class.
        /// </summary>
        public UserCancelledException()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.UserCancelledException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        public UserCancelledException(string message)
            : base(message)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.UserCancelledException"/> class with a specified error message.
        /// </summary>
        /// <param name="format">A composite format string for use in <see cref="String.Format(IFormatProvider, string, object[])"/>.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        public UserCancelledException(string format, params object[] args)
            : base(format, args)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.UserCancelledException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException"/> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        public UserCancelledException(string message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.UserCancelledException"/> class with a serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        protected UserCancelledException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        { }

        internal UserCancelledException(string message, GitErrorCategory category)
            : base(message, category)
        { }

        internal override GitErrorCode ErrorCode
        {
            get
            {
                return GitErrorCode.User;
            }
        }
    }

    /// <summary>
    /// Class that holds username and password credentials for remote repository access.
    /// </summary>
    public sealed class UsernamePasswordCredentials : Credentials
    {
        /// <summary>
        /// Callback to acquire a credential object.
        /// </summary>
        /// <param name="cred">The newly created credential object.</param>
        /// <returns>0 for success, &lt; 0 to indicate an error, &gt; 0 to indicate no credential was acquired.</returns>
        protected internal override int GitCredentialHandler(out IntPtr cred)
        {
            if (Username == null || Password == null)
            {
                throw new InvalidOperationException("UsernamePasswordCredentials contains a null Username or Password.");
            }

            return NativeMethods.git_credential_userpass_plaintext_new(out cred, Username, Password);
        }

        static internal unsafe UsernamePasswordCredentials FromNative(GitCredentialUserpass* gitCred)
        {
            return new UsernamePasswordCredentials()
            {
                Username = LaxUtf8Marshaler.FromNative(gitCred->username),
                Password = LaxUtf8Marshaler.FromNative(gitCred->password),
            };
        }

        /// <summary>
        /// Username for username/password authentication (as in HTTP basic auth).
        /// </summary>
        public string Username { get; set; }

        /// <summary>
        /// Password for username/password authentication (as in HTTP basic auth).
        /// </summary>
        public string Password { get; set; }
    }

    internal class VoidReference : Reference
    {
        internal VoidReference(IRepository repo, string canonicalName)
            : base(repo, canonicalName, null)
        { }

        public override DirectReference ResolveToDirectReference()
        {
            return null;
        }
    }

    /// <summary>
    /// A Worktree.
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class Worktree : IEquatable<Worktree>, IBelongToARepository
    {
        private static readonly LambdaEqualityHelper<Worktree> equalityHelper =
            new LambdaEqualityHelper<Worktree>(x => x.Name);

        private readonly Repository parent;
        //private readonly Repository worktree;
        private readonly string name;
        private WorktreeLock worktreeLock;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected Worktree()
        { }

        internal Worktree(Repository repo, string name, WorktreeLock worktreeLock)
        {
            this.parent = repo;
            this.name = name;
            this.worktreeLock = worktreeLock;
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        internal WorktreeHandle GetWorktreeHandle()
        {
            return Proxy.git_worktree_lookup(parent.Handle, name);
        }

        /// <summary>
        /// The name of the worktree.
        /// </summary>
        public virtual string Name { get { return name; } }

        /// <summary>
        /// The Repository representation of the worktree
        /// </summary>
        public virtual Repository WorktreeRepository { get { return new Repository(GetWorktreeHandle()); } }

        /// <summary>
        /// A flag indicating if the worktree is locked or not.
        /// </summary>
        public virtual bool IsLocked { get { return worktreeLock == null ? false : worktreeLock.IsLocked; } }

        /// <summary>
        /// Gets the reason associated with the lock
        /// </summary>
        public virtual string LockReason { get { return worktreeLock == null ? null : worktreeLock.Reason; } }

        /// <summary>
        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="Worktree"/>.
        /// </summary>
        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="Worktree"/>.</param>
        /// <returns>True if the specified <see cref="Object"/> is equal to the current <see cref="Worktree"/>; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as Worktree);
        }

        /// <summary>
        /// Determines whether the specified <see cref="Worktree"/> is equal to the current <see cref="Worktree"/>.
        /// </summary>
        /// <param name="other">The <see cref="Worktree"/> to compare with the current <see cref="Worktree"/>.</param>
        /// <returns>True if the specified <see cref="Worktree"/> is equal to the current <see cref="Worktree"/>; otherwise, false.</returns>
        public bool Equals(Worktree other)
        {
            return equalityHelper.Equals(this, other);
        }

        /// <summary>
        ///  Unlock the worktree
        /// </summary>
        public virtual void Unlock()
        {
            using (var handle = GetWorktreeHandle())
            {
                Proxy.git_worktree_unlock(handle);
                this.worktreeLock = Proxy.git_worktree_is_locked(handle);
            }
        }

        /// <summary>
        ///  Lock the worktree
        /// </summary>
        public virtual void Lock(string reason)
        {
            using (var handle = GetWorktreeHandle())
            {
                Proxy.git_worktree_lock(handle, reason);
                this.worktreeLock = Proxy.git_worktree_is_locked(handle);
            }
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return equalityHelper.GetHashCode(this);
        }

        /// <summary>
        /// Returns the <see cref="Name"/>, a <see cref="String"/> representation of the current <see cref="Worktree"/>.
        /// </summary>
        /// <returns>The <see cref="Name"/> that represents the current <see cref="Worktree"/>.</returns>
        public override string ToString()
        {
            return Name;
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "{0} => {1}", Name, worktreeLock);
            }
        }

        IRepository IBelongToARepository.Repository { get { return parent; } }
    }

    /// <summary>
    /// The collection of worktrees in a <see cref="Repository"/>
    /// </summary>
    public class WorktreeCollection : IEnumerable<Worktree>
    {
        internal readonly Repository repo;

        /// <summary>
        /// Needed for mocking purposes.
        /// </summary>
        protected WorktreeCollection()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="LibGit2Sharp.WorktreeCollection"/> class.
        /// </summary>
        /// <param name="repo">The repo.</param>
        internal WorktreeCollection(Repository repo)
        {
            this.repo = repo;
        }

        /// <summary>
        /// Gets the <see cref="LibGit2Sharp.Submodule"/> with the specified name.
        /// </summary>
        public virtual Worktree this[string name]
        {
            get
            {
                Ensure.ArgumentNotNullOrEmptyString(name, "name");

                return Lookup(name, handle => new Worktree(repo,
                    name,
                    Proxy.git_worktree_is_locked(handle)));
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="committishOrBranchSpec"></param>
        /// <param name="name"></param>
        /// <param name="path"></param>
        /// <param name="isLocked"></param>
        /// <returns></returns>
        public virtual Worktree Add(string committishOrBranchSpec, string name, string path, bool isLocked)
        {
            if(string.Equals(committishOrBranchSpec, name))
            {
                // Proxy.git_worktree_add() creates a new branch of name = name, so if we want to checkout a given branch then the 'name' cannot be the same as the target branch
                return null;
            }

            git_worktree_add_options options = new git_worktree_add_options
            {
                version = 1,
                locked = Convert.ToInt32(isLocked)
            };

            using (var handle = Proxy.git_worktree_add(repo.Handle, name, path, options))
            {
                var worktree = new Worktree(
                      repo,
                      name,
                      Proxy.git_worktree_is_locked(handle));

                // switch the worktree to the target branch
                using (var repository = worktree.WorktreeRepository)
                {
                    Commands.Checkout(repository, committishOrBranchSpec);
                }
            }

            return this[name];
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="name"></param>
        /// <param name="path"></param>
        /// <param name="isLocked"></param>
        public virtual Worktree Add(string name, string path, bool isLocked)
        {
            git_worktree_add_options options = new git_worktree_add_options
            {
                version = 1,
                locked = Convert.ToInt32(isLocked)
            };

            using (var handle = Proxy.git_worktree_add(repo.Handle, name, path, options))
            {
                return new Worktree(
                   repo,
                   name,
                   Proxy.git_worktree_is_locked(handle));
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="worktree"></param>
        /// <returns></returns>
        public virtual bool Prune(Worktree worktree)
        {
            return Prune(worktree, false);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="worktree"></param>
        /// <param name="ifLocked"></param>
        /// <returns></returns>
        public virtual bool Prune(Worktree worktree, bool ifLocked)
        {
            using (var handle = worktree.GetWorktreeHandle())
            {
                git_worktree_prune_options options = new git_worktree_prune_options
                {
                    version = 1,
                    // default
                    flags = GitWorktreePruneOptionFlags.GIT_WORKTREE_PRUNE_WORKING_TREE | GitWorktreePruneOptionFlags.GIT_WORKTREE_PRUNE_VALID
                };

                if (ifLocked)
                {
                    options.flags |= GitWorktreePruneOptionFlags.GIT_WORKTREE_PRUNE_LOCKED;
                }

                return Proxy.git_worktree_prune(handle, options);
            }
        }

        internal T Lookup<T>(string name, Func<WorktreeHandle, T> selector, bool throwIfNotFound = false)
        {
            using (var handle = Proxy.git_worktree_lookup(repo.Handle, name))
            {
                if (handle != null && Proxy.git_worktree_validate(handle))
                {
                    return selector(handle);
                }

                if (throwIfNotFound)
                {
                    throw new LibGit2SharpException("Worktree lookup failed for '{0}'.", name);
                }

                return default(T);
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator{T}"/> object that can be used to iterate through the collection.</returns>
        public virtual IEnumerator<Worktree> GetEnumerator()
        {
            return Proxy.git_worktree_list(repo.Handle)
                .Select(n => Lookup(n, handle => new Worktree(repo, n, Proxy.git_worktree_is_locked(handle))))
                .GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/> object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "Count = {0}", this.Count());
            }
        }
    }

    /// <summary>
    ///     Represents the lock state of a Worktree
    /// </summary>
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public class WorktreeLock
    {
        /// <summary>
        ///     Creates a new instance of <see cref="WorktreeLock"/> with default, unlocked, state
        /// </summary>
        public WorktreeLock() : this(false, null)
        {

        }

        /// <summary>
        ///     Creates a new instance of <see cref="WorktreeLock"/>
        /// </summary>
        /// <param name="isLocked">the locked state</param>
        /// <param name="reason">the reason given for the lock</param>
        public WorktreeLock(bool isLocked, string reason)
        {
            _IsLocked = isLocked;
            _Reason = reason;
        }
        /// <summary>
        ///     Gets a flag indicating if the worktree is locked
        /// </summary>
        public virtual bool IsLocked { get { return _IsLocked; } }
        bool _IsLocked;

        /// <summary>
        ///     Gets the reason, if set, for the lock
        /// </summary>
        public virtual string Reason { get { return _Reason; } }
        string _Reason;

        private string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "{0} => {1}", IsLocked, Reason);
            }
        }
    }

}

namespace LibGit2Sharp.Core
{
    using LibGit2Sharp.Core.Handles;
    using LibGit2Sharp.Handlers;
    using System.Collections.Generic;
    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Runtime.ConstrainedExecution;
    using System.Runtime.InteropServices;
    using System.Text;
    using System;

    internal class ArrayMarshaler<T> : IDisposable
    {
        private readonly IntPtr[] ptrs;

        public ArrayMarshaler(T[] objs)
        {
            ptrs = new IntPtr[objs.Length];

            for (var i = 0; i < objs.Length; i++)
            {
                IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(T)));
                ptrs[i] = ptr;
                Marshal.StructureToPtr(objs[i], ptr, false);
            }
        }

        public int Count
        {
            get { return ptrs.Length; }
        }

        public IntPtr[] ToArray()
        {
            return ptrs;
        }

        public void Dispose()
        {
            foreach (var ptr in ptrs)
            {
                Marshal.FreeHGlobal(ptr);
            }
        }
    }

    internal abstract class EncodingMarshaler : ICustomMarshaler
    {
        private readonly Encoding encoding;

        protected EncodingMarshaler(Encoding encoding)
        {
            this.encoding = encoding;
        }

        #region ICustomMarshaler

        public void CleanUpManagedData(object managedObj)
        {
        }

        public virtual void CleanUpNativeData(IntPtr pNativeData)
        {
            Cleanup(pNativeData);
        }

        public int GetNativeDataSize()
        {
            // Not a value type
            return -1;
        }

        public virtual IntPtr MarshalManagedToNative(Object managedObj)
        {
            if (managedObj == null)
            {
                return IntPtr.Zero;
            }

            var str = managedObj as string;

            if (str == null)
            {
                throw new MarshalDirectiveException(string.Format(CultureInfo.InvariantCulture,
                                                                  "{0} must be used on a string.",
                                                                  GetType().Name));
            }

            return FromManaged(encoding, str);
        }

        public virtual Object MarshalNativeToManaged(IntPtr pNativeData)
        {
            return FromNative(encoding, pNativeData);
        }

        #endregion

        public static unsafe IntPtr FromManaged(Encoding encoding, String value)
        {
            if (encoding == null || value == null)
            {
                return IntPtr.Zero;
            }

            int length = encoding.GetByteCount(value);
            var buffer = (byte*)Marshal.AllocHGlobal(length + 1).ToPointer();

            if (length > 0)
            {
                fixed (char* pValue = value)
                {
                    encoding.GetBytes(pValue, value.Length, buffer, length);
                }
            }

            buffer[length] = 0;

            return new IntPtr(buffer);
        }

        public static void Cleanup(IntPtr pNativeData)
        {
            if (pNativeData == IntPtr.Zero)
            {
                return;
            }

            Marshal.FreeHGlobal(pNativeData);
        }

        public static unsafe string FromNative(Encoding encoding, IntPtr pNativeData)
        {
            return FromNative(encoding, (byte*)pNativeData);
        }

        public static unsafe string FromNative(Encoding encoding, byte* pNativeData)
        {
            if (pNativeData == null)
            {
                return null;
            }

            var start = (byte*)pNativeData;
            byte* walk = start;

            // Find the end of the string
            while (*walk != 0)
            {
                walk++;
            }

            if (walk == start)
            {
                return String.Empty;
            }

            return new String((sbyte*)pNativeData, 0, (int)(walk - start), encoding);
        }

        public static unsafe string FromNative(Encoding encoding, IntPtr pNativeData, int length)
        {
            if (pNativeData == IntPtr.Zero)
            {
                return null;
            }

            if (length == 0)
            {
                return String.Empty;
            }

            return new String((sbyte*)pNativeData.ToPointer(), 0, length, encoding);
        }

        public static string FromBuffer(Encoding encoding, byte[] buffer)
        {
            if (buffer == null)
            {
                return null;
            }

            int length = 0;
            int stop = buffer.Length;

            while (length < stop &&
                   0 != buffer[length])
            {
                length++;
            }

            return FromBuffer(encoding, buffer, length);
        }

        public static string FromBuffer(Encoding encoding, byte[] buffer, int length)
        {
            Debug.Assert(buffer != null);

            if (length == 0)
            {
                return String.Empty;
            }

            return encoding.GetString(buffer, 0, length);
        }
    }

    /// <summary>
    /// Ensure input parameters
    /// </summary>
    [DebuggerStepThrough]
    internal static class Ensure
    {
        /// <summary>
        /// Checks an argument to ensure it isn't null.
        /// </summary>
        /// <param name="argumentValue">The argument value to check.</param>
        /// <param name="argumentName">The name of the argument.</param>
        public static void ArgumentNotNull(object argumentValue, string argumentName)
        {
            if (argumentValue == null)
            {
                throw new ArgumentNullException(argumentName);
            }
        }

        /// <summary>
        /// Checks an array argument to ensure it isn't null or empty.
        /// </summary>
        /// <param name="argumentValue">The argument value to check.</param>
        /// <param name="argumentName">The name of the argument.</param>
        public static void ArgumentNotNullOrEmptyEnumerable<T>(IEnumerable<T> argumentValue, string argumentName)
        {
            ArgumentNotNull(argumentValue, argumentName);

            if (!argumentValue.Any())
            {
                throw new ArgumentException("Enumerable cannot be empty", argumentName);
            }
        }

        /// <summary>
        /// Checks a string argument to ensure it isn't null or empty.
        /// </summary>
        /// <param name="argumentValue">The argument value to check.</param>
        /// <param name="argumentName">The name of the argument.</param>
        public static void ArgumentNotNullOrEmptyString(string argumentValue, string argumentName)
        {
            ArgumentNotNull(argumentValue, argumentName);

            if (String.IsNullOrWhiteSpace (argumentValue))
            {
                throw new ArgumentException("String cannot be empty", argumentName);
            }
        }

        /// <summary>
        /// Checks a string argument to ensure it doesn't contain a zero byte.
        /// </summary>
        /// <param name="argumentValue">The argument value to check.</param>
        /// <param name="argumentName">The name of the argument.</param>
        public static void ArgumentDoesNotContainZeroByte(string argumentValue, string argumentName)
        {
            if (string.IsNullOrEmpty(argumentValue))
            {
                return;
            }

            int zeroPos = -1;
            for (var i = 0; i < argumentValue.Length; i++)
            {
                if (argumentValue[i] == '\0')
                {
                    zeroPos = i;
                    break;
                }
            }

            if (zeroPos == -1)
            {
                return;
            }

            throw new ArgumentException(
                string.Format(CultureInfo.InvariantCulture,
                    "Zero bytes ('\\0') are not allowed. A zero byte has been found at position {0}.", zeroPos), argumentName);
        }

        /// <summary>
        /// Checks an argument to ensure it isn't a IntPtr.Zero (aka null).
        /// </summary>
        /// <param name="argumentValue">The argument value to check.</param>
        /// <param name="argumentName">The name of the argument.</param>
        public static void ArgumentNotZeroIntPtr(IntPtr argumentValue, string argumentName)
        {
            if (argumentValue == IntPtr.Zero)
            {
                throw new ArgumentNullException(argumentName);
            }
        }

        /// <summary>
        /// Checks a pointer argument to ensure it is the expected pointer value.
        /// </summary>
        /// <param name="argumentValue">The argument value to check.</param>
        /// <param name="expectedValue">The expected value.</param>
        /// <param name="argumentName">The name of the argument.</param>
        public static void ArgumentIsExpectedIntPtr(IntPtr argumentValue, IntPtr expectedValue, string argumentName)
        {
            if (argumentValue != expectedValue)
            {
                throw new ArgumentException("Unexpected IntPtr value", argumentName);
            }
        }

        private static readonly Dictionary<GitErrorCode, Func<string, GitErrorCategory, LibGit2SharpException>>
            GitErrorsToLibGit2SharpExceptions =
                new Dictionary<GitErrorCode, Func<string, GitErrorCategory, LibGit2SharpException>>
                {
                    { GitErrorCode.User, (m, c) => new UserCancelledException(m, c) },
                    { GitErrorCode.BareRepo, (m, c) => new BareRepositoryException(m, c) },
                    { GitErrorCode.Exists, (m, c) => new NameConflictException(m, c) },
                    { GitErrorCode.InvalidSpecification, (m, c) => new InvalidSpecificationException(m, c) },
                    { GitErrorCode.UnmergedEntries, (m, c) => new UnmergedIndexEntriesException(m, c) },
                    { GitErrorCode.NonFastForward, (m, c) => new NonFastForwardException(m, c) },
                    { GitErrorCode.Conflict, (m, c) => new CheckoutConflictException(m, c) },
                    { GitErrorCode.LockedFile, (m, c) => new LockedFileException(m, c) },
                    { GitErrorCode.NotFound, (m, c) => new NotFoundException(m, c) },
                    { GitErrorCode.Peel, (m, c) => new PeelException(m, c) },
                };

        private static unsafe void HandleError(int result)
        {
            string errorMessage;
            GitErrorCategory errorCategory = GitErrorCategory.Unknown;
            GitError* error = NativeMethods.git_error_last();

            if (error == null)
            {
                errorMessage = "No error message has been provided by the native library";
            }
            else
            {
                errorMessage = LaxUtf8Marshaler.FromNative(error->Message);
            }

            Func<string, GitErrorCategory, LibGit2SharpException> exceptionBuilder;
            if (!GitErrorsToLibGit2SharpExceptions.TryGetValue((GitErrorCode)result, out exceptionBuilder))
            {
                exceptionBuilder = (m, c) => new LibGit2SharpException(m, c);
            }

            throw exceptionBuilder(errorMessage, errorCategory);
        }

        /// <summary>
        /// Check that the result of a C call was successful
        /// <para>
        ///   The native function is expected to return strictly 0 for
        ///   success or a negative value in the case of failure.
        /// </para>
        /// </summary>
        /// <param name="result">The result to examine.</param>
        public static void ZeroResult(int result)
        {
            if (result == (int)GitErrorCode.Ok)
            {
                return;
            }

            HandleError(result);
        }

        /// <summary>
        /// Check that the result of a C call returns a boolean value.
        /// <para>
        ///   The native function is expected to return strictly 0 or 1.
        /// </para>
        /// </summary>
        /// <param name="result">The result to examine.</param>
        public static void BooleanResult(int result)
        {
            if (result == 0 || result == 1)
            {
                return;
            }

            HandleError(result);
        }

        /// <summary>
        /// Check that the result of a C call that returns an integer
        /// value was successful.
        /// <para>
        ///   The native function is expected to return 0 or a positive
        ///   value for success or a negative value in the case of failure.
        /// </para>
        /// </summary>
        /// <param name="result">The result to examine.</param>
        public static void Int32Result(int result)
        {
            if (result >= (int)GitErrorCode.Ok)
            {
                return;
            }

            HandleError(result);
        }

        /// <summary>
        /// Checks an argument by applying provided checker.
        /// </summary>
        /// <param name="argumentValue">The argument value to check.</param>
        /// <param name="checker">The predicate which has to be satisfied</param>
        /// <param name="argumentName">The name of the argument.</param>
        public static void ArgumentConformsTo<T>(T argumentValue, Func<T, bool> checker, string argumentName)
        {
            if (checker(argumentValue))
            {
                return;
            }

            throw new ArgumentException(argumentName);
        }

        /// <summary>
        /// Checks an argument is a positive integer.
        /// </summary>
        /// <param name="argumentValue">The argument value to check.</param>
        /// <param name="argumentName">The name of the argument.</param>
        public static void ArgumentPositiveInt32(long argumentValue, string argumentName)
        {
            if (argumentValue >= 0 && argumentValue <= uint.MaxValue)
            {
                return;
            }

            throw new ArgumentException(argumentName);
        }

        /// <summary>
        /// Check that the result of a C call that returns a non-null GitObject
        /// using the default exception builder.
        /// <para>
        ///   The native function is expected to return a valid object value.
        /// </para>
        /// </summary>
        /// <param name="gitObject">The <see cref="GitObject"/> to examine.</param>
        /// <param name="identifier">The <see cref="GitObject"/> identifier to examine.</param>
        public static void GitObjectIsNotNull(GitObject gitObject, string identifier)
        {
            if (gitObject != null)
            {
                return;
            }

            var messageFormat = "No valid git object identified by '{0}' exists in the repository.";

            if (string.Equals("HEAD", identifier, StringComparison.Ordinal))
            {
                throw new UnbornBranchException(messageFormat, identifier);
            }

            throw new NotFoundException(messageFormat, identifier);
        }
    }

    internal static class EnumExtensions
    {
        public static bool HasAny(this Enum enumInstance, IEnumerable<Enum> entries)
        {
            return entries.Any(enumInstance.HasFlag);
        }
    }

    /// <summary>
    /// Specify how the remote tracking branches should be locally dealt with
    /// when their upstream countepart doesn't exist anymore.
    /// </summary>
    internal enum FetchPruneStrategy
    {
        /// <summary>
        /// Use the setting from the configuration
        /// or, when there isn't any, fallback to default behavior.
        /// </summary>
        FromConfigurationOrDefault = 0,

        /// <summary>
        /// Force pruning on
        /// </summary>
        Prune,

        /// <summary>
        /// Force pruning off
        /// </summary>
        NoPrune,
    }

    /// <summary>
    /// Represents a file-related log of commits beyond renames.
    /// </summary>
    internal class FileHistory : IEnumerable<LogEntry>
    {
        #region Fields

        /// <summary>
        /// The allowed commit sort strategies.
        /// </summary>
        private static readonly List<CommitSortStrategies> AllowedSortStrategies = new List<CommitSortStrategies>
        {
            CommitSortStrategies.Topological,
            CommitSortStrategies.Time,
            CommitSortStrategies.Topological | CommitSortStrategies.Time
        };

        /// <summary>
        /// The repository.
        /// </summary>
        private readonly Repository _repo;

        /// <summary>
        /// The file's path relative to the repository's root.
        /// </summary>
        private readonly string _path;

        /// <summary>
        /// The filter to be used in querying the commit log.
        /// </summary>
        private readonly CommitFilter _queryFilter;

        #endregion

        #region Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="FileHistory"/> class.
        /// The commits will be enumerated in reverse chronological order.
        /// </summary>
        /// <param name="repo">The repository.</param>
        /// <param name="path">The file's path relative to the repository's root.</param>
        /// <exception cref="ArgumentNullException">If any of the parameters is null.</exception>
        internal FileHistory(Repository repo, string path)
            : this(repo, path, new CommitFilter())
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="FileHistory"/> class.
        /// The given <see cref="CommitFilter"/> instance specifies the commit
        /// sort strategies and range of commits to be considered.
        /// Only the time (corresponding to <code>--date-order</code>) and topological
        /// (coresponding to <code>--topo-order</code>) sort strategies are supported.
        /// </summary>
        /// <param name="repo">The repository.</param>
        /// <param name="path">The file's path relative to the repository's root.</param>
        /// <param name="queryFilter">The filter to be used in querying the commit log.</param>
        /// <exception cref="ArgumentNullException">If any of the parameters is null.</exception>
        /// <exception cref="ArgumentException">When an unsupported commit sort strategy is specified.</exception>
        internal FileHistory(Repository repo, string path, CommitFilter queryFilter)
        {
            Ensure.ArgumentNotNull(repo, "repo");
            Ensure.ArgumentNotNull(path, "path");
            Ensure.ArgumentNotNull(queryFilter, "queryFilter");

            // Ensure the commit sort strategy makes sense.
            if (!AllowedSortStrategies.Contains(queryFilter.SortBy))
            {
                throw new ArgumentException("Unsupported sort strategy. Only 'Topological', 'Time', or 'Topological | Time' are allowed.",
                                             "queryFilter");
            }

            _repo = repo;
            _path = path;
            _queryFilter = queryFilter;
        }

        #endregion

        #region IEnumerable<LogEntry> Members

        /// <summary>
        /// Gets the <see cref="IEnumerator{LogEntry}"/> that enumerates the
        /// <see cref="LogEntry"/> instances representing the file's history,
        /// including renames (as in <code>git log --follow</code>).
        /// </summary>
        /// <returns>A <see cref="IEnumerator{LogEntry}"/>.</returns>
        public IEnumerator<LogEntry> GetEnumerator()
        {
            return FullHistory(_repo, _path, _queryFilter).GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        /// <summary>
        /// Gets the relevant commits in which the given file was created, changed, or renamed.
        /// </summary>
        /// <param name="repo">The repository.</param>
        /// <param name="path">The file's path relative to the repository's root.</param>
        /// <param name="filter">The filter to be used in querying the commits log.</param>
        /// <returns>A collection of <see cref="LogEntry"/> instances.</returns>
        private static IEnumerable<LogEntry> FullHistory(IRepository repo, string path, CommitFilter filter)
        {
            var map = new Dictionary<Commit, string>();

            foreach (var currentCommit in repo.Commits.QueryBy(filter))
            {
                var currentPath = map.Keys.Count > 0 ? map[currentCommit] : path;
                var currentTreeEntry = currentCommit.Tree[currentPath];

                if (currentTreeEntry == null)
                {
                    yield break;
                }

                var parentCount = currentCommit.Parents.Count();
                if (parentCount == 0)
                {
                    yield return new LogEntry { Path = currentPath, Commit = currentCommit };
                }
                else
                {
                    DetermineParentPaths(repo, currentCommit, currentPath, map);

                    if (parentCount != 1)
                    {
                        continue;
                    }

                    var parentCommit = currentCommit.Parents.Single();
                    var parentPath = map[parentCommit];
                    var parentTreeEntry = parentCommit.Tree[parentPath];

                    if (parentTreeEntry == null ||
                        parentTreeEntry.Target.Id != currentTreeEntry.Target.Id ||
                        parentPath != currentPath)
                    {
                        yield return new LogEntry { Path = currentPath, Commit = currentCommit };
                    }
                }
            }
        }

        private static void DetermineParentPaths(IRepository repo, Commit currentCommit, string currentPath, IDictionary<Commit, string> map)
        {
            foreach (var parentCommit in currentCommit.Parents.Where(parentCommit => !map.ContainsKey(parentCommit)))
            {
                map.Add(parentCommit, ParentPath(repo, currentCommit, currentPath, parentCommit));
            }
        }

        private static string ParentPath(IRepository repo, Commit currentCommit, string currentPath, Commit parentCommit)
        {
            using (var treeChanges = repo.Diff.Compare<TreeChanges>(parentCommit.Tree, currentCommit.Tree))
            {
                var treeEntryChanges = treeChanges.FirstOrDefault(c => c.Path == currentPath);
                return treeEntryChanges != null && treeEntryChanges.Status == ChangeKind.Renamed
                    ? treeEntryChanges.OldPath
                    : currentPath;
            }
        }
    }

    internal class FilePath : IEquatable<FilePath>
    {
        internal static FilePath Empty = new FilePath(string.Empty);

        private const char posixDirectorySeparatorChar = '/';

        private readonly string native;
        private readonly string posix;

        private FilePath(string path)
        {
            native = Replace(path, posixDirectorySeparatorChar, Path.DirectorySeparatorChar);
            posix = Replace(path, Path.DirectorySeparatorChar, posixDirectorySeparatorChar);
        }

        public string Native
        {
            get { return native; }
        }

        public string Posix
        {
            get { return posix; }
        }

        public override string ToString()
        {
            return Native;
        }

        public static implicit operator FilePath(string path)
        {
            switch (path)
            {
                case null:
                    return null;

                case "":
                    return Empty;

                default:
                    return new FilePath(path);
            }
        }

        private static string Replace(string path, char oldChar, char newChar)
        {
            if (oldChar == newChar)
            {
                return path;
            }

            return path == null ? null : path.Replace(oldChar, newChar);
        }

        public bool Equals(FilePath other)
        {
            return other == null
                ? posix == null
                : string.Equals(posix, other.posix, StringComparison.Ordinal);
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as FilePath);
        }

        public override int GetHashCode()
        {
            return posix == null ? 0 : posix.GetHashCode();
        }
    }

    internal static class FilePathExtensions
    {
        internal static FilePath Combine(this FilePath filePath, string childPath)
        {
            return filePath.IsNullOrEmpty() ? childPath : filePath.Posix + "/" + childPath;
        }

        internal static bool IsNullOrEmpty(this FilePath filePath)
        {
            return ReferenceEquals(filePath, null) || filePath.Posix.Length == 0;
        }
    }

    /// <summary>
    /// This marshaler is to be used for capturing a UTF-8 string owned by libgit2 and
    /// converting it to a managed FilePath instance. The marshaler will not attempt to
    /// free the native pointer after conversion, because the memory is owned by libgit2.
    ///
    /// Use this marshaler for return values, for example:
    /// [return: MarshalAs(UnmanagedType.CustomMarshaler,
    ///                    MarshalCookie = "git2",
    ///                    MarshalTypeRef = typeof(LaxFilePathNoCleanupMarshaler))]
    /// </summary>
    internal class LaxFilePathNoCleanupMarshaler : LaxFilePathMarshaler
    {
        private static readonly LaxFilePathNoCleanupMarshaler staticInstance = new LaxFilePathNoCleanupMarshaler();

        public new static ICustomMarshaler GetInstance(string cookie)
        {
            return staticInstance;
        }

        #region ICustomMarshaler

        public override void CleanUpNativeData(IntPtr pNativeData)
        {
        }

        #endregion
    }

    /// <summary>
    /// This marshaler is to be used for sending managed FilePath instances to libgit2.
    /// The marshaler will allocate a buffer in native memory to hold the UTF-8 string
    /// and perform the encoding conversion using that buffer as the target. The pointer
    /// received by libgit2 will be to this buffer. After the function call completes, the
    /// native buffer is freed.
    ///
    /// Use this marshaler for function parameters, for example:
    /// [DllImport(libgit2)]
    /// internal static extern int git_index_open(out IndexSafeHandle index,
    ///     [MarshalAs(UnmanagedType.CustomMarshaler,
    ///                MarshalCookie = "git2",
    ///                MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath indexpath);
    /// </summary>
    internal class StrictFilePathMarshaler : StrictUtf8Marshaler
    {
        private static readonly StrictFilePathMarshaler staticInstance = new StrictFilePathMarshaler();

        public new static ICustomMarshaler GetInstance(string cookie)
        {
            return staticInstance;
        }

        #region ICustomMarshaler

        public override IntPtr MarshalManagedToNative(Object managedObj)
        {
            if (null == managedObj)
            {
                return IntPtr.Zero;
            }

            var filePath = managedObj as FilePath;

            if (null == filePath)
            {
                throw new MarshalDirectiveException(string.Format(CultureInfo.InvariantCulture,
                                                    "{0} must be used on a FilePath.",
                                                    this.GetType().Name));
            }

            return FromManaged(filePath);
        }

        #endregion

        public static IntPtr FromManaged(FilePath filePath)
        {
            if (filePath == null)
            {
                return IntPtr.Zero;
            }

            return StrictUtf8Marshaler.FromManaged(filePath.Posix);
        }
    }

    /// <summary>
    /// This marshaler is to be used for capturing a UTF-8 string allocated by libgit2 and
    /// converting it to a managed FilePath instance. The marshaler will free the native pointer
    /// after conversion.
    /// </summary>
    internal class LaxFilePathMarshaler : LaxUtf8Marshaler
    {
        private static readonly LaxFilePathMarshaler staticInstance = new LaxFilePathMarshaler();

        public new static ICustomMarshaler GetInstance(string cookie)
        {
            return staticInstance;
        }

        #region ICustomMarshaler

        public override Object MarshalNativeToManaged(IntPtr pNativeData)
        {
            return FromNative(pNativeData);
        }

        #endregion

        public new static FilePath FromNative(IntPtr pNativeData)
        {
            return LaxUtf8Marshaler.FromNative(pNativeData);
        }

        public new static unsafe FilePath FromNative(char* buffer)
        {
            return LaxUtf8Marshaler.FromNative(buffer);
        }

        public new static FilePath FromBuffer(byte[] buffer)
        {
            return LaxUtf8Marshaler.FromBuffer(buffer);
        }
    }

    [Flags]
    internal enum GitBlameOptionFlags
    {
        /// <summary>
        /// Normal blame, the default
        /// </summary>
        GIT_BLAME_NORMAL = 0,

        /// <summary>
        /// Track lines that have moved within a file (like `git blame -M`).
        /// </summary>
        GIT_BLAME_TRACK_COPIES_SAME_FILE = (1 << 0),

        /** Track lines that have moved across files in the same commit (like `git blame -C`).
         * NOT IMPLEMENTED. */
        GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES = (1 << 1),

        /// <summary>
        /// Track lines that have been copied from another file that exists in the
        /// same commit (like `git blame -CC`). Implies SAME_FILE.
        /// </summary>
        GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES = (1 << 2),

        /// <summary>
        /// Track lines that have been copied from another file that exists in *any*
        /// commit (like `git blame -CCC`). Implies SAME_COMMIT_COPIES.
        /// </summary>
        GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES = (1 << 3),

        /// <summary>
        /// Restrict the search of commits to those reachable
        /// following only the first parents.
        /// </summary>
        GIT_BLAME_FIRST_PARENT = (1 << 4),
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class git_blame_options
    {
        public uint version = 1;
        public GitBlameOptionFlags flags;

        public UInt16 min_match_characters;
        public git_oid newest_commit;
        public git_oid oldest_commit;
        public UIntPtr min_line;
        public UIntPtr max_line;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_blame_hunk
    {
        public UIntPtr lines_in_hunk;

        public git_oid final_commit_id;
        public UIntPtr final_start_line_number;
        public git_signature* final_signature;

        public git_oid orig_commit_id;
        public char* orig_path;
        public UIntPtr orig_start_line_number;
        public git_signature* orig_signature;

        public byte boundary;
    }

    internal static class BlameStrategyExtensions
    {
        public static GitBlameOptionFlags ToGitBlameOptionFlags(this BlameStrategy strategy)
        {
            switch (strategy)
            {
                case BlameStrategy.Default:
                    return GitBlameOptionFlags.GIT_BLAME_NORMAL;

                default:
                    throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture,
                                                                  "{0} is not supported at this time",
                                                                  strategy));
            }
        }
    }

    [Flags]
    internal enum GitBranchType
    {
        GIT_BRANCH_LOCAL = 1,
        GIT_BRANCH_REMOTE = 2,
        GIT_BRANCH_ALL = GIT_BRANCH_LOCAL | GIT_BRANCH_REMOTE,
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct git_certificate
    {
        public GitCertificateType type;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_certificate_ssh
    {
        public GitCertificateType cert_type;
        public GitCertificateSshType type;

        /// <summary>
        /// The MD5 hash (if appropriate)
        /// </summary>
        public unsafe fixed byte HashMD5[16];

        /// <summary>
        /// The SHA1 hash (if appropriate)
        /// </summary>
        public unsafe fixed byte HashSHA1[20];
    }

    [Flags]
    internal enum GitCertificateSshType
    {
        MD5  = (1 << 0),
        SHA1 = (1 << 1),
    }

    /// <summary>
    /// Git certificate types to present to the user
    /// </summary>
    internal enum GitCertificateType
    {
        /// <summary>
        /// No information about the certificate is available.
        /// </summary>
        None = 0,

        /// <summary>
        /// The certificate is a x509 certificate
        /// </summary>
        X509 = 1,

        /// <summary>
        /// The "certificate" is in fact a hostkey identification for ssh.
        /// </summary>
        Hostkey = 2,

        /// <summary>
        /// The "certificate" is in fact a collection of `name:content` strings
        /// containing information about the certificate.
        /// </summary>
        StrArray = 3,
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_certificate_x509
    {
        /// <summary>
        /// Type of the certificate, in this case, GitCertificateType.X509
        /// </summary>
        public GitCertificateType cert_type;
        /// <summary>
        /// Pointer to the X509 certificate data
        /// </summary>
        public byte* data;
        /// <summary>
        ///  The size of the certificate data
        /// </summary>
        public UIntPtr len;
    }

    [Flags]
    internal enum CheckoutStrategy
    {
        /// <summary>
        /// Default is a dry run, no actual updates.
        /// </summary>
        GIT_CHECKOUT_NONE = 0,

        /// <summary>
        /// Allow safe updates that cannot overwrite uncommited data.
        /// </summary>
        GIT_CHECKOUT_SAFE = (1 << 0),

        /// <summary>
        /// Allow update of entries in working dir that are modified from HEAD.
        /// </summary>
        GIT_CHECKOUT_FORCE = (1 << 1),

        /// <summary>
        /// Allow checkout to recreate missing files.
        /// </summary>
        GIT_CHECKOUT_RECREATE_MISSING = (1 << 2),

        /// <summary>
        /// Allow checkout to make safe updates even if conflicts are found
        /// </summary>
        GIT_CHECKOUT_ALLOW_CONFLICTS = (1 << 4),

        /// <summary>
        /// Remove untracked files not in index (that are not ignored)
        /// </summary>
        GIT_CHECKOUT_REMOVE_UNTRACKED = (1 << 5),

        /// <summary>
        /// Remove ignored files not in index
        /// </summary>
        GIT_CHECKOUT_REMOVE_IGNORED = (1 << 6),

        /// <summary>
        /// Only update existing files, don't create new ones
        /// </summary>
        GIT_CHECKOUT_UPDATE_ONLY = (1 << 7),

        /// <summary>
        /// Normally checkout updates index entries as it goes; this stops that
        /// Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.
        /// </summary>
        GIT_CHECKOUT_DONT_UPDATE_INDEX = (1 << 8),

        /// <summary>
        /// Don't refresh index/config/etc before doing checkout
        /// </summary>
        GIT_CHECKOUT_NO_REFRESH = (1 << 9),

        ///Allow checkout to skip unmerged files
        GIT_CHECKOUT_SKIP_UNMERGED = (1 << 10),

        /// <summary>
        /// For unmerged files, checkout stage 2 from index
        /// </summary>
        GIT_CHECKOUT_USE_OURS = (1 << 11),

        /// <summary>
        /// For unmerged files, checkout stage 3 from index
        /// </summary>
        GIT_CHECKOUT_USE_THEIRS = (1 << 12),

        /// <summary>
        /// Treat pathspec as simple list of exact match file paths
        /// </summary>
        GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = (1 << 13),

        /// <summary>
        /// Ignore directories in use, they will be left empty
        /// </summary>
        GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = (1 << 18),

        /// <summary>
        /// Don't overwrite ignored files that exist in the checkout target
        /// </summary>
        GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = (1 << 19),

        /// <summary>
        /// Write normal merge files for conflicts
        /// </summary>
        GIT_CHECKOUT_CONFLICT_STYLE_MERGE = (1 << 20),

        /// <summary>
        /// Include common ancestor data in diff3 format files for conflicts
        /// </summary>
        GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = (1 << 21),

        /// <summary>
        /// Don't overwrite existing files or folders
        /// </summary>
        GIT_CHECKOUT_DONT_REMOVE_EXISTING = (1 << 22),

        /// <summary>
        /// Normally checkout writes the index upon completion; this prevents that.
        /// </summary>
        GIT_CHECKOUT_DONT_WRITE_INDEX = (1 << 23),

        // THE FOLLOWING OPTIONS ARE NOT YET IMPLEMENTED

        /// <summary>
        /// Recursively checkout submodules with same options (NOT IMPLEMENTED)
        /// </summary>
        GIT_CHECKOUT_UPDATE_SUBMODULES = (1 << 16),

        /// <summary>
        /// Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED)
        /// </summary>
        GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = (1 << 17),
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate int checkout_notify_cb(
        CheckoutNotifyFlags why,
        IntPtr path,
        IntPtr baseline,
        IntPtr target,
        IntPtr workdir,
        IntPtr payload);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate void progress_cb(
            IntPtr strPtr,
            UIntPtr completed_steps,
            UIntPtr total_steps,
            IntPtr payload);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate int perfdata_cb(
            IntPtr perfdata,
            IntPtr payload);

    [StructLayout(LayoutKind.Sequential)]
    internal struct GitCheckoutOpts
    {
        public uint version;

        public CheckoutStrategy checkout_strategy;

        public int DisableFilters;
        public uint DirMode;
        public uint FileMode;
        public int FileOpenFlags;

        public CheckoutNotifyFlags notify_flags;
        public checkout_notify_cb notify_cb;
        public IntPtr notify_payload;

        public progress_cb progress_cb;
        public IntPtr progress_payload;

        public GitStrArray paths;

        public IntPtr baseline;
        public IntPtr baseline_index;
        public IntPtr target_directory;

        public IntPtr ancestor_label;
        public IntPtr our_label;
        public IntPtr their_label;

        public perfdata_cb perfdata_cb;
        public IntPtr perfdata_payload;
    }

    /// <summary>
    /// An inteface for objects that specify parameters from which a
    /// GitCheckoutOpts struct can be populated.
    /// </summary>
    internal interface IConvertableToGitCheckoutOpts
    {
        CheckoutCallbacks GenerateCallbacks();

        CheckoutStrategy CheckoutStrategy { get; }

        CheckoutNotifyFlags CheckoutNotifyFlags { get; }
    }

    /// <summary>
    /// This wraps an IConvertableToGitCheckoutOpts object and can tweak the
    /// properties so that they are appropriate for a checkout performed as
    /// part of a FastForward merge. Most properties are passthrough to the
    /// wrapped object.
    /// </summary>
    internal class FastForwardCheckoutOptionsAdapter : IConvertableToGitCheckoutOpts
    {
        private IConvertableToGitCheckoutOpts internalOptions;

        internal FastForwardCheckoutOptionsAdapter(IConvertableToGitCheckoutOpts internalOptions)
        {
            this.internalOptions = internalOptions;
        }

        /// <summary>
        /// Passthrough to the wrapped object.
        /// </summary>
        /// <returns></returns>
        public CheckoutCallbacks GenerateCallbacks()
        {
            return internalOptions.GenerateCallbacks();
        }

        /// <summary>
        /// There should be no resolvable conflicts in a FastForward merge.
        /// Just perform checkout with the safe checkout strategy.
        /// </summary>
        public CheckoutStrategy CheckoutStrategy
        {
            get
            {
                return CheckoutStrategy.GIT_CHECKOUT_SAFE;
            }
        }

        /// <summary>
        /// Passthrough to the wrapped object.
        /// </summary>
        /// <returns></returns>
        public CheckoutNotifyFlags CheckoutNotifyFlags
        {
            get { return internalOptions.CheckoutNotifyFlags; }
        }
    }

    /// <summary>
    /// A wrapper around the native GitCheckoutOpts structure. This class is responsible
    /// for the managed objects that the native code points to.
    /// </summary>
    internal class GitCheckoutOptsWrapper : IDisposable
    {
        /// <summary>
        /// Create wrapper around <see cref="GitCheckoutOpts"/> from <see cref="CheckoutOptions"/>.
        /// </summary>
        /// <param name="options">Options to create native GitCheckoutOpts structure from.</param>
        /// <param name="paths">Paths to checkout.</param>
        public GitCheckoutOptsWrapper(IConvertableToGitCheckoutOpts options, FilePath[] paths = null)
        {
            Callbacks = options.GenerateCallbacks();

            if (paths != null)
            {
                PathArray = GitStrArrayManaged.BuildFrom(paths);
            }

            Options = new GitCheckoutOpts
            {
                version = 1,
                checkout_strategy = options.CheckoutStrategy,
                progress_cb = Callbacks.CheckoutProgressCallback,
                notify_cb = Callbacks.CheckoutNotifyCallback,
                notify_flags = options.CheckoutNotifyFlags,
                paths = PathArray.Array,
            };
        }

        /// <summary>
        /// Native struct to pass to libgit.
        /// </summary>
        public GitCheckoutOpts Options { get; set; }

        /// <summary>
        /// The managed class mapping native callbacks into the
        /// corresponding managed delegate.
        /// </summary>
        public CheckoutCallbacks Callbacks { get; private set; }

        /// <summary>
        /// Keep the paths around so we can dispose them.
        /// </summary>
        private GitStrArrayManaged PathArray;

        public void Dispose()
        {
            PathArray.Dispose();
        }

        /// <summary>
        /// Method to translate from <see cref="CheckoutFileConflictStrategy"/> to <see cref="CheckoutStrategy"/> flags.
        /// </summary>
        internal static CheckoutStrategy CheckoutStrategyFromFileConflictStrategy(CheckoutFileConflictStrategy fileConflictStrategy)
        {
            CheckoutStrategy flags = default(CheckoutStrategy);

            switch (fileConflictStrategy)
            {
                case CheckoutFileConflictStrategy.Ours:
                    flags = CheckoutStrategy.GIT_CHECKOUT_USE_OURS;
                    break;

                case CheckoutFileConflictStrategy.Theirs:
                    flags = CheckoutStrategy.GIT_CHECKOUT_USE_THEIRS;
                    break;

                case CheckoutFileConflictStrategy.Merge:
                    flags = CheckoutStrategy.GIT_CHECKOUT_CONFLICT_STYLE_MERGE;
                    break;

                case CheckoutFileConflictStrategy.Diff3:
                    flags = CheckoutStrategy.GIT_CHECKOUT_CONFLICT_STYLE_DIFF3;
                    break;
            }

            return flags;
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitCherryPickOptions
    {
        public uint Version = 1;

        // For merge commits, the "mainline" is treated as the parent
        public uint Mainline = 0;

        public GitMergeOpts MergeOpts = new GitMergeOpts { Version = 1 };

        public GitCheckoutOpts CheckoutOpts = new GitCheckoutOpts { version = 1 };
    }

    internal enum GitCloneLocal
    {
        CloneLocalAuto,
        CloneLocal,
        CloneNoLocal,
        CloneLocalNoLinks
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct GitCloneOptions
    {
        public uint Version;

        public GitCheckoutOpts CheckoutOpts;
        public GitFetchOptions FetchOpts;

        public int Bare;
        public GitCloneLocal Local;
        public IntPtr CheckoutBranch;

        public IntPtr RepositoryCb;
        public IntPtr RepositoryCbPayload;

        public IntPtr RemoteCb;
        public IntPtr RemoteCbPayload;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct GitConfigEntry
    {
        public char* namePtr;
        public char* valuePtr;
        public char* backend_type;
        public char* origin_path;
        public uint include_depth;
        public uint level;
        public void* freePtr;
        public void* payloadPtr;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct GitCredential
    {
        public GitCredentialType credtype;
        public IntPtr free;
    }

    /// <summary>
    /// Authentication type requested.
    /// </summary>
    [Flags]
    internal enum GitCredentialType
    {
        /// <summary>
        /// A plaintext username and password.
        /// </summary>
        UserPassPlaintext = (1 << 0),

        /// <summary>
        /// A ssh key from disk.
        /// </summary>
        SshKey = (1 << 1),

        /// <summary>
        /// A key with a custom signature function.
        /// </summary>
        SshCustom = (1 << 2),

        /// <summary>
        /// A key for NTLM/Kerberos "default" credentials.
        /// </summary>
        Default = (1 << 3),

        /// <summary>
        /// TODO
        /// </summary>
        SshInteractive = (1 << 4),

        /// <summary>
        /// Username-only information
        ///
        /// If the SSH transport does not know which username to use,
        /// it will ask via this credential type.
        /// </summary>
        Username = (1 << 5),

        /// <summary>
        /// Credentials read from memory.
        ///
        /// Only available for libssh2+OpenSSL for now.
        /// </summary>
        SshMemory = (1 << 6),
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct GitCredentialUserpass
    {
        public GitCredential parent;
        public char* username;
        public char* password;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct GitDescribeFormatOptions
    {
        public uint Version;
        public uint MinAbbreviatedSize;
        public bool AlwaysUseLongFormat;
        public IntPtr DirtySuffix;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct GitDescribeOptions
    {
        public uint Version;
        public uint MaxCandidatesTags;
        public DescribeStrategy DescribeStrategy;
        public IntPtr Pattern;
        public bool OnlyFollowFirstParent;
        public bool ShowCommitOidAsFallback;
    }

    [Flags]
    internal enum GitDiffOptionFlags
    {
        /// <summary>
        /// Normal diff, the default
        /// </summary>
        GIT_DIFF_NORMAL = 0,

        /*
         * Options controlling which files will be in the diff
         */

        /// <summary>
        /// Reverse the sides of the diff
        /// </summary>
        GIT_DIFF_REVERSE = (1 << 0),

        /// <summary>
        /// Include ignored files in the diff
        /// </summary>
        GIT_DIFF_INCLUDE_IGNORED = (1 << 1),

        /// <summary>
        /// Even with GIT_DIFF_INCLUDE_IGNORED, an entire ignored directory
        /// will be marked with only a single entry in the diff; this flag
        /// adds all files under the directory as IGNORED entries, too.
        /// </summary>
        GIT_DIFF_RECURSE_IGNORED_DIRS = (1 << 2),

        /// <summary>
        /// Include untracked files in the diff
        /// </summary>
        GIT_DIFF_INCLUDE_UNTRACKED = (1 << 3),

        /// <summary>
        /// Even with GIT_DIFF_INCLUDE_UNTRACKED, an entire untracked
        /// directory will be marked with only a single entry in the diff
        /// (a la what core Git does in `git status`); this flag adds *all*
        /// files under untracked directories as UNTRACKED entries, too.
        /// </summary>
        GIT_DIFF_RECURSE_UNTRACKED_DIRS = (1 << 4),

        /// <summary>
        /// Include unmodified files in the diff
        /// </summary>
        GIT_DIFF_INCLUDE_UNMODIFIED = (1 << 5),

        /// <summary>
        /// Normally, a type change between files will be converted into a
        /// DELETED record for the old and an ADDED record for the new; this
        /// options enabled the generation of TYPECHANGE delta records.
        /// </summary>
        GIT_DIFF_INCLUDE_TYPECHANGE = (1 << 6),

        /// <summary>
        /// Even with GIT_DIFF_INCLUDE_TYPECHANGE, blob->tree changes still
        /// generally show as a DELETED blob.  This flag tries to correctly
        /// label blob->tree transitions as TYPECHANGE records with new_file's
        /// mode set to tree.  Note: the tree SHA will not be available.
        /// </summary>
        GIT_DIFF_INCLUDE_TYPECHANGE_TREES = (1 << 7),

        /// <summary>
        /// Ignore file mode changes
        /// </summary>
        GIT_DIFF_IGNORE_FILEMODE = (1 << 8),

        /// <summary>
        /// Treat all submodules as unmodified
        /// </summary>
        GIT_DIFF_IGNORE_SUBMODULES = (1 << 9),

        /// <summary>
        /// Use case insensitive filename comparisons
        /// </summary>
        GIT_DIFF_IGNORE_CASE = (1 << 10),

        /// <summary>
        /// May be combined with `GIT_DIFF_IGNORE_CASE` to specify that a file
        /// that has changed case will be returned as an add/delete pair.
        /// </summary>
        GIT_DIFF_INCLUDE_CASECHANGE = (1 << 11),

        /// <summary>
        /// If the pathspec is set in the diff options, this flags means to
        /// apply it as an exact match instead of as an fnmatch pattern.
        /// </summary>
        GIT_DIFF_DISABLE_PATHSPEC_MATCH = (1 << 12),

        /// <summary>
        /// Disable updating of the `binary` flag in delta records.  This is
        /// useful when iterating over a diff if you don't need hunk and data
        /// callbacks and want to avoid having to load file completely.
        /// </summary>
        GIT_DIFF_SKIP_BINARY_CHECK = (1 << 13),

        /// <summary>
        /// When diff finds an untracked directory, to match the behavior of
        /// core Git, it scans the contents for IGNORED and UNTRACKED files.
        /// If *all* contents are IGNORED, then the directory is IGNORED; if
        /// any contents are not IGNORED, then the directory is UNTRACKED.
        /// This is extra work that may not matter in many cases.  This flag
        /// turns off that scan and immediately labels an untracked directory
        /// as UNTRACKED (changing the behavior to not match core Git).
        /// </summary>
        GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS = (1 << 14),

        /// <summary>
        /// When diff finds a file in the working directory with stat
        /// information different from the index, but the OID ends up being the
        /// same, write the correct stat information into the index.  Note:
        /// without this flag, diff will always leave the index untouched.
        /// </summary>
        GIT_DIFF_UPDATE_INDEX = (1 << 15),

        /// <summary>
        /// Include unreadable files in the diff
        /// </summary>
        GIT_DIFF_INCLUDE_UNREADABLE = (1 << 16),

        /// <summary>
        /// Include unreadable files in the diff
        /// </summary>
        GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED = (1 << 17),

        /*
         * Options controlling how output will be generated
         */

        /// <summary>
        /// Use a heuristic that takes indentation and whitespace into account
        /// which generally can produce better diffs when dealing with ambiguous
        /// diff hunks.
        /// </summary>
        GIT_DIFF_INDENT_HEURISTIC = (1 << 18),

        /// <summary>
        /// Treat all files as text, disabling binary attributes and detection
        /// </summary>
        GIT_DIFF_FORCE_TEXT = (1 << 20),

        /// <summary>
        /// Treat all files as binary, disabling text diffs
        /// </summary>
        GIT_DIFF_FORCE_BINARY = (1 << 21),

        /// <summary>
        /// Ignore all whitespace
        /// </summary>
        GIT_DIFF_IGNORE_WHITESPACE = (1 << 22),

        /// <summary>
        /// Ignore changes in amount of whitespace
        /// </summary>
        GIT_DIFF_IGNORE_WHITESPACE_CHANGE = (1 << 23),

        /// <summary>
        /// Ignore whitespace at end of line
        /// </summary>
        GIT_DIFF_IGNORE_WHITESPACE_EOL = (1 << 24),

        /// <summary>
        /// When generating patch text, include the content of untracked
        /// files.  This automatically turns on GIT_DIFF_INCLUDE_UNTRACKED but
        /// it does not turn on GIT_DIFF_RECURSE_UNTRACKED_DIRS.  Add that
        /// flag if you want the content of every single UNTRACKED file.
        /// </summary>
        GIT_DIFF_SHOW_UNTRACKED_CONTENT = (1 << 25),

        /// <summary>
        /// When generating output, include the names of unmodified files if
        /// they are included in the git_diff.  Normally these are skipped in
        /// the formats that list files (e.g. name-only, name-status, raw).
        /// Even with this, these will not be included in patch format.
        /// </summary>
        GIT_DIFF_SHOW_UNMODIFIED = (1 << 26),

        /// <summary>
        /// Use the "patience diff" algorithm
        /// </summary>
        GIT_DIFF_PATIENCE = (1 << 28),

        /// <summary>
        /// Take extra time to find minimal diff
        /// </summary>
        GIT_DIFF_MINIMAL = (1 << 29),

        /// <summary>
        /// Include the necessary deflate / delta information so that `git-apply`
        /// can apply given diff information to binary files.
        /// </summary>
        GIT_DIFF_SHOW_BINARY = (1 << 30),
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate int diff_notify_cb(
        IntPtr diff_so_far,
        IntPtr delta_to_add,
        IntPtr matched_pathspec,
        IntPtr payload);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate int diff_progress_cb(
        IntPtr diff_so_far,
        IntPtr old_path,
        IntPtr new_path,
        IntPtr payload);

    [StructLayout(LayoutKind.Sequential)]
    internal class GitDiffOptions : IDisposable
    {
        public uint Version = 1;
        public GitDiffOptionFlags Flags;

        /* options controlling which files are in the diff */

        public SubmoduleIgnore IgnoreSubmodules;
        public GitStrArrayManaged PathSpec;
        public diff_notify_cb NotifyCallback;
        public diff_progress_cb ProgressCallback;
        public IntPtr Payload;

        /* options controlling how to diff text is generated */

        public uint ContextLines;
        public uint InterhunkLines;
        public ushort IdAbbrev;
        public Int64 MaxSize;
        public IntPtr OldPrefixString;
        public IntPtr NewPrefixString;

        public void Dispose()
        {
            PathSpec.Dispose();
        }
    }

    [Flags]
    internal enum GitDiffFlags
    {
        GIT_DIFF_FLAG_BINARY = (1 << 0),
        GIT_DIFF_FLAG_NOT_BINARY = (1 << 1),
        GIT_DIFF_FLAG_VALID_ID = (1 << 2),
        GIT_DIFF_FLAG_EXISTS = (1 << 3),
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_diff_file
    {
        public git_oid Id;
        public char* Path;
        public Int64 Size;
        public GitDiffFlags Flags;
        public UInt16 Mode;
        public UInt16 IdAbbrev;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_diff_delta
    {
        public ChangeKind status;
        public GitDiffFlags flags;
        public UInt16 similarity;
        public UInt16 nfiles;
        public git_diff_file old_file;
        public git_diff_file new_file;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitDiffHunk
    {
        public int OldStart;
        public int OldLines;
        public int NewStart;
        public int NewLines;
        public UIntPtr HeaderLen;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
        public byte[] Header;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitDiffLine
    {
        public GitDiffLineOrigin lineOrigin;
        public int OldLineNo;
        public int NewLineNo;
        public int NumLines;
        public UIntPtr contentLen;
        public Int64 contentOffset;
        public IntPtr content;
    }

    enum GitDiffLineOrigin : byte
    {
        GIT_DIFF_LINE_CONTEXT = 0x20, //' ',
        GIT_DIFF_LINE_ADDITION = 0x2B, //'+',
        GIT_DIFF_LINE_DELETION = 0x2D, //'-',
        GIT_DIFF_LINE_ADD_EOFNL = 0x0A, //'\n', /**< LF was added at end of file */
        GIT_DIFF_LINE_DEL_EOFNL = 0x0, //'\0', /**< LF was removed at end of file */

        /* these values will only be sent to a `git_diff_output_fn` */
        GIT_DIFF_LINE_FILE_HDR = 0x46, //'F',
        GIT_DIFF_LINE_HUNK_HDR = 0x48, //'H',
        GIT_DIFF_LINE_BINARY = 0x42, //'B',
    }

    enum GitDiffFormat
    {
        GIT_DIFF_FORMAT_PATCH = 1, // < full git diff
        GIT_DIFF_FORMAT_PATCH_HEADER = 2, // < just the file headers of patch
        GIT_DIFF_FORMAT_RAW = 3, // < like git diff --raw
        GIT_DIFF_FORMAT_NAME_ONLY = 4, // < like git diff --name-only
        GIT_DIFF_FORMAT_NAME_STATUS = 5, // < like git diff --name-status
    }

    [Flags]
    enum GitDiffFindFlags
    {
        // Obey `diff.renames`. Overridden by any other GIT_DIFF_FIND_... flag.
        GIT_DIFF_FIND_BY_CONFIG = 0,

        // Look for renames? (`--find-renames`)
        GIT_DIFF_FIND_RENAMES = (1 << 0),
        // consider old side of modified for renames? (`--break-rewrites=N`)
        GIT_DIFF_FIND_RENAMES_FROM_REWRITES = (1 << 1),

        // look for copies? (a la `--find-copies`)
        GIT_DIFF_FIND_COPIES = (1 << 2),
        // consider unmodified as copy sources? (`--find-copies-harder`)
        GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED = (1 << 3),

        // mark large rewrites for split (`--break-rewrites=/M`)
        GIT_DIFF_FIND_REWRITES = (1 << 4),
        // actually split large rewrites into delete/add pairs
        GIT_DIFF_BREAK_REWRITES = (1 << 5),
        // mark rewrites for split and break into delete/add pairs
        GIT_DIFF_FIND_AND_BREAK_REWRITES =
            (GIT_DIFF_FIND_REWRITES | GIT_DIFF_BREAK_REWRITES),

        // find renames/copies for untracked items in working directory
        GIT_DIFF_FIND_FOR_UNTRACKED = (1 << 6),

        // turn on all finding features
        GIT_DIFF_FIND_ALL = (0x0ff),

        // measure similarity ignoring leading whitespace (default)
        GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE = 0,
        // measure similarity ignoring all whitespace
        GIT_DIFF_FIND_IGNORE_WHITESPACE = (1 << 12),
        // measure similarity including all data
        GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE = (1 << 13),
        // measure similarity only by comparing SHAs (fast and cheap)
        GIT_DIFF_FIND_EXACT_MATCH_ONLY = (1 << 14),

        // do not break rewrites unless they contribute to a rename
        GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY = (1 << 15),

        // Remove any UNMODIFIED deltas after find_similar is done.
        GIT_DIFF_FIND_REMOVE_UNMODIFIED = (1 << 16),
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitDiffFindOptions
    {
        public uint Version = 1;
        public GitDiffFindFlags Flags;
        public UInt16 RenameThreshold;
        public UInt16 RenameFromRewriteThreshold;
        public UInt16 CopyThreshold;
        public UInt16 BreakRewriteThreshold;
        public UIntPtr RenameLimit;

        // TODO
        public IntPtr SimilarityMetric;
    }

    [Flags]
    enum GitDiffBinaryType
    {
        // There is no binary delta.
        GIT_DIFF_BINARY_NONE = 0,

        // The binary data is the literal contents of the file. */
        GIT_DIFF_BINARY_LITERAL,

        // The binary data is the delta from one side to the other. */
        GIT_DIFF_BINARY_DELTA,
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitDiffBinaryFile
    {
        public GitDiffBinaryType Type;
        public IntPtr Data;
        public UIntPtr DataLen;
        public UIntPtr InflatedLen;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitDiffBinary
    {
        public uint ContainsData;
        public GitDiffBinaryFile OldFile;
        public GitDiffBinaryFile NewFile;
    }

    internal enum GitDirection
    {
        Fetch = 0,
        Push = 1
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct GitError
    {
        public char* Message;
        public GitErrorCategory Category;
    }

    internal enum GitErrorCategory
    {
        Unknown = -1,
        None,
        NoMemory,
        Os,
        Invalid,
        Reference,
        Zlib,
        Repository,
        Config,
        Regex,
        Odb,
        Index,
        Object,
        Net,
        Tag,
        Tree,
        Indexer,
        Ssl,
        Submodule,
        Thread,
        Stash,
        Checkout,
        FetchHead,
        Merge,
        Ssh,
        Filter,
        Revert,
        Callback,
        CherryPick,
        Describe,
        Rebase,
        Filesystem,
        Patch,
        Worktree,
        Sha1
    }

    internal enum GitErrorCode
    {
        Ok = 0,
        Error = -1,

        /// <summary>
        /// Input does not exist in the scope searched.
        /// </summary>
        NotFound = -3,

        /// <summary>
        /// Input already exists in the processed scope.
        /// </summary>
        Exists = -4,

        /// <summary>
        /// The given short oid is ambiguous.
        /// </summary>
        Ambiguous = -5,

        /// <summary>
        /// Buffer related issue.
        /// </summary>
        Buffer = -6,

        /// <summary>
        /// Callback error.
        /// </summary>
        User = -7,

        /// <summary>
        /// Operation cannot be performed against a bare repository.
        /// </summary>
        BareRepo = -8,

        /// <summary>
        /// Operation cannot be performed against an orphaned HEAD.
        /// </summary>
        OrphanedHead = -9,

        /// <summary>
        /// Operation cannot be performed against a not fully merged index.
        /// </summary>
        UnmergedEntries = -10,

        /// <summary>
        /// Push cannot be performed against the remote without losing commits.
        /// </summary>
        NonFastForward = -11,

        /// <summary>
        /// Input is not a valid specification.
        /// </summary>
        InvalidSpecification = -12,

        /// <summary>
        /// A conflicting change has been detected in the index
        /// or working directory.
        /// </summary>
        Conflict = -13,

        /// <summary>
        /// A file operation failed because the file was locked.
        /// </summary>
        LockedFile = -14,

        /// <summary>
        /// Reference value does not match expected.
        /// </summary>
        Modified = -15,

        /// <summary>
        /// Authentication error.
        /// </summary>
        Auth = -16,

        /// <summary>
        /// Server certificate is invalid.
        /// </summary>
        Certificate = -17,

        /// <summary>
        /// Patch/merge has already been applied.
        /// </summary>
        Applied = -18,

        /// <summary>
        /// The requested peel operation is not possible.
        /// </summary>
        Peel = -19,

        /// <summary>
        /// Unexpected EOF.
        /// </summary>
        EndOfFile = -20,

        /// <summary>
        /// Invalid operation or input.
        /// </summary>
        Invalid = -21,

        /// <summary>
        /// Uncommitted changes in index prevented operation.
        /// </summary>
        Uncommitted = -22,

        /// <summary>
        /// The operation is not valid for a directory.
        /// </summary>
        Directory = -23,

        /// <summary>
        /// A merge conflict exists and cannot continue
        /// </summary>
        MergeConflict = -24,

        /// <summary>
        /// Skip and passthrough the given ODB backend.
        /// </summary>
        PassThrough = -30,

        /// <summary>
        /// There are no more entries left to iterate.
        /// </summary>
        IterOver = -31,

        /// <summary>
        /// Internal-only.
        /// </summary>
        Retry = -32,

        /// <summary>
        /// A retrieved object did not match its expected ID.
        /// </summary>
        Mismatch = -33,
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitFetchOptions
    {
        public int Version = 1;
        public GitRemoteCallbacks RemoteCallbacks;
        public FetchPruneStrategy Prune;
        public bool UpdateFetchHead = true;
        public TagFetchMode download_tags;
        public GitProxyOptions ProxyOptions;
        public int Depth = 0; // GIT_FETCH_DEPTH_FULL
        public RemoteRedirectMode FollowRedirects = RemoteRedirectMode.Initial;
        public GitStrArrayManaged CustomHeaders;
    }

    /// <summary>
    /// Git fetch options wrapper. Disposable wrapper for GitFetchOptions
    /// </summary>
    internal class GitFetchOptionsWrapper : IDisposable
    {
        public GitFetchOptionsWrapper() : this(new GitFetchOptions()) { }

        public GitFetchOptionsWrapper(GitFetchOptions fetchOptions)
        {
            Options = fetchOptions;
        }

        public GitFetchOptions Options { get; private set; }

        #region IDisposable
        private bool disposedValue = false; // To detect redundant calls
        protected virtual void Dispose(bool disposing)
        {
            if (disposedValue)
                return;

            Options.CustomHeaders.Dispose();
            EncodingMarshaler.Cleanup(Options.ProxyOptions.Url);
            disposedValue = true;
        }

        public void Dispose()
        {
            Dispose(true);
        }
        #endregion
    }

    /// <summary>
    /// A git filter
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal class GitFilter
    {
        public uint version = 1;

        public IntPtr attributes;

        [MarshalAs(UnmanagedType.FunctionPtr)]
        public git_filter_init_fn init;

        [MarshalAs(UnmanagedType.FunctionPtr)]
        public git_filter_shutdown_fn shutdown;

        [MarshalAs(UnmanagedType.FunctionPtr)]
        public git_filter_check_fn check;

        [MarshalAs(UnmanagedType.FunctionPtr)]
        public git_filter_apply_fn apply;

        [MarshalAs(UnmanagedType.FunctionPtr)]
        public git_filter_stream_fn stream;

        [MarshalAs(UnmanagedType.FunctionPtr)]
        public git_filter_cleanup_fn cleanup;

        /* The libgit2 structure definition ends here. Subsequent fields are for libgit2sharp bookkeeping. */

        /// <summary>
        /// Initialize callback on filter
        ///
        /// Specified as `filter.initialize`, this is an optional callback invoked
        /// before a filter is first used.  It will be called once at most.
        ///
        /// If non-NULL, the filter's `initialize` callback will be invoked right
        /// before the first use of the filter, so you can defer expensive
        /// initialization operations (in case libgit2 is being used in a way that doesn't need the filter).
        /// </summary>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_filter_init_fn(IntPtr filter);

        /// <summary>
        /// Shutdown callback on filter
        ///
        /// Specified as `filter.shutdown`, this is an optional callback invoked
        /// when the filter is unregistered or when libgit2 is shutting down.  It
        /// will be called once at most and should release resources as needed.
        /// Typically this function will free the `git_filter` object itself.
        /// </summary>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void git_filter_shutdown_fn(IntPtr filter);

        /// <summary>
        /// Callback to decide if a given source needs this filter
        /// Specified as `filter.check`, this is an optional callback that checks if filtering is needed for a given source.
        ///
        /// It should return 0 if the filter should be applied (i.e. success), GIT_PASSTHROUGH if the filter should
        /// not be applied, or an error code to fail out of the filter processing pipeline and return to the caller.
        ///
        /// The `attr_values` will be set to the values of any attributes given in the filter definition.  See `git_filter` below for more detail.
        ///
        /// The `payload` will be a pointer to a reference payload for the filter. This will start as NULL, but `check` can assign to this
        /// pointer for later use by the `apply` callback.  Note that the value should be heap allocated (not stack), so that it doesn't go
        /// away before the `apply` callback can use it.  If a filter allocates and assigns a value to the `payload`, it will need a `cleanup`
        /// callback to free the payload.
        /// </summary>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_filter_check_fn(
            GitFilter gitFilter,
            IntPtr payload,
            IntPtr filterSource,
            IntPtr attributeValues);

        /// <summary>
        /// Callback to actually perform the data filtering
        ///
        /// Specified as `filter.apply`, this is the callback that actually filters data.
        /// If it successfully writes the output, it should return 0.  Like `check`,
        /// it can return GIT_PASSTHROUGH to indicate that the filter doesn't want to run.
        /// Other error codes will stop filter processing and return to the caller.
        ///
        /// The `payload` value will refer to any payload that was set by the `check` callback.  It may be read from or written to as needed.
        /// </summary>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_filter_apply_fn(
            GitFilter gitFilter,
            IntPtr payload,
            IntPtr gitBufTo,
            IntPtr gitBufFrom,
            IntPtr filterSource);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_filter_stream_fn(
            out IntPtr git_writestream_out,
            GitFilter self,
            IntPtr payload,
            IntPtr filterSource,
            IntPtr git_writestream_next);

        /// <summary>
        /// Callback to clean up after filtering has been applied. Specified as `filter.cleanup`, this is an optional callback invoked
        /// after the filter has been applied.  If the `check` or `apply` callbacks allocated a `payload`
        /// to keep per-source filter state, use this  callback to free that payload and release resources as required.
        /// </summary>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void git_filter_cleanup_fn(IntPtr gitFilter, IntPtr payload);
    }
    /// <summary>
    /// The file source being filtered
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_filter_source
    {
        public git_repository* repository;

        public char* path;

        public git_oid oid;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_index_mtime
    {
        public int seconds;
        public uint nanoseconds;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_index_entry
    {
        internal const ushort GIT_IDXENTRY_VALID = 0x8000;

        public git_index_mtime ctime;
        public git_index_mtime mtime;
        public uint dev;
        public uint ino;
        public uint mode;
        public uint uid;
        public uint gid;
        public uint file_size;
        public git_oid id;
        public ushort flags;
        public ushort extended_flags;
        public char* path;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_index_name_entry
    {
        public char* ancestor;
        public char* ours;
        public char* theirs;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_index_reuc_entry
    {
        public uint AncestorMode;
        public uint OurMode;
        public uint TheirMode;
        public git_oid AncestorId;
        public git_oid OurId;
        public git_oid TheirId;
        public char* Path;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitIndexTime
    {
        public int seconds;
        public uint nanoseconds;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct GitMergeOpts
    {
        public uint Version;

        public GitMergeFlag MergeTreeFlags;

        /// <summary>
        /// Similarity to consider a file renamed.
        /// </summary>
        public uint RenameThreshold;

        /// <summary>
        /// Maximum similarity sources to examine (overrides
        /// 'merge.renameLimit' config (default 200)
        /// </summary>
        public uint TargetLimit;

        /// <summary>
        /// Pluggable similarityMetric; pass IntPtr.Zero
        /// to use internal metric.
        /// </summary>
        public IntPtr SimilarityMetric;

        /// <summary>
        /// Maximum number of times to merge common ancestors to build a
        /// virtual merge base when faced with criss-cross merges.  When this
        /// limit is reached, the next ancestor will simply be used instead of
        /// attempting to merge it.  The default is unlimited.
        /// </summary>
        public uint RecursionLimit;

        /// <summary>
        /// Default merge driver to be used when both sides of a merge have
        /// changed.  The default is the `text` driver.
        /// </summary>
        public string DefaultDriver;

        /// <summary>
        /// Flags for automerging content.
        /// </summary>
        public MergeFileFavor MergeFileFavorFlags;

        /// <summary>
        /// File merging flags.
        /// </summary>
        public GitMergeFileFlag FileFlags;
    }

    /// <summary>
    /// The results of `git_merge_analysis` indicate the merge opportunities.
    /// </summary>
    [Flags]
    internal enum GitMergeAnalysis
    {
        /// <summary>
        /// No merge is possible.  (Unused.)
        /// </summary>
        GIT_MERGE_ANALYSIS_NONE = 0,

        /// <summary>
        /// A "normal" merge; both HEAD and the given merge input have diverged
        /// from their common ancestor.  The divergent commits must be merged.
        /// </summary>
        GIT_MERGE_ANALYSIS_NORMAL = (1 << 0),

        /// <summary>
        /// All given merge inputs are reachable from HEAD, meaning the
        /// repository is up-to-date and no merge needs to be performed.
        /// </summary>
        GIT_MERGE_ANALYSIS_UP_TO_DATE = (1 << 1),

        /// <summary>
        /// The given merge input is a fast-forward from HEAD and no merge
        /// needs to be performed.  Instead, the client can check out the
        /// given merge input.
        /// </summary>
        GIT_MERGE_ANALYSIS_FASTFORWARD = (1 << 2),

        /// <summary>
        /// The HEAD of the current repository is "unborn" and does not point to
        /// a valid commit.  No merge can be performed, but the caller may wish
        /// to simply set HEAD to the target commit(s).
        /// </summary>
        GIT_MERGE_ANALYSIS_UNBORN = (1 << 3),
    }

    internal enum GitMergePreference
    {
        /// <summary>
        /// No configuration was found that suggests a preferred behavior for
        /// merge.
        /// </summary>
        GIT_MERGE_PREFERENCE_NONE = 0,

        /// <summary>
        /// There is a `merge.ff=false` configuration setting, suggesting that
        /// the user does not want to allow a fast-forward merge.
        /// </summary>
        GIT_MERGE_PREFERENCE_NO_FASTFORWARD = (1 << 0),

        /// <summary>
        /// There is a `merge.ff=only` configuration setting, suggesting that
        /// the user only wants fast-forward merges.
        /// </summary>
        GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY = (1 << 1),
    }

    [Flags]
    internal enum GitMergeFlag
    {
        /// <summary>
        /// No options.
        /// </summary>
        GIT_MERGE_NORMAL = 0,

        /// <summary>
        /// Detect renames that occur between the common ancestor and the "ours"
     	/// side or the common ancestor and the "theirs" side.  This will enable
 	    /// the ability to merge between a modified and renamed file.
        /// </summary>
        GIT_MERGE_FIND_RENAMES = (1 << 0),

        /// <summary>
        /// If a conflict occurs, exit immediately instead of attempting to
        /// continue resolving conflicts.  The merge operation will fail with
        /// GIT_EMERGECONFLICT and no index will be returned.
        ///</summary>
        GIT_MERGE_FAIL_ON_CONFLICT = (1 << 1),

        /// <summary>
        /// Do not write the REUC extension on the generated index
        /// </summary>
        GIT_MERGE_SKIP_REUC = (1 << 2),

        /// <summary>
        /// If the commits being merged have multiple merge bases, do not build
        /// a recursive merge base (by merging the multiple merge bases),
        /// instead simply use the first base.  This flag provides a similar
        /// merge base to `git-merge-resolve`.
        /// </summary>
        GIT_MERGE_NO_RECURSIVE = (1 << 3),
    }

    [Flags]
    internal enum GitMergeFileFlag
    {
        /// <summary>
        /// Defaults
        /// </summary>
        GIT_MERGE_FILE_DEFAULT = 0,

        /// <summary>
        /// Create standard conflicted merge files
        /// </summary>
        GIT_MERGE_FILE_STYLE_MERGE = (1 << 0),

        /// <summary>
        /// Create diff3-style files
        /// </summary>
        GIT_MERGE_FILE_STYLE_DIFF3 = (1 << 1),

        /// <summary>
        /// Condense non-alphanumeric regions for simplified diff file
        /// </summary>
        GIT_MERGE_FILE_SIMPLIFY_ALNUM = (1 << 2),

        /// <summary>
        /// Ignore all whitespace
        /// </summary>
        GIT_MERGE_FILE_IGNORE_WHITESPACE = (1 << 3),

        /// <summary>
        /// Ignore changes in amount of whitespace
        /// </summary>
        GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE = (1 << 4),

        /// <summary>
        /// Ignore whitespace at end of line
        /// </summary>
        GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL = (1 << 5),

        /// <summary>
        /// Use the "patience diff" algorithm
        /// </summary>
        GIT_MERGE_FILE_DIFF_PATIENCE = (1 << 6),

        /// <summary>
        /// Take extra time to find minimal diff
        /// </summary>
        GIT_MERGE_FILE_DIFF_MINIMAL = (1 << 7),
    }

    internal class GitObjectLazyGroup : LazyGroup<ObjectHandle>
    {
        private readonly ObjectId id;

        public GitObjectLazyGroup(Repository repo, ObjectId id)
            : base(repo)
        {
            this.id = id;
        }

        protected override void EvaluateInternal(Action<ObjectHandle> evaluator)
        {
            using (var osw = new ObjectSafeWrapper(id, repo.Handle))
            {
                evaluator(osw.ObjectPtr);
            }
        }

        public static ILazy<TResult> Singleton<TResult>(Repository repo, ObjectId id, Func<ObjectHandle, TResult> resultSelector, bool throwIfMissing = false)
        {
            return Singleton(() =>
            {
                using (var osw = new ObjectSafeWrapper(id, repo.Handle, throwIfMissing: throwIfMissing))
                {
                    return resultSelector(osw.ObjectPtr);
                }
            });
        }
    }

    /// <summary>
    /// Underlying type of a <see cref="GitObject"/>
    /// </summary>
    internal enum GitObjectType
    {
        /// <summary>
        /// Object can be of any type.
        /// </summary>
        Any = -2,

        /// <summary>
        /// Object is invalid.
        /// </summary>
        Bad = -1,

        /// <summary>
        /// Reserved for future use.
        /// </summary>
        Ext1 = 0,

        /// <summary>
        /// A commit object.
        /// </summary>
        Commit = 1,

        /// <summary>
        /// A tree (directory listing) object.
        /// </summary>
        Tree = 2,

        /// <summary>
        /// A file revision object.
        /// </summary>
        Blob = 3,

        /// <summary>
        /// An annotated tag object.
        /// </summary>
        Tag = 4,

        /// <summary>
        /// Reserved for future use.
        /// </summary>
        Ext2 = 5,

        /// <summary>
        /// A delta, base is given by an offset.
        /// </summary>
        OfsDelta = 6,

        /// <summary>
        /// A delta, base is given by object id.
        /// </summary>
        RefDelta = 7
    }

    internal static class GitObjectTypeExtensions
    {
        public static TreeEntryTargetType ToTreeEntryTargetType(this GitObjectType type)
        {
            switch (type)
            {
                case GitObjectType.Commit:
                    return TreeEntryTargetType.GitLink;

                case GitObjectType.Tree:
                    return TreeEntryTargetType.Tree;

                case GitObjectType.Blob:
                    return TreeEntryTargetType.Blob;

                default:
                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture,
                                                                      "Cannot map {0} to a TreeEntryTargetType.",
                                                                      type));
            }
        }

        public static ObjectType ToObjectType(this GitObjectType type)
        {
            switch (type)
            {
                case GitObjectType.Commit:
                    return ObjectType.Commit;

                case GitObjectType.Tree:
                    return ObjectType.Tree;

                case GitObjectType.Blob:
                    return ObjectType.Blob;

                case GitObjectType.Tag:
                    return ObjectType.Tag;

                default:
                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture,
                                                                      "Cannot map {0} to a ObjectType.",
                                                                      type));
            }
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct GitOdbBackend
    {
        static GitOdbBackend()
        {
            GCHandleOffset = Marshal.OffsetOf(typeof(GitOdbBackend), "GCHandle").ToInt32();
        }

        public uint Version;

#pragma warning disable 169

        /// <summary>
        /// This field is populated by libgit2 at backend addition time, and exists for its
        /// use only. From this side of the interop, it is unreferenced.
        /// </summary>
        private readonly IntPtr Odb;

#pragma warning restore 169

        public read_callback Read;
        public read_prefix_callback ReadPrefix;
        public read_header_callback ReadHeader;
        public write_callback Write;
        public writestream_callback WriteStream;
        public readstream_callback ReadStream;
        public exists_callback Exists;
        public exists_prefix_callback ExistsPrefix;
        public IntPtr Refresh;
        public foreach_callback Foreach;
        public IntPtr WritePack;
        public IntPtr WriteMidx;
        public IntPtr Freshen;
        public free_callback Free;

        /* The libgit2 structure definition ends here. Subsequent fields are for libgit2sharp bookkeeping. */

        public IntPtr GCHandle;

        /* The following static fields are not part of the structure definition. */

        public static int GCHandleOffset;

        /// <summary>
        /// The backend is passed an OID. From that data the backend is expected to return a pointer to the
        /// data for that object, the size of the data, and the type of the object.
        /// </summary>
        /// <param name="buffer_p">[out] If the call is successful, the backend will write the address of a buffer containing the object contents here.</param>
        /// <param name="len_p">[out] If the call is successful, the backend will write the length of the buffer containing the object contents here.</param>
        /// <param name="type_p">[out] If the call is successful, the backend will write the type of the object here.</param>
        /// <param name="backend">[in] A pointer to the backend which is being asked to perform the task.</param>
        /// <param name="oid">[in] The OID which the backend is being asked to look up.</param>
        /// <returns>0 if successful; an error code otherwise.</returns>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int read_callback(
            out IntPtr buffer_p,
            out UIntPtr len_p,
            out GitObjectType type_p,
            IntPtr backend,
            ref GitOid oid);

        /// <summary>
        /// The backend is passed a short OID and the number of characters in that short OID.
        /// From that data the backend is expected to return the full OID (in out_oid), a pointer
        /// to the data (in buffer_p), the size of the buffer returned in buffer_p (in len_p),
        /// and the object type (in type_p). The short OID might not be long enough to resolve
        /// to just one object. In that case the backend should return GIT_EAMBIGUOUS.
        /// </summary>
        /// <param name="out_oid">[out] If the call is successful, the backend will write the full OID if the object here.</param>
        /// <param name="buffer_p">[out] If the call is successful, the backend will write the address of a buffer containing the object contents here.</param>
        /// <param name="len_p">[out] If the call is successful, the backend will write the length of the buffer containing the object contents here.</param>
        /// <param name="type_p">[out] If the call is successful, the backend will write the type of the object here.</param>
        /// <param name="backend">[in] A pointer to the backend which is being asked to perform the task.</param>
        /// <param name="short_oid">[in] The short-form OID which the backend is being asked to look up.</param>
        /// <param name="len">[in] The length of the short-form OID (short_oid).</param>
        /// <returns>0 if successful; an error code otherwise.</returns>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int read_prefix_callback(
            out GitOid out_oid,
            out IntPtr buffer_p,
            out UIntPtr len_p,
            out GitObjectType type_p,
            IntPtr backend,
            ref GitOid short_oid,
            UIntPtr len);

        /// <summary>
        /// The backend is passed an OID. From that data the backend is expected to return the size of the
        /// data for that OID, and the type of that OID.
        /// </summary>
        /// <param name="len_p">[out] If the call is successful, the backend will write the length of the data for the OID here.</param>
        /// <param name="type_p">[out] If the call is successful, the backend will write the type of the object here.</param>
        /// <param name="backend">[in] A pointer to the backend which is being asked to perform the task.</param>
        /// <param name="oid">[in] The OID which the backend is being asked to look up.</param>
        /// <returns>0 if successful; an error code otherwise.</returns>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int read_header_callback(
            out UIntPtr len_p,
            out GitObjectType type_p,
            IntPtr backend,
            ref GitOid oid);

        /// <summary>
        /// The backend is passed an OID, the type of the object, and its contents. The backend is asked to write
        /// that data to the backing store.
        /// </summary>
        /// <param name="oid">[in] The OID which the backend is being asked to write.</param>
        /// <param name="backend">[in] A pointer to the backend which is being asked to perform the task.</param>
        /// <param name="data">[in] A pointer to the data for this object.</param>
        /// <param name="len">[in] The length of the buffer pointed to by data.</param>
        /// <param name="type">[in] The type of the object.</param>
        /// <returns>0 if successful; an error code otherwise.</returns>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int write_callback(
            IntPtr backend,
            ref GitOid oid,
            IntPtr data,
            UIntPtr len,
            GitObjectType type);

        /// <summary>
        /// The backend is passed an OID, the type of the object, and the length of its contents. The backend is
        /// asked to return a stream object which the caller can use to write the contents of the object to the
        /// backing store.
        /// </summary>
        /// <param name="stream_out">[out] The stream object which the caller will use to write the contents for this object.</param>
        /// <param name="backend">[in] A pointer to the backend which is being asked to perform the task.</param>
        /// <param name="length">[in] The length of the object's contents.</param>
        /// <param name="type">[in] The type of the object being written.</param>
        /// <returns>0 if successful; an error code otherwise.</returns>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int writestream_callback(
            out IntPtr stream_out,
            IntPtr backend,
            Int64 length,
            GitObjectType type);

        /// <summary>
        /// The backend is passed an OID. The backend is asked to return a stream object which the caller can use
        /// to read the contents of this object from the backing store.
        /// </summary>
        /// <param name="stream_out">[out] The stream object which the caller will use to read the contents of this object.</param>
        /// <param name="backend">[in] A pointer to the backend which is being asked to perform the task.</param>
        /// <param name="oid">[in] The object ID that the caller is requesting.</param>
        /// <returns>0 if successful; an error code otherwise.</returns>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int readstream_callback(
            out IntPtr stream_out,
            IntPtr backend,
            ref GitOid oid);

        /// <summary>
        /// The backend is passed an OID. The backend is asked to return a value that indicates whether or not
        /// the object exists in the backing store.
        /// </summary>
        /// <param name="backend">[in] A pointer to the backend which is being asked to perform the task.</param>
        /// <param name="oid">[in] The object ID that the caller is requesting.</param>
        /// <returns>True if the object exists; false otherwise</returns>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate bool exists_callback(
            IntPtr backend,
            ref GitOid oid);

        /// <summary>
        /// The backend is passed a short OID and the number of characters in that short OID.
        /// The backend is asked to return a value that indicates whether or not
        /// the object exists in the backing store. The short OID might not be long enough to resolve
        /// to just one object. In that case the backend should return GIT_EAMBIGUOUS.
        /// </summary>
        /// <param name="found_oid">[out] If the call is successful, the backend will write the full OID if the object here.</param>
        /// <param name="backend">[in] A pointer to the backend which is being asked to perform the task.</param>
        /// <param name="short_oid">[in] The short-form OID which the backend is being asked to look up.</param>
        /// <param name="len">[in] The length of the short-form OID (short_oid).</param>
        /// <returns>1 if the object exists, 0 if the object doesn't; an error code otherwise.</returns>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int exists_prefix_callback(
            ref GitOid found_oid,
            IntPtr backend,
            ref GitOid short_oid,
            UIntPtr len);

        /// <summary>
        /// The backend is passed a callback function and a void* to pass through to the callback. The backend is
        /// asked to iterate through all objects in the backing store, invoking the callback for each item.
        /// </summary>
        /// <param name="backend">[in] A pointer to the backend which is being asked to perform the task.</param>
        /// <param name="cb">[in] The callback function to invoke.</param>
        /// <param name="data">[in] An arbitrary parameter to pass through to the callback</param>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int foreach_callback(
            IntPtr backend,
            foreach_callback_callback cb,
            IntPtr data);

        /// <summary>
        /// The owner of this backend is finished with it. The backend is asked to clean up and shut down.
        /// </summary>
        /// <param name="backend">[in] A pointer to the backend which is being freed.</param>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void free_callback(
            IntPtr backend);

        /// <summary>
        /// A callback for the backend's implementation of foreach.
        /// </summary>
        /// <param name="oid">The oid of each object in the backing store.</param>
        /// <param name="data">The arbitrary parameter given to foreach_callback.</param>
        /// <returns>A non-negative result indicates the enumeration should continue. Otherwise, the enumeration should stop.</returns>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int foreach_callback_callback(
            IntPtr oid,
            IntPtr data);
    }

    [Flags]
    internal enum GitOdbBackendStreamMode
    {
        Read = 2,
        Write = 4
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitOdbBackendStream
    {
        static GitOdbBackendStream()
        {
            GCHandleOffset = Marshal.OffsetOf(typeof(GitOdbBackendStream), "GCHandle").ToInt32();
        }

        public IntPtr Backend;
        public GitOdbBackendStreamMode Mode;
        public IntPtr HashCtx;

        public Int64 DeclaredSize;
        public Int64 ReceivedBytes;

        public read_callback Read;
        public write_callback Write;
        public finalize_write_callback FinalizeWrite;
        public free_callback Free;

        /* The libgit2 structure definition ends here. Subsequent fields are for libgit2sharp bookkeeping. */

        public IntPtr GCHandle;

        /* The following static fields are not part of the structure definition. */

        public static int GCHandleOffset;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int read_callback(
            IntPtr stream,
            IntPtr buffer,
            UIntPtr len);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int write_callback(
            IntPtr stream,
            IntPtr buffer,
            UIntPtr len);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int finalize_write_callback(IntPtr stream, ref GitOid oid);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void free_callback(IntPtr stream);
    }

    internal struct git_oid
    {
        public const int Size = 20;
        public unsafe fixed byte Id[20];
    }

    /// <summary>
    /// Represents a unique id in git which is the sha1 hash of this id's content.
    /// </summary>
    internal struct GitOid
    {
        /// <summary>
        /// Number of bytes in the Id.
        /// </summary>
        public const int Size = 20;

        /// <summary>
        /// The raw binary 20 byte Id.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = Size)]
        public byte[] Id;

        public static implicit operator ObjectId(GitOid oid)
        {
            return new ObjectId(oid);
        }

        public static implicit operator ObjectId(GitOid? oid)
        {
            return oid == null ? null : new ObjectId(oid.Value);
        }

        /// <summary>
        /// Static convenience property to return an id (all zeros).
        /// </summary>
        public static GitOid Empty
        {
            get { return new GitOid(); }
        }
    }

    internal enum GitProxyType
    {
        None,
        Auto,
        Specified
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct GitProxyOptions
    {
        public uint Version;
        public GitProxyType Type;
        public IntPtr Url;
        public NativeMethods.git_cred_acquire_cb Credentials;
        public NativeMethods.git_transport_certificate_check_cb CertificateCheck;
        public IntPtr Payload;
    }

    internal class GitProxyOptionsWrapper : IDisposable
    {
        public GitProxyOptionsWrapper() : this(new GitProxyOptions()) { }

        public GitProxyOptionsWrapper(GitProxyOptions fetchOptions)
        {
            Options = fetchOptions;
        }

        public GitProxyOptions Options { get; private set; }

        private bool disposedValue = false;

        protected virtual void Dispose(bool disposing)
        {
            if (disposedValue)
                return;

            EncodingMarshaler.Cleanup(Options.Url);
            disposedValue = true;
        }

        public void Dispose()
        {
            Dispose(true);
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitPushOptions
    {
        public int Version = 1;
        public int PackbuilderDegreeOfParallelism;
        public GitRemoteCallbacks RemoteCallbacks;
        public GitProxyOptions ProxyOptions;
        public RemoteRedirectMode FollowRedirects = RemoteRedirectMode.Initial;
        public GitStrArrayManaged CustomHeaders;
        public GitStrArrayManaged RemotePushOptions;
    }

    /// <summary>
    /// Git push options wrapper. Disposable wrapper for <see cref="GitPushOptions"/>.
    /// </summary>
    internal class GitPushOptionsWrapper : IDisposable
    {
        public GitPushOptionsWrapper() : this(new GitPushOptions()) { }

        public GitPushOptionsWrapper(GitPushOptions pushOptions)
        {
            this.Options = pushOptions;
        }

        public GitPushOptions Options { get; private set; }

        #region IDisposable
        private bool disposedValue = false; // To detect redundant calls
        protected virtual void Dispose(bool disposing)
        {
            if (disposedValue)
                return;

            this.Options.CustomHeaders.Dispose();
            EncodingMarshaler.Cleanup(Options.ProxyOptions.Url);
            disposedValue = true;
        }

        public void Dispose()
        {
            Dispose(true);
        }
        #endregion
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_push_update
    {
        public char* src_refname;
        public char* dst_refname;
        public git_oid src;
        public git_oid dst;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_rebase_operation
    {
        internal RebaseStepOperation type;
        internal git_oid id;
        internal char* exec;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitRebaseOptions
    {
        public uint version = 1;

        public int quiet;

        public int inmemory;

        public IntPtr rewrite_notes_ref;

        public GitMergeOpts merge_options = new GitMergeOpts { Version = 1 };

        public GitCheckoutOpts checkout_options = new GitCheckoutOpts { version = 1 };

        private IntPtr padding; // TODO: add git_commit_create_cb

        public NativeMethods.commit_signing_callback signing_callback;
    }

    [Flags]
    internal enum GitReferenceType
    {
        Invalid = 0,
        Oid = 1,
        Symbolic = 2,
        Packed = 4,
        Peel = 8,
        ListAll = Oid | Symbolic | Packed
    }

    /// <summary>
    /// Structure for git_remote_callbacks
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct GitRemoteCallbacks
    {
        internal uint version;

        internal NativeMethods.remote_progress_callback progress;

        internal NativeMethods.remote_completion_callback completion;

        internal NativeMethods.git_cred_acquire_cb acquire_credentials;

        internal NativeMethods.git_transport_certificate_check_cb certificate_check;

        internal NativeMethods.git_transfer_progress_callback download_progress;

        internal NativeMethods.remote_update_tips_callback update_tips;

        internal NativeMethods.git_packbuilder_progress pack_progress;

        internal NativeMethods.git_push_transfer_progress push_transfer_progress;

        internal NativeMethods.push_update_reference_callback push_update_reference;

        internal NativeMethods.push_negotiation_callback push_negotiation;

        internal IntPtr transport;

        private IntPtr padding; // TODO: add git_remote_ready_cb

        internal IntPtr payload;

        internal NativeMethods.url_resolve_callback resolve_url;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_remote_head
    {
        public int Local;
        public git_oid Oid;
        public git_oid Loid;
        public char* Name;
        public char* SymrefTarget;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitRepositoryInitOptions : IDisposable
    {
        public uint Version = 1;
        public GitRepositoryInitFlags Flags;
        public int Mode;
        public IntPtr WorkDirPath;
        public IntPtr Description;
        public IntPtr TemplatePath;
        public IntPtr InitialHead;
        public IntPtr OriginUrl;

        public static GitRepositoryInitOptions BuildFrom(FilePath workdirPath, bool isBare)
        {
            var opts = new GitRepositoryInitOptions
            {
                Flags = GitRepositoryInitFlags.GIT_REPOSITORY_INIT_MKPATH,
                Mode = 0  /* GIT_REPOSITORY_INIT_SHARED_UMASK  */
            };

            if (workdirPath != null)
            {
                Debug.Assert(!isBare);

                opts.WorkDirPath = StrictFilePathMarshaler.FromManaged(workdirPath);
            }

            if (isBare)
            {
                opts.Flags |= GitRepositoryInitFlags.GIT_REPOSITORY_INIT_BARE;
            }

            return opts;
        }

        public void Dispose()
        {
            EncodingMarshaler.Cleanup(WorkDirPath);
            WorkDirPath = IntPtr.Zero;
        }
    }

    [Flags]
    internal enum GitRepositoryInitFlags
    {
        GIT_REPOSITORY_INIT_BARE = (1 << 0),
        GIT_REPOSITORY_INIT_NO_REINIT = (1 << 1),
        GIT_REPOSITORY_INIT_NO_DOTGIT_DIR = (1 << 2),
        GIT_REPOSITORY_INIT_MKDIR = (1 << 3),
        GIT_REPOSITORY_INIT_MKPATH = (1 << 4),
        GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE = (1 << 5),
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitRevertOpts
    {
        public uint Version = 1;

        // For merge commits, the "mainline" is treated as the parent
        public uint Mainline = 0;

        public GitMergeOpts MergeOpts = new GitMergeOpts { Version = 1 };

        public GitCheckoutOpts CheckoutOpts = new GitCheckoutOpts { version = 1 };
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_signature
    {
        public char* name;
        public char* email;
        public git_time when;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitSmartSubtransport
    {
        static GitSmartSubtransport()
        {
            GCHandleOffset = Marshal.OffsetOf(typeof(GitSmartSubtransport), "GCHandle").ToInt32();
        }

        public action_callback Action;
        public close_callback Close;
        public free_callback Free;

        /* The libgit2 structure definition ends here. Subsequent fields are for libgit2sharp bookkeeping. */

        public IntPtr GCHandle;

        /* The following static fields are not part of the structure definition. */

        public static int GCHandleOffset;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int action_callback(
            out IntPtr stream,
            IntPtr subtransport,
            IntPtr url,
            GitSmartSubtransportAction action);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int close_callback(IntPtr subtransport);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void free_callback(IntPtr subtransport);
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitSmartSubtransportRegistration
    {
        public IntPtr SubtransportCallback;
        public uint Rpc;
        public uint Param;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int create_callback(
            out IntPtr subtransport,
            IntPtr owner,
            IntPtr param);
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitSmartSubtransportStream
    {
        static GitSmartSubtransportStream()
        {
            GCHandleOffset = Marshal.OffsetOf(typeof(GitSmartSubtransportStream), "GCHandle").ToInt32();
        }

        public IntPtr SmartTransport;

        public read_callback Read;
        public write_callback Write;
        public free_callback Free;

        /* The libgit2 structure definition ends here. Subsequent fields are for libgit2sharp bookkeeping. */

        public IntPtr GCHandle;

        /* The following static fields are not part of the structure definition. */

        public static int GCHandleOffset;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int read_callback(
            IntPtr stream,
            IntPtr buffer,
            UIntPtr buf_size,
            out UIntPtr bytes_read);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int write_callback(
            IntPtr stream,
            IntPtr buffer,
            UIntPtr len);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void free_callback(IntPtr stream);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    internal delegate int stash_apply_progress_cb(StashApplyProgress progress, IntPtr payload);

    [StructLayout(LayoutKind.Sequential)]
    internal class GitStashApplyOpts
    {
        public uint Version = 1;

        public StashApplyModifiers Flags;
        public GitCheckoutOpts CheckoutOptions;

        public stash_apply_progress_cb ApplyProgressCallback;
        public IntPtr ProgressPayload;
    }

    /// <summary>
    /// A status entry from libgit2.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_status_entry
    {
        /// <summary>
        /// Calculated status of a filepath in the working directory considering the current <see cref = "Repository.Index" /> and the <see cref="Repository.Head" />.
        /// </summary>
        public FileStatus status;

        /// <summary>
        /// The difference between the <see cref="Repository.Head" /> and <see cref = "Repository.Index" />.
        /// </summary>
        public git_diff_delta* head_to_index;

        /// <summary>
        /// The difference between the <see cref = "Repository.Index" /> and the working directory.
        /// </summary>
        public git_diff_delta* index_to_workdir;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class GitStatusOptions : IDisposable
    {
        public uint Version = 1;

        public GitStatusShow Show;
        public GitStatusOptionFlags Flags;

        public GitStrArrayManaged PathSpec;

        public IntPtr Baseline = IntPtr.Zero;

        public void Dispose()
        {
            PathSpec.Dispose();
        }
    }

    internal enum GitStatusShow
    {
        IndexAndWorkDir = 0,
        IndexOnly = 1,
        WorkDirOnly = 2,
    }

    [Flags]
    internal enum GitStatusOptionFlags
    {
        IncludeUntracked = (1 << 0),
        IncludeIgnored = (1 << 1),
        IncludeUnmodified = (1 << 2),
        ExcludeSubmodules = (1 << 3),
        RecurseUntrackedDirs = (1 << 4),
        DisablePathspecMatch = (1 << 5),
        RecurseIgnoredDirs = (1 << 6),
        RenamesHeadToIndex = (1 << 7),
        RenamesIndexToWorkDir = (1 << 8),
        SortCaseSensitively = (1 << 9),
        SortCaseInsensitively = (1 << 10),
        RenamesFromRewrites = (1 << 11),
        NoRefresh = (1 << 12),
        UpdateIndex = (1 << 13),
        IncludeUnreadable = (1 << 14),
        IncludeUnreadableAsUntracked = (1 << 15),
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct GitStrArray
    {
        /// <summary>
        /// A pointer to an array of null-terminated strings.
        /// </summary>
        public IntPtr Strings;

        /// <summary>
        /// The number of strings in the array.
        /// </summary>
        public UIntPtr Count;

        /// <summary>
        /// Resets the GitStrArray to default values.
        /// </summary>
        public void Reset()
        {
            Strings = IntPtr.Zero;
            Count = UIntPtr.Zero;
        }
    }

    /// <summary>
    /// A git_strarray where the string array and strings themselves were allocated
    /// with LibGit2Sharp's allocator (Marshal.AllocHGlobal).
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct GitStrArrayManaged : IDisposable
    {
        public GitStrArray Array;

        public static GitStrArrayManaged BuildFrom(string[] strings)
        {
            return BuildFrom(strings, StrictUtf8Marshaler.FromManaged);
        }

        public static GitStrArrayManaged BuildFrom(FilePath[] paths)
        {
            return BuildFrom(paths, StrictFilePathMarshaler.FromManaged);
        }

        private static GitStrArrayManaged BuildFrom<T>(T[] input, Func<T, IntPtr> marshaler)
        {
            var pointers = new IntPtr[input.Length];

            for (int i = 0; i < input.Length; i++)
            {
                var item = input[i];
                pointers[i] = marshaler(item);
            }

            var toReturn = new GitStrArrayManaged();

            toReturn.Array.Strings = Marshal.AllocHGlobal(checked(IntPtr.Size * input.Length));
            Marshal.Copy(pointers, 0, toReturn.Array.Strings, input.Length);
            toReturn.Array.Count = new UIntPtr((uint)input.Length);

            return toReturn;
        }

        public void Dispose()
        {
            var count = checked((int)Array.Count.ToUInt32());

            for (int i = 0; i < count; i++)
            {
                EncodingMarshaler.Cleanup(Marshal.ReadIntPtr(Array.Strings, i * IntPtr.Size));
            }

            if (Array.Strings != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(Array.Strings);
            }

            // Now that we've freed the memory, zero out the structure.
            Array.Reset();
        }
    }

    /// <summary>
    /// A git_strarray where the string array and strings themselves were allocated
    /// with libgit2's allocator. Only libgit2 can free this git_strarray.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct GitStrArrayNative : IDisposable
    {
        public GitStrArray Array;

        /// <summary>
        /// Enumerates each string from the array using the UTF-8 marshaler.
        /// </summary>
        public String[] ReadStrings()
        {
            var count = checked((int)Array.Count.ToUInt32());

            String[] toReturn = new String[count];

            for (int i = 0; i < count; i++)
            {
                toReturn[i] = LaxUtf8Marshaler.FromNative(Marshal.ReadIntPtr(Array.Strings, i * IntPtr.Size));
            }

            return toReturn;
        }

        public void Dispose()
        {
            if (Array.Strings != IntPtr.Zero)
            {
                NativeMethods.git_strarray_dispose(ref Array);
            }

            // Now that we've freed the memory, zero out the structure.
            Array.Reset();
        }
    }

    internal enum GitSubmoduleIgnore
    {
        Unspecified = -1,
        None = 1,
        Untracked = 2,
        Dirty = 3,
        All = 4,
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct GitSubmoduleUpdateOptions
    {
        public uint Version;

        public GitCheckoutOpts CheckoutOptions;

        public GitFetchOptions FetchOptions;

        public int AllowFetch;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct git_time
    {
        public long time;
        public int offset;
    }

    /// <summary>
    /// Managed structure corresponding to git_transfer_progress native structure.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct GitTransferProgress
    {
        public uint total_objects;
        public uint indexed_objects;
        public uint received_objects;
        public uint local_objects;
        public uint total_deltas;
        public uint indexed_deltas;
        public UIntPtr received_bytes;
    }

    /**
    * Flags which can be passed to git_worktree_prune to alter its
    * behavior.
    */
    [Flags]
    internal enum GitWorktreePruneOptionFlags : uint
    {
        /// <summary>
        /// Prune working tree even if working tree is valid
        /// </summary>
        GIT_WORKTREE_PRUNE_VALID = (1u << 0),

        /// <summary>
        /// Prune working tree even if it is locked
        /// </summary>
        GIT_WORKTREE_PRUNE_LOCKED = (1u << 1),

        /// <summary>
        /// Prune checked out working tree
        /// </summary>
        GIT_WORKTREE_PRUNE_WORKING_TREE = (1u << 2)
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class git_worktree_add_options
    {
        public uint version = 1;

        public int locked;

        public IntPtr @ref = IntPtr.Zero;

        public GitCheckoutOpts checkoutOpts = new GitCheckoutOpts { version = 1 };
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class git_worktree_prune_options
    {
        public uint version = 1;

        public GitWorktreePruneOptionFlags flags;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct GitWriteStream
    {
        [MarshalAs(UnmanagedType.FunctionPtr)]
        public write_fn write;

        [MarshalAs(UnmanagedType.FunctionPtr)]
        public close_fn close;

        [MarshalAs(UnmanagedType.FunctionPtr)]
        public free_fn free;

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int write_fn(IntPtr stream, IntPtr buffer, UIntPtr len);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int close_fn(IntPtr stream);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void free_fn(IntPtr stream);
    }

    internal class HistoryRewriter
    {
        private readonly IRepository repo;

        private readonly HashSet<Commit> targetedCommits;
        private readonly Dictionary<GitObject, GitObject> objectMap = new Dictionary<GitObject, GitObject>();
        private readonly Dictionary<Reference, Reference> refMap = new Dictionary<Reference, Reference>();
        private readonly Queue<Action> rollbackActions = new Queue<Action>();

        private readonly string backupRefsNamespace;
        private readonly RewriteHistoryOptions options;

        public HistoryRewriter(
            IRepository repo,
            IEnumerable<Commit> commitsToRewrite,
            RewriteHistoryOptions options)
        {
            this.repo = repo;
            this.options = options;
            targetedCommits = new HashSet<Commit>(commitsToRewrite);

            backupRefsNamespace = this.options.BackupRefsNamespace;

            if (!backupRefsNamespace.EndsWith("/", StringComparison.Ordinal))
            {
                backupRefsNamespace += "/";
            }
        }

        public void Execute()
        {
            var success = false;
            try
            {
                // Find out which refs lead to at least one the commits
                var refsToRewrite = repo.Refs.ReachableFrom(targetedCommits).ToList();

                var filter = new CommitFilter
                {
                    IncludeReachableFrom = refsToRewrite,
                    SortBy = CommitSortStrategies.Reverse | CommitSortStrategies.Topological
                };

                var commits = repo.Commits.QueryBy(filter);
                foreach (var commit in commits)
                {
                    RewriteCommit(commit, options);
                }

                // Ordering matters. In the case of `A -> B -> commit`, we need to make sure B is rewritten
                // before A.
                foreach (var reference in refsToRewrite.OrderBy(ReferenceDepth))
                {
                    // TODO: Rewrite refs/notes/* properly
                    if (reference.CanonicalName.StartsWith("refs/notes/"))
                    {
                        continue;
                    }

                    RewriteReference(reference);
                }

                success = true;
                if (options.OnSucceeding != null)
                {
                    options.OnSucceeding();
                }
            }
            catch (Exception ex)
            {
                try
                {
                    if (!success && options.OnError != null)
                    {
                        options.OnError(ex);
                    }
                }
                finally
                {
                    foreach (var action in rollbackActions)
                    {
                        action();
                    }
                }

                throw;
            }
            finally
            {
                rollbackActions.Clear();
            }
        }

        private Reference RewriteReference(Reference reference)
        {
            // Has this target already been rewritten?
            if (refMap.ContainsKey(reference))
            {
                return refMap[reference];
            }

            var sref = reference as SymbolicReference;
            if (sref != null)
            {
                return RewriteReference(sref,
                                        old => old.Target,
                                        RewriteReference,
                                        (refs, old, target, logMessage) => refs.UpdateTarget(old,
                                                                                             target,
                                                                                             logMessage));
            }

            var dref = reference as DirectReference;
            if (dref != null)
            {
                return RewriteReference(dref,
                                        old => old.Target,
                                        RewriteTarget,
                                        (refs, old, target, logMessage) => refs.UpdateTarget(old,
                                                                                             target.Id,
                                                                                             logMessage));
            }

            return reference;
        }

        private delegate Reference ReferenceUpdater<in TRef, in TTarget>(
            ReferenceCollection refs,
            TRef origRef,
            TTarget origTarget,
            string logMessage)
            where TRef : Reference
            where TTarget : class;

        private Reference RewriteReference<TRef, TTarget>(
            TRef oldRef, Func<TRef, TTarget> selectTarget,
            Func<TTarget, TTarget> rewriteTarget,
            ReferenceUpdater<TRef, TTarget> updateTarget)
            where TRef : Reference
            where TTarget : class
        {
            var oldRefTarget = selectTarget(oldRef);

            string newRefName = oldRef.CanonicalName;
            if (oldRef.IsTag && options.TagNameRewriter != null)
            {
                newRefName = Reference.TagPrefix +
                             options.TagNameRewriter(oldRef.CanonicalName.Substring(Reference.TagPrefix.Length),
                                                     false,
                                                     oldRef.TargetIdentifier);
            }

            var newTarget = rewriteTarget(oldRefTarget);

            if (oldRefTarget.Equals(newTarget) && oldRef.CanonicalName == newRefName)
            {
                // The reference isn't rewritten
                return oldRef;
            }

            string backupName = backupRefsNamespace + oldRef.CanonicalName.Substring("refs/".Length);

            if (repo.Refs.Resolve<Reference>(backupName) != null)
            {
                throw new InvalidOperationException(String.Format(CultureInfo.InvariantCulture,
                                                                  "Can't back up reference '{0}' - '{1}' already exists",
                                                                  oldRef.CanonicalName,
                                                                  backupName));
            }

            repo.Refs.Add(backupName, oldRef.TargetIdentifier, "filter-branch: backup");
            rollbackActions.Enqueue(() => repo.Refs.Remove(backupName));

            if (newTarget == null)
            {
                repo.Refs.Remove(oldRef);
                rollbackActions.Enqueue(() => repo.Refs.Add(oldRef.CanonicalName, oldRef, "filter-branch: abort", true));
                return refMap[oldRef] = null;
            }

            Reference newRef = updateTarget(repo.Refs, oldRef, newTarget, "filter-branch: rewrite");
            rollbackActions.Enqueue(() => updateTarget(repo.Refs, oldRef, oldRefTarget, "filter-branch: abort"));

            if (newRef.CanonicalName == newRefName)
            {
                return refMap[oldRef] = newRef;
            }

            var movedRef = repo.Refs.Rename(newRef, newRefName, false);
            rollbackActions.Enqueue(() => repo.Refs.Rename(newRef, oldRef.CanonicalName, false));
            return refMap[oldRef] = movedRef;
        }

        private void RewriteCommit(Commit commit, RewriteHistoryOptions options)
        {
            var newHeader = CommitRewriteInfo.From(commit);
            var newTree = commit.Tree;

            // Find the new parents
            var newParents = commit.Parents;

            if (targetedCommits.Contains(commit))
            {
                // Get the new commit header
                if (options.CommitHeaderRewriter != null)
                {
                    newHeader = options.CommitHeaderRewriter(commit) ?? newHeader;
                }

                if (options.CommitTreeRewriter != null)
                {
                    // Get the new commit tree
                    var newTreeDefinition = options.CommitTreeRewriter(commit);
                    newTree = repo.ObjectDatabase.CreateTree(newTreeDefinition);
                }

                // Retrieve new parents
                if (options.CommitParentsRewriter != null)
                {
                    newParents = options.CommitParentsRewriter(commit);
                }
            }

            // Create the new commit
            var mappedNewParents = newParents
                .Select(oldParent => objectMap.ContainsKey(oldParent)
                            ? objectMap[oldParent] as Commit
                            : oldParent)
                .Where(newParent => newParent != null)
                .ToList();

            if (options.PruneEmptyCommits &&
                TryPruneEmptyCommit(commit, mappedNewParents, newTree))
            {
                return;
            }

            var newCommit = repo.ObjectDatabase.CreateCommit(newHeader.Author,
                                                             newHeader.Committer,
                                                             newHeader.Message,
                                                             newTree,
                                                             mappedNewParents,
                                                             options.PrettifyMessages);

            // Record the rewrite
            objectMap[commit] = newCommit;
        }

        private bool TryPruneEmptyCommit(Commit commit, IList<Commit> mappedNewParents, Tree newTree)
        {
            var parent = mappedNewParents.Count > 0 ? mappedNewParents[0] : null;

            if (parent == null)
            {
                if (newTree.Count == 0)
                {
                    objectMap[commit] = null;
                    return true;
                }
            }
            else if (parent.Tree == newTree)
            {
                objectMap[commit] = parent;
                return true;
            }

            return false;
        }

        private GitObject RewriteTarget(GitObject oldTarget)
        {
            // Has this target already been rewritten?
            if (objectMap.ContainsKey(oldTarget))
            {
                return objectMap[oldTarget];
            }

            Debug.Assert((oldTarget as Commit) == null);

            var annotation = oldTarget as TagAnnotation;
            if (annotation == null)
            {
                //TODO: Probably a Tree or a Blob. This is not covered by any test
                return oldTarget;
            }

            // Recursively rewrite annotations if necessary
            var newTarget = RewriteTarget(annotation.Target);

            string newName = annotation.Name;

            if (options.TagNameRewriter != null)
            {
                newName = options.TagNameRewriter(annotation.Name, true, annotation.Target.Sha);
            }

            var newAnnotation = repo.ObjectDatabase.CreateTagAnnotation(newName,
                                                                        newTarget,
                                                                        annotation.Tagger,
                                                                        annotation.Message);
            objectMap[annotation] = newAnnotation;
            return newAnnotation;
        }

        private int ReferenceDepth(Reference reference)
        {
            var dref = reference as DirectReference;
            return dref == null
                ? 1 + ReferenceDepth(((SymbolicReference)reference).Target)
                : 1;
        }
    }

    internal interface ILazy<T>
    {
        T Value { get; }
    }

    internal class LambdaEqualityHelper<T>
    {
        private readonly Func<T, object>[] equalityContributorAccessors;

        public LambdaEqualityHelper(params Func<T, object>[] equalityContributorAccessors)
        {
            this.equalityContributorAccessors = equalityContributorAccessors;
        }

        public bool Equals(T instance, T other)
        {
            if (ReferenceEquals(null, instance) || ReferenceEquals(null, other))
            {
                return false;
            }

            if (ReferenceEquals(instance, other))
            {
                return true;
            }

            if (instance.GetType() != other.GetType())
            {
                return false;
            }

            foreach (Func<T, object> accessor in equalityContributorAccessors)
            {
                if (!Equals(accessor(instance), accessor(other)))
                {
                    return false;
                }
            }

            return true;
        }

        public int GetHashCode(T instance)
        {
            int hashCode = GetType().GetHashCode();

            unchecked
            {
                foreach (Func<T, object> accessor in equalityContributorAccessors)
                {
                    object item = accessor(instance);
                    hashCode = (hashCode * 397) ^ (item != null ? item.GetHashCode() : 0);
                }
            }

            return hashCode;
        }
    }

    internal abstract class LazyGroup<T>
    {
        private readonly IList<IEvaluator<T>> evaluators = new List<IEvaluator<T>>();
        private readonly object @lock = new object();
        private bool evaluated;
        protected readonly Repository repo;

        protected LazyGroup(Repository repo)
        {
            this.repo = repo;
        }

        public ILazy<TResult> AddLazy<TResult>(Func<T, TResult> func)
        {
            var prop = new Dependent<T, TResult>(func, this);
            evaluators.Add(prop);
            return prop;
        }

        public void Evaluate()
        {
            lock (@lock)
            {
                if (evaluated)
                {
                    return;
                }

                EvaluateInternal(input =>
                                 {
                                     foreach (var e in evaluators)
                                     {
                                         e.Evaluate(input);
                                     }
                                 });
                evaluated = true;
            }
        }

        protected abstract void EvaluateInternal(Action<T> evaluator);

        protected static ILazy<TResult> Singleton<TResult>(Func<TResult> resultSelector)
        {
            return new LazyWrapper<TResult>(resultSelector);
        }

        private interface IEvaluator<TInput>
        {
            void Evaluate(TInput input);
        }

        private class Dependent<TInput, TOutput> : ILazy<TOutput>, IEvaluator<TInput>
        {
            private readonly Func<TInput, TOutput> valueFactory;
            private readonly LazyGroup<TInput> lazyGroup;

            private TOutput value;
            private bool hasBeenEvaluated;

            public Dependent(Func<TInput, TOutput> valueFactory, LazyGroup<TInput> lazyGroup)
            {
                this.valueFactory = valueFactory;
                this.lazyGroup = lazyGroup;
            }

            public TOutput Value
            {
                get { return Evaluate(); }
            }

            private TOutput Evaluate()
            {
                if (!hasBeenEvaluated)
                {
                    lazyGroup.Evaluate();
                }

                return value;
            }

            void IEvaluator<TInput>.Evaluate(TInput input)
            {
                value = valueFactory(input);
                hasBeenEvaluated = true;
            }
        }

        protected class LazyWrapper<TType> : Lazy<TType>, ILazy<TType>
        {
            public LazyWrapper(Func<TType> evaluator)
                : base(evaluator)
            { }
        }
    }

    [Flags]
    internal enum LookUpOptions
    {
        None = 0,
        ThrowWhenNoGitObjectHasBeenFound = 1,
        DereferenceResultToCommit = 2,
        ThrowWhenCanNotBeDereferencedToACommit = 4,
    }

    internal enum OSPlatform { Windows, Linux, OSX };
    internal enum Architecture { Amd64, Arm64 };

    public static class DateTimeOffsetExtensions
    {
        public static long ToUnixTimeSeconds(this DateTimeOffset when)
        {
            return (long)when.Subtract(new DateTimeOffset(1970, 1, 1, 0, 0, 0, TimeSpan.Zero)).TotalSeconds;
        }
        public static DateTimeOffset FromUnixTimeSeconds(long time)
        {
            return new DateTimeOffset(1970, 1, 1, 0, 0, 0, TimeSpan.Zero).AddSeconds(time);
        }
    }

#if !LIBGIT2_USE_INTERNAL_DLL
#if LIBGIT2_ORIGINAL_DLL_LOADING
    struct DllImportSearchPath { } // dummy replacement for System.Runtime.InteropServices from .NET 4.5
    internal static class RuntimeInformation
    {
        internal static bool IsOSPlatform(OSPlatform osp) { return (osp == OSPlatform.Windows); }
        internal static Architecture ProcessArchitecture = Architecture.Amd64;
    }
    internal static class NativeLibrary
    {
        internal static void SetDllImportResolver(Assembly assembly, Func<string, Assembly, DllImportSearchPath?, IntPtr> ResolveDll)
        {
            //throw new NotImplementedException();
        }

        internal static bool TryLoad(string nativeLibraryPath, out IntPtr handle)
        {
            //throw new NotImplementedException();
            handle = IntPtr.Zero;
            return true;
        }

        internal static bool TryLoad(string libraryName, Assembly assembly, DllImportSearchPath? searchPath, out IntPtr handle)
        {
            //throw new NotImplementedException();
            handle = IntPtr.Zero;
            return true;
        }
    }

    internal static class NativeMethods
    {
        public const uint GIT_PATH_MAX = 4096;
        private const string libgit2 = "git2-172-dbg.dll"; //NativeDllName.Name;

        // An object tied to the lifecycle of the NativeMethods static class.
        // This will handle initialization and shutdown of the underlying
        // native library.
        private static NativeShutdownObject shutdownObject;

        static NativeMethods()
        {
            if (Platform.IsRunningOnNetFramework() || Platform.IsRunningOnNetCore())
            {
                // Use NativeLibrary when available.
                if (!TryUseNativeLibrary())
                {
                    // NativeLibrary is not available, fall back.

                    // Use GlobalSettings.NativeLibraryPath when set.
                    // Try to load the .dll from the path explicitly.
                    // If this call succeeds further DllImports will find the library loaded and not attempt to load it again.
                    // If it fails the next DllImport will load the library from safe directories.
                    string nativeLibraryPath = GetGlobalSettingsNativeLibraryPath();

                    if (nativeLibraryPath != null)
                    {
                        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))

                        {
                            LoadWindowsLibrary(nativeLibraryPath);
                        }
                        else
                        {
                            LoadUnixLibrary(nativeLibraryPath, RTLD_NOW);
                        }
                    }
                }
            }

            InitializeNativeLibrary();
        }

        private static string GetGlobalSettingsNativeLibraryPath()
        {
            string nativeLibraryDir = GlobalSettings.GetAndLockNativeLibraryPath();

            if (nativeLibraryDir == null)
            {
                return null;
            }

            return Path.Combine(nativeLibraryDir, libgit2 + Platform.GetNativeLibraryExtension());
        }

#if NETFRAMEWORK
        private static bool TryUseNativeLibrary() => false;
#else
        private static bool TryUseNativeLibrary()
        {
            NativeLibrary.SetDllImportResolver(typeof(NativeMethods).Assembly, ResolveDll);

            return true;
        }

        private static IntPtr ResolveDll(string libraryName, Assembly assembly, DllImportSearchPath? searchPath)
        {
            IntPtr handle = IntPtr.Zero;

            if (libraryName == libgit2)
            {
                // Use GlobalSettings.NativeLibraryPath when set.
                string nativeLibraryPath = GetGlobalSettingsNativeLibraryPath();

                if (nativeLibraryPath != null && NativeLibrary.TryLoad(nativeLibraryPath, out handle))
                {
                    return handle;
                }

                // Use Default DllImport resolution.
                if (NativeLibrary.TryLoad(libraryName, assembly, searchPath, out handle))
                {
                    return handle;
                }

                // We carry a number of .so files for Linux which are linked against various
                // libc/OpenSSL libraries. Try them out.
                if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                {
                    // The libraries are located at 'runtimes/<rid>/native/lib{libraryName}.so'
                    // The <rid> ends with the processor architecture. e.g. fedora-x64.
                    string assemblyDirectory = Path.GetDirectoryName(typeof(NativeMethods).Assembly.Location);
                    string processorArchitecture = RuntimeInformation.ProcessArchitecture.ToString().ToLowerInvariant();
                    string runtimesDirectory = Path.Combine(assemblyDirectory, "runtimes");

                    if (Directory.Exists(runtimesDirectory))
                    {
                        foreach (var runtimeFolder in Directory.GetDirectories(runtimesDirectory, "*-"+processorArchitecture))
                        {
                            string libPath = Path.Combine(runtimeFolder, "native", "lib"+libraryName+".so");

                            if (NativeLibrary.TryLoad(libPath, out handle))
                            {
                                return handle;
                            }
                        }
                    }
                }
            }

            return handle;
        }
#endif

        public const int RTLD_NOW = 0x002;

        [DllImport("libdl", EntryPoint = "dlopen")]
        private static extern IntPtr LoadUnixLibrary(string path, int flags);

        [DllImport("kernel32", EntryPoint = "LoadLibrary")]
        private static extern IntPtr LoadWindowsLibrary(string path);

        // Avoid inlining this method because otherwise mono's JITter may try
        // to load the library _before_ we've configured the path.
        [MethodImpl(MethodImplOptions.NoInlining)]
        private static void InitializeNativeLibrary()
        {
            int initCounter;
            try
            {
            }
            finally // avoid thread aborts
            {
                // Initialization can be called multiple times as long as there is a corresponding shutdown to each initialization.
                initCounter = git_libgit2_init();
                shutdownObject = new NativeShutdownObject();
            }

            // Configure the OpenSSL locking on the first initialization of the library in the current process.
            if (initCounter == 1)
            {
                git_openssl_set_locking();
            }
        }
#else
    internal static class NativeMethods
    {
#endif
        #if PLATFORM_x64
        private const string libgit2 = "libgit2-x64";
        #elif PLATFORM_x86
        private const string libgit2 = "libgit2-x86";
        #else
        #error Unknown platform
        #endif

        private static NativeShutdownObject shutdownObject;

        [DllImport("kernel32.dll", EntryPoint = "LoadLibrary")]
        private static extern IntPtr LoadWindowsLibrary(string path);

        static NativeMethods()
        {
            // Initialization can be called multiple times as long as there is a corresponding shutdown to each initialization.
            int initCounter = initCounter = git_libgit2_init();
            System.Diagnostics.Debug.Assert(initCounter == 1);

            shutdownObject = new NativeShutdownObject();

            // Configure the OpenSSL locking on the first initialization of the library in the current process.
            if (initCounter == 1)
            {
                git_openssl_set_locking();
            }
        }

        // Shutdown the native library in a finalizer.
        private sealed class NativeShutdownObject : CriticalFinalizerObject
        {
            ~NativeShutdownObject()
            {
                git_libgit2_shutdown();
            }
        }

#region dll imports
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe GitError* git_error_last();

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_error_set_str(
            GitErrorCategory error_class,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string errorString);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void git_error_set_oom();

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UInt32 git_blame_get_hunk_count(git_blame* blame);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_blame_hunk* git_blame_get_hunk_byindex(
            git_blame* blame, UInt32 index);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_blame_file(
            out git_blame* blame,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path,
            git_blame_options options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_blame_free(git_blame* blame);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_blob_create_from_disk(
            ref GitOid id,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_blob_create_from_workdir(
            ref GitOid id,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath relative_path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_blob_create_from_stream(
            out IntPtr stream,
            git_repository* repositoryPtr,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string hintpath);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_blob_create_from_stream_commit(
            ref GitOid oid,
            IntPtr stream);

#if LIBGIT2_HAVE_DEPRECATE
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_blob_filtered_content(
            GitBuf buf,
            git_object* blob,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string as_path,
            [MarshalAs(UnmanagedType.Bool)] bool check_for_binary_data);
#endif

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe IntPtr git_blob_rawcontent(git_object* blob);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe Int64 git_blob_rawsize(git_object* blob);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_branch_create_from_annotated(
            out git_reference* ref_out,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string branch_name,
            git_annotated_commit* target,
            [MarshalAs(UnmanagedType.Bool)] bool force);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_branch_delete(
            git_reference* reference);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int branch_foreach_callback(
            IntPtr branch_name,
            GitBranchType branch_type,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void git_branch_iterator_free(
            IntPtr iterator);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_branch_iterator_new(
            out IntPtr iter_out,
            IntPtr repo,
            GitBranchType branch_type);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_branch_move(
            out git_reference* ref_out,
            git_reference* reference,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string new_branch_name,
            [MarshalAs(UnmanagedType.Bool)] bool force);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_branch_next(
            out IntPtr ref_out,
            out GitBranchType type_out,
            IntPtr iter);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_branch_remote_name(
            GitBuf buf,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string canonical_branch_name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int commit_signing_callback(
            IntPtr signature,
            IntPtr signature_field,
            IntPtr commit_content,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_rebase_init(
            out git_rebase* rebase,
            git_repository* repo,
            git_annotated_commit* branch,
            git_annotated_commit* upstream,
            git_annotated_commit* onto,
            GitRebaseOptions options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_rebase_open(
            out git_rebase* rebase,
            git_repository* repo,
            GitRebaseOptions options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UIntPtr git_rebase_operation_entrycount(
            git_rebase* rebase);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UIntPtr git_rebase_operation_current(
            git_rebase* rebase);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_rebase_operation* git_rebase_operation_byindex(
            git_rebase* rebase,
            UIntPtr index);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_rebase_next(
            out git_rebase_operation* operation,
            git_rebase* rebase);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_rebase_commit(
            ref GitOid id,
            git_rebase* rebase,
            git_signature* author,
            git_signature* committer,
            IntPtr message_encoding,
            IntPtr message);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_rebase_abort(
            git_rebase* rebase);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_rebase_finish(
            git_rebase* repo,
            git_signature* signature);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_rebase_free(git_rebase* rebase);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_rename(
            ref GitStrArray problems,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string old_name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string new_name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_remote_rename_problem_cb(
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))] string problematic_refspec,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_branch_upstream_name(
            GitBuf buf,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string referenceName);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void git_buf_dispose(GitBuf buf);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_checkout_tree(
            git_repository* repo,
            git_object* treeish,
            ref GitCheckoutOpts opts);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_checkout_index(
            git_repository* repo,
            git_object* treeish,
            ref GitCheckoutOpts opts);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_clone(
            out git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string origin_url,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath workdir_path,
            ref GitCloneOptions opts);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_signature* git_commit_author(git_object* commit);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_signature* git_commit_committer(git_object* commit);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_commit_create_from_ids(
            out GitOid id,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string updateRef,
            git_signature* author,
            git_signature* committer,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string encoding,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string message,
            ref GitOid tree,
            UIntPtr parentCount,
            [MarshalAs(UnmanagedType.LPArray)][In] IntPtr[] parents);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_commit_create_buffer(
            GitBuf res,
            git_repository* repo,
            git_signature* author,
            git_signature* committer,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string encoding,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string message,
            git_object* tree,
            UIntPtr parent_count,
            IntPtr* parents /* git_commit** originally */);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_commit_create_with_signature(
            out GitOid id,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string commit_content,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string signature,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string signature_field);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_commit_message(git_object* commit);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_commit_summary(git_object* commit);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_commit_message_encoding(git_object* commit);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_commit_parent_id(git_object* commit, uint n);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe uint git_commit_parentcount(git_object* commit);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_commit_tree_id(git_object* commit);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_commit_extract_signature(
            GitBuf signature,
            GitBuf signed_data,
            git_repository* repo,
            ref GitOid commit_id,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string field);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_delete_entry(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_lock(out IntPtr txn, git_config* config);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_delete_multivar(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string regexp);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_set_multivar(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string regexp,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string value);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_config_find_global(GitBuf global_config_path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_config_find_system(GitBuf system_config_path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_config_find_xdg(GitBuf xdg_config_path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_config_find_programdata(GitBuf programdata_config_path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_config_free(git_config* cfg);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_config_entry_free(GitConfigEntry* entry);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_get_entry(
            out GitConfigEntry* entry,
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_add_file_ondisk(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path,
            uint level,
            git_repository* repo,
            [MarshalAs(UnmanagedType.Bool)] bool force);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_new(out git_config* cfg);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_open_level(
            out git_config* cfg,
            git_config* parent,
            uint level);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_config_parse_bool(
            [MarshalAs(UnmanagedType.Bool)] out bool value,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string valueToParse);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_config_parse_int32(
            [MarshalAs(UnmanagedType.I4)] out int value,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string valueToParse);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_config_parse_int64(
            [MarshalAs(UnmanagedType.I8)] out long value,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string valueToParse);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_set_bool(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.Bool)] bool value);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_set_int32(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            int value);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_set_int64(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            long value);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_set_string(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string value);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int config_foreach_callback(
            IntPtr entry,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_foreach(
            git_config* cfg,
            config_foreach_callback callback,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_config_iterator_glob_new(
            out IntPtr iter,
            IntPtr cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string regexp);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_config_next(
            out IntPtr entry,
            IntPtr iter);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void git_config_iterator_free(IntPtr iter);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_config_snapshot(out git_config* @out, git_config* config);

        // Ordinarily we would decorate the `url` parameter with the StrictUtf8Marshaler like we do everywhere
        // else, but apparently doing a native->managed callback with the 64-bit version of CLR 2.0 can
        // sometimes vomit when using a custom IMarshaler.  So yeah, don't do that.  If you need the url,
        // call StrictUtf8Marshaler.FromNative manually.  See the discussion here:
        // http://social.msdn.microsoft.com/Forums/en-US/netfx64bit/thread/1eb746c6-d695-4632-8a9e-16c4fa98d481
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_cred_acquire_cb(
            out IntPtr cred,
            IntPtr url,
            IntPtr username_from_url,
            GitCredentialType allowed_types,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_credential_default_new(out IntPtr cred);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_credential_userpass_plaintext_new(
            out IntPtr cred,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string username,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string password);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void git_credential_free(IntPtr cred);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_describe_commit(
            out git_describe_result* describe,
            git_object* committish,
            ref GitDescribeOptions options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_describe_format(
            GitBuf buf,
            git_describe_result* describe,
            ref GitDescribeFormatOptions options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_describe_result_free(git_describe_result* describe);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_diff_free(git_diff* diff);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_diff_tree_to_tree(
            out git_diff* diff,
            git_repository* repo,
            git_object* oldTree,
            git_object* newTree,
            GitDiffOptions options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_diff_tree_to_index(
            out git_diff* diff,
            git_repository* repo,
            git_object* oldTree,
            git_index* index,
            GitDiffOptions options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_diff_merge(
            git_diff* onto,
            git_diff* from);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_diff_index_to_workdir(
            out git_diff* diff,
            git_repository* repo,
            git_index* index,
            GitDiffOptions options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_diff_tree_to_workdir(
            out git_diff* diff,
            git_repository* repo,
            git_object* oldTree,
            GitDiffOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int git_diff_file_cb(
            [In] git_diff_delta* delta,
            float progress,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int git_diff_hunk_cb(
            [In] git_diff_delta* delta,
            [In] GitDiffHunk hunk,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int git_diff_line_cb(
            [In] git_diff_delta* delta,
            [In] GitDiffHunk hunk,
            [In] GitDiffLine line,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int git_diff_binary_cb(
            [In] git_diff_delta* delta,
            [In] GitDiffBinary binary,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_diff_blobs(
            git_object* oldBlob,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string old_as_path,
            git_object* newBlob,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string new_as_path,
            GitDiffOptions options,
            git_diff_file_cb fileCallback,
            git_diff_binary_cb binaryCallback,
            git_diff_hunk_cb hunkCallback,
            git_diff_line_cb lineCallback,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_diff_foreach(
            git_diff* diff,
            git_diff_file_cb fileCallback,
            git_diff_binary_cb binaryCallback,
            git_diff_hunk_cb hunkCallback,
            git_diff_line_cb lineCallback,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_diff_find_similar(
            git_diff* diff,
            GitDiffFindOptions options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UIntPtr git_diff_num_deltas(git_diff* diff);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_diff_delta* git_diff_get_delta(git_diff* diff, UIntPtr idx);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_filter_register(
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            IntPtr gitFilter, int priority);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_filter_unregister(
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_filter_source_mode(git_filter_source* source);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_libgit2_features();

        #region git_libgit2_opts

        // Bindings for git_libgit2_opts(int option, ...):
        // Currently only GIT_OPT_GET_SEARCH_PATH and GIT_OPT_SET_SEARCH_PATH are supported,
        // but other overloads could be added using a similar pattern.
        // CallingConvention.Cdecl is used to allow binding the the C varargs signature, and each possible call signature must be enumerated.
        // __argslist was an option, but is an undocumented feature that should likely not be used here.

        // git_libgit2_opts(GIT_OPT_GET_SEARCH_PATH, int level, git_buf *buf)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_libgit2_opts(int option, uint level, GitBuf buf);

        // git_libgit2_opts(GIT_OPT_SET_SEARCH_PATH, int level, const char *path)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_libgit2_opts(int option, uint level,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        // git_libgit2_opts(GIT_OPT_ENABLE_*, int enabled)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_libgit2_opts(int option, int enabled);

        // git_libgit2_opts(GIT_OPT_SET_USER_AGENT, const char *path)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_libgit2_opts(int option,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        // git_libgit2_opts(GIT_OPT_GET_USER_AGENT, git_buf *buf)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_libgit2_opts(int option, GitBuf buf);

        // git_libgit2_opts(GIT_OPT_SET_EXTENSIONS, const char **extensions, size_t len)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_libgit2_opts(int option, IntPtr extensions, UIntPtr len);

        // git_libgit2_opts(GIT_OPT_GET_EXTENSIONS, git_strarray *out)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_libgit2_opts(int option, out GitStrArray extensions);
        #endregion

        #region git_libgit2_opts_osxarm64

        // For RID osx-arm64 the calling convention is different: we need to pad out to 8 arguments before varargs
        // (see discussion at https://github.com/dotnet/runtime/issues/48796)

        // git_libgit2_opts(GIT_OPT_GET_SEARCH_PATH, int level, git_buf *buf)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl, EntryPoint = "git_libgit2_opts")]
        internal static extern int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, uint level, GitBuf buf);

        // git_libgit2_opts(GIT_OPT_SET_SEARCH_PATH, int level, const char *path)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl, EntryPoint = "git_libgit2_opts")]
        internal static extern int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, uint level,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        // git_libgit2_opts(GIT_OPT_ENABLE_*, int enabled)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl, EntryPoint = "git_libgit2_opts")]
        internal static extern int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, int enabled);

        // git_libgit2_opts(GIT_OPT_SET_USER_AGENT, const char *path)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl, EntryPoint = "git_libgit2_opts")]
        internal static extern int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        // git_libgit2_opts(GIT_OPT_GET_USER_AGENT, git_buf *buf)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl, EntryPoint = "git_libgit2_opts")]
        internal static extern int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, GitBuf buf);

        // git_libgit2_opts(GIT_OPT_SET_EXTENSIONS, const char **extensions, size_t len)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl, EntryPoint = "git_libgit2_opts")]
        internal static extern int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, IntPtr extensions, UIntPtr len);

        // git_libgit2_opts(GIT_OPT_GET_EXTENSIONS, git_strarray *out)
        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl, EntryPoint = "git_libgit2_opts")]
        internal static extern int git_libgit2_opts_osxarm64(int option, IntPtr nop2, IntPtr nop3, IntPtr nop4, IntPtr nop5, IntPtr nop6, IntPtr nop7, IntPtr nop8, out GitStrArray extensions);
        #endregion

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_graph_ahead_behind(out UIntPtr ahead, out UIntPtr behind, git_repository* repo, ref GitOid one, ref GitOid two);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_graph_descendant_of(
            git_repository* repo,
            ref GitOid commit,
            ref GitOid ancestor);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_ignore_add_rule(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string rules);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_ignore_clear_internal_rules(git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_ignore_path_is_ignored(
            out int ignored,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_add_bypath(
            git_index* index,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_add(
            git_index* index,
            git_index_entry* entry);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_conflict_get(
            out git_index_entry* ancestor,
            out git_index_entry* ours,
            out git_index_entry* theirs,
            git_index* index,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_conflict_iterator_new(
            out git_index_conflict_iterator* iterator,
            git_index* index);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_conflict_next(
            out git_index_entry* ancestor,
            out git_index_entry* ours,
            out git_index_entry* theirs,
            git_index_conflict_iterator* iterator);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_index_conflict_iterator_free(
            git_index_conflict_iterator* iterator);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UIntPtr git_index_entrycount(git_index* index);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_entry_stage(git_index_entry* indexentry);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_index_free(git_index* index);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_index_entry* git_index_get_byindex(git_index* index, UIntPtr n);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_index_entry* git_index_get_bypath(
            git_index* index,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path,
            int stage);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_has_conflicts(git_index* index);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UIntPtr git_index_name_entrycount(git_index* handle);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_index_name_entry* git_index_name_get_byindex(git_index* handle, UIntPtr n);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_open(
            out git_index* index,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath indexpath);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_read(
            git_index* index,
            [MarshalAs(UnmanagedType.Bool)] bool force);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_remove_bypath(
            git_index* index,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UIntPtr git_index_reuc_entrycount(git_index* handle);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_index_reuc_entry* git_index_reuc_get_byindex(git_index* handle, UIntPtr n);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_index_reuc_entry* git_index_reuc_get_bypath(
            git_index* handle,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_write(git_index* index);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_write_tree(out GitOid treeOid, git_index* index);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_write_tree_to(out GitOid treeOid, git_index* index, git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_read_tree(git_index* index, git_object* tree);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_index_clear(git_index* index);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_merge_base_many(
            out GitOid mergeBase,
            git_repository* repo,
            int length,
            [In] GitOid[] input_array);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_merge_base_octopus(
            out GitOid mergeBase,
            git_repository* repo,
            int length,
            [In] GitOid[] input_array);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_annotated_commit_from_ref(
            out git_annotated_commit* annotatedCommit,
            git_repository* repo,
            git_reference* reference);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_annotated_commit_from_fetchhead(
            out git_annotated_commit* annotatedCommit,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string branch_name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string remote_url,
            ref GitOid oid);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_annotated_commit_from_revspec(
            out git_annotated_commit* annotatedCommit,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string revspec);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_annotated_commit_lookup(
            out git_annotated_commit* annotatedCommit,
            git_repository* repo,
            ref GitOid id);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_annotated_commit_id(
            git_annotated_commit* annotatedCommit);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_merge(
            git_repository* repo,
            [In] IntPtr[] their_heads,
            UIntPtr their_heads_len,
            ref GitMergeOpts merge_opts,
            ref GitCheckoutOpts checkout_opts);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_merge_commits(
            out git_index* index,
            git_repository* repo,
            git_object* our_commit,
            git_object* their_commit,
            ref GitMergeOpts merge_opts);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_merge_analysis(
            out GitMergeAnalysis status_out,
            out GitMergePreference preference_out,
            git_repository* repo,
            [In] IntPtr[] their_heads,
            int their_heads_len);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_annotated_commit_free(git_annotated_commit* commit);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_message_prettify(
            GitBuf buf,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string message,
            [MarshalAs(UnmanagedType.Bool)] bool strip_comments,
            sbyte comment_char);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_note_create(
            out GitOid noteOid,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string notes_ref,
            git_signature* author,
            git_signature* committer,
            ref GitOid oid,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string note,
            int force);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_note_free(git_note* note);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_note_message(git_note* note);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_note_id(git_note* note);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_note_read(
            out git_note* note,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string notes_ref,
            ref GitOid oid);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_note_remove(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string notes_ref,
            git_signature* author,
            git_signature* committer,
            ref GitOid oid);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_note_default_ref(
            GitBuf notes_ref,
            git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_note_foreach_cb(
            ref GitOid blob_id,
            ref GitOid annotated_object_id,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_note_foreach(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string notes_ref,
            git_note_foreach_cb cb,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_odb_add_backend(git_odb* odb, IntPtr backend, int priority);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr git_odb_backend_data_alloc(IntPtr backend, UIntPtr len);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_odb_exists(git_odb* odb, ref GitOid id);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_odb_foreach_cb(
            IntPtr id,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_odb_foreach(
            git_odb* odb,
            git_odb_foreach_cb cb,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_odb_open_wstream(out git_odb_stream* stream, git_odb* odb, Int64 size, GitObjectType type);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_odb_free(git_odb* odb);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_odb_read_header(out UIntPtr len_out, out GitObjectType type, git_odb* odb, ref GitOid id);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_object_free(git_object* obj);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_odb_stream_write(git_odb_stream* Stream, IntPtr Buffer, UIntPtr len);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_odb_stream_finalize_write(out GitOid id, git_odb_stream* stream);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_odb_stream_free(git_odb_stream* stream);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_odb_write(out GitOid id, git_odb* odb, byte* data, UIntPtr len, GitObjectType type);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_object_id(git_object* obj);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_object_lookup(out git_object* obj, git_repository* repo, ref GitOid id, GitObjectType type);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_object_peel(
            out git_object* peeled,
            git_object* obj,
            GitObjectType type);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_object_short_id(
            GitBuf buf,
            git_object* obj);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe GitObjectType git_object_type(git_object* obj);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_patch_from_diff(out git_patch* patch, git_diff* diff, UIntPtr idx);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_patch_print(git_patch* patch, git_diff_line_cb print_cb, IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_patch_line_stats(
            out UIntPtr total_context,
            out UIntPtr total_additions,
            out UIntPtr total_deletions,
            git_patch* patch);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_patch_free(git_patch* patch);

        /* Push network progress notification function */
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_push_transfer_progress(uint current, uint total, UIntPtr bytes, IntPtr payload);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_packbuilder_progress(int stage, uint current, uint total, IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_packbuilder_free(git_packbuilder* packbuilder);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_packbuilder_insert(
            git_packbuilder* packbuilder,
            ref GitOid id,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_packbuilder_insert_commit(
            git_packbuilder* packbuilder,
            ref GitOid id);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_packbuilder_insert_recur(
            git_packbuilder* packbuilder,
            ref GitOid id,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_packbuilder_insert_tree(
            git_packbuilder* packbuilder,
            ref GitOid id);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_packbuilder_new(out git_packbuilder* packbuilder, git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UIntPtr git_packbuilder_object_count(git_packbuilder* packbuilder);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UInt32 git_packbuilder_set_threads(git_packbuilder* packbuilder, UInt32 numThreads);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_packbuilder_write(
            git_packbuilder* packbuilder,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path,
            uint mode,
            IntPtr progressCallback,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UIntPtr git_packbuilder_written(git_packbuilder* packbuilder);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reference_create(
            out git_reference* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            ref GitOid oid,
            [MarshalAs(UnmanagedType.Bool)] bool force,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string log_message);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reference_symbolic_create(
            out git_reference* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string target,
            [MarshalAs(UnmanagedType.Bool)] bool force,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string log_message);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int ref_glob_callback(
            IntPtr reference_name,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reference_foreach_glob(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string glob,
            ref_glob_callback callback,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_reference_free(git_reference* reference);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reference_name_is_valid(int* valid,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string refname);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reference_list(out GitStrArray array, git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reference_lookup(
            out git_reference* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_reference_name(git_reference* reference);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reference_remove(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_reference_target(git_reference* reference);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reference_rename(
            out git_reference* ref_out,
            git_reference* reference,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string newName,
            [MarshalAs(UnmanagedType.Bool)] bool force,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string log_message);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reference_set_target(
            out git_reference* ref_out,
            git_reference* reference,
            ref GitOid id,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string log_message);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reference_symbolic_set_target(
            out git_reference* ref_out,
            git_reference* reference,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string target,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string log_message);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_reference_symbolic_target(git_reference* reference);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe GitReferenceType git_reference_type(git_reference* reference);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reference_ensure_log(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string refname);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_reflog_free(git_reflog* reflog);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reflog_read(
            out git_reflog* ref_out,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UIntPtr git_reflog_entrycount
            (git_reflog* reflog);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_reflog_entry* git_reflog_entry_byindex(
            git_reflog* reflog,
            UIntPtr idx);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_reflog_entry_id_old(
            git_reflog_entry* entry);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_reflog_entry_id_new(
            git_reflog_entry* entry);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_signature* git_reflog_entry_committer(
            git_reflog_entry* entry);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_reflog_entry_message(git_reflog_entry* entry);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_refspec_transform(
            GitBuf buf,
            IntPtr refspec,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_refspec_rtransform(
            GitBuf buf,
            IntPtr refspec,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern string git_refspec_string(
            IntPtr refSpec);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern RefSpecDirection git_refspec_direction(IntPtr refSpec);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern string git_refspec_dst(
            IntPtr refSpec);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern string git_refspec_src(
            IntPtr refspec);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool git_refspec_force(IntPtr refSpec);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool git_refspec_src_matches(
            IntPtr refspec,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string reference);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern bool git_refspec_dst_matches(
            IntPtr refspec,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string reference);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_autotag(git_remote* remote);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_connect(
            git_remote* remote,
            GitDirection direction,
            ref GitRemoteCallbacks callbacks,
            ref GitProxyOptions proxy_options,
            ref GitStrArray custom_headers);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_create(
            out git_remote* remote,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_create_anonymous(
            out git_remote* remote,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_create_with_fetchspec(
            out git_remote* remote,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string refspec);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_delete(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_fetch(
            git_remote* remote,
            ref GitStrArray refspecs,
            GitFetchOptions fetch_opts,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string log_message);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_remote_free(git_remote* remote);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_get_fetch_refspecs(out GitStrArray array, git_remote* remote);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_refspec* git_remote_get_refspec(git_remote* remote, UIntPtr n);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_get_push_refspecs(out GitStrArray array, git_remote* remote);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_push(
            git_remote* remote,
            ref GitStrArray refSpecs,
            GitPushOptions opts);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UIntPtr git_remote_refspec_count(git_remote* remote);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_set_url(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string remote,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_add_fetch(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string remote,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_set_pushurl(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string remote,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_add_push(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string remote,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_name_is_valid(int* valid,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string remote_name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_list(out GitStrArray array, git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_lookup(
            out git_remote* remote,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_remote_ls(out git_remote_head** heads, out UIntPtr size, git_remote* remote);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_remote_name(git_remote* remote);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_remote_url(git_remote* remote);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_remote_pushurl(git_remote* remote);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_remote_set_autotag(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            TagFetchMode option);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int remote_progress_callback(IntPtr str, int len, IntPtr data);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int remote_completion_callback(RemoteCompletionType type, IntPtr data);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int remote_update_tips_callback(
            IntPtr refName,
            ref GitOid oldId,
            ref GitOid newId,
            IntPtr data);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int push_negotiation_callback(
            IntPtr updates,
            UIntPtr len,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int push_update_reference_callback(
            IntPtr refName,
            IntPtr status,
            IntPtr data
            );

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_repository_discover(
            GitBuf buf,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath start_path,
            [MarshalAs(UnmanagedType.Bool)] bool across_fs,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath ceiling_dirs);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_repository_fetchhead_foreach_cb(
            IntPtr remote_name,
            IntPtr remote_url,
            ref GitOid oid,
            [MarshalAs(UnmanagedType.Bool)] bool is_merge,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_fetchhead_foreach(
            git_repository* repo,
            git_repository_fetchhead_foreach_cb cb,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_repository_free(git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_repository_head_detached(IntPtr repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_repository_head_unborn(IntPtr repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_ident(
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))] out string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))] out string email,
            git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_index(out git_index* index, git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_init_ext(
            out git_repository* repository,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path,
            GitRepositoryInitOptions options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_repository_is_bare(IntPtr handle);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_repository_is_shallow(IntPtr repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_state_cleanup(git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_repository_mergehead_foreach_cb(
            ref GitOid oid,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_mergehead_foreach(
            git_repository* repo,
            git_repository_mergehead_foreach_cb cb,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_message(
            GitBuf buf,
            git_repository* repository);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_new(
            out git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_odb(out git_odb* odb, git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_open(
            out git_repository* repository,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_open_ext(
            out git_repository* repository,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path,
            RepositoryOpenFlags flags,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath ceilingDirs);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxFilePathNoCleanupMarshaler))]
        internal static extern unsafe FilePath git_repository_path(git_repository* repository);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_set_config(
            git_repository* repository,
            git_config* config);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_set_ident(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string email);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_set_index(
            git_repository* repository,
            git_index* index);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_set_workdir(
            git_repository* repository,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath workdir,
            [MarshalAs(UnmanagedType.Bool)] bool update_gitlink);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_set_head_detached(
            git_repository* repo,
            ref GitOid commitish);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_set_head_detached_from_annotated(
            git_repository* repo,
            git_annotated_commit* commit);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_set_head(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string refname);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_state(
            git_repository* repository);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxFilePathNoCleanupMarshaler))]
        internal static extern unsafe FilePath git_repository_workdir(git_repository* repository);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxFilePathNoCleanupMarshaler))]
        internal static extern FilePath git_repository_workdir(IntPtr repository);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_reset(
            git_repository* repo,
            git_object* target,
            ResetMode reset_type,
            ref GitCheckoutOpts opts);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_revert(
            git_repository* repo,
            git_object* commit,
            GitRevertOpts opts);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_revert_commit(
            out git_index* index,
            git_repository* repo,
            git_object* revert_commit,
            git_object* our_commit,
            uint mainline,
            ref GitMergeOpts opts);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_revparse_ext(
            out git_object* obj,
            out git_reference* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string spec);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_revwalk_free(git_revwalk* walker);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_revwalk_hide(git_revwalk* walker, ref GitOid commit_id);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_revwalk_new(out git_revwalk* walker, git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_revwalk_next(out GitOid id, git_revwalk* walker);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_revwalk_push(git_revwalk* walker, ref GitOid id);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_revwalk_reset(git_revwalk* walker);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_revwalk_sorting(git_revwalk* walk, CommitSortStrategies sort);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_revwalk_simplify_first_parent(git_revwalk* walk);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_signature_free(git_signature* signature);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_signature_new(
            out git_signature* signature,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string email,
            long time,
            int offset);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_signature_now(
            out git_signature* signature,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string email);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_signature_dup(out git_signature* dest, git_signature* sig);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_stash_save(
            out GitOid id,
            git_repository* repo,
            git_signature* stasher,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string message,
            StashModifiers flags);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_stash_cb(
            UIntPtr index,
            IntPtr message,
            ref GitOid stash_id,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_stash_foreach(
            git_repository* repo,
            git_stash_cb callback,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_stash_drop(git_repository* repo, UIntPtr index);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_stash_apply(
            git_repository* repo,
            UIntPtr index,
            GitStashApplyOpts opts);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_stash_pop(
            git_repository* repo,
            UIntPtr index,
            GitStashApplyOpts opts);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_status_file(
            out FileStatus statusflags,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath filepath);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_status_list_new(
            out git_status_list* git_status_list,
            git_repository* repo,
            GitStatusOptions options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_status_list_entrycount(
            git_status_list* statusList);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_status_entry* git_status_byindex(
            git_status_list* list,
            UIntPtr idx);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_status_list_free(
            git_status_list* statusList);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void git_strarray_dispose(
            ref GitStrArray array);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_submodule_lookup(
            out git_submodule* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_submodule_resolve_url(
            GitBuf buf,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_submodule_update(
            git_submodule* sm,
            [MarshalAs(UnmanagedType.Bool)] bool init,
            ref GitSubmoduleUpdateOptions submoduleUpdateOptions);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int submodule_callback(
            IntPtr sm,
            IntPtr name,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_submodule_foreach(
            git_repository* repo,
            submodule_callback callback,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_submodule_add_to_index(
            git_submodule* submodule,
            [MarshalAs(UnmanagedType.Bool)] bool write_index);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_submodule_free(git_submodule* submodule);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_submodule_path(
            git_submodule* submodule);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_submodule_url(
            git_submodule* submodule);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_submodule_index_id(
            git_submodule* submodule);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_submodule_head_id(
            git_submodule* submodule);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_submodule_wd_id(
            git_submodule* submodule);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe SubmoduleIgnore git_submodule_ignore(
            git_submodule* submodule);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe SubmoduleUpdate git_submodule_update_strategy(
            git_submodule* submodule);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe SubmoduleRecurse git_submodule_fetch_recurse_submodules(
            git_submodule* submodule);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_submodule_reload(
            git_submodule* submodule,
            [MarshalAs(UnmanagedType.Bool)] bool force);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_submodule_status(
            out SubmoduleStatus status,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath name,
            GitSubmoduleIgnore ignore);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_submodule_init(
            git_submodule* submodule,
            [MarshalAs(UnmanagedType.Bool)] bool overwrite);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_tag_annotation_create(
            out GitOid oid,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            git_object* target,
            git_signature* signature,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string message);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_tag_create(
            out GitOid oid,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            git_object* target,
            git_signature* signature,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string message,
            [MarshalAs(UnmanagedType.Bool)]
            bool force);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_tag_create_lightweight(
            out GitOid oid,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            git_object* target,
            [MarshalAs(UnmanagedType.Bool)]
            bool force);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_tag_delete(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string tagName);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_tag_list(out GitStrArray array, git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_tag_message(git_object* tag);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_tag_name(git_object* tag);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_signature* git_tag_tagger(git_object* tag);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_tag_target_id(git_object* tag);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe GitObjectType git_tag_target_type(git_object* tag);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_libgit2_init();

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_libgit2_shutdown();

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_openssl_set_locking();

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void git_trace_cb(LogLevel level, IntPtr message);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_trace_set(LogLevel level, git_trace_cb trace_cb);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_transfer_progress_callback(ref GitTransferProgress stats, IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_transport_cb(out IntPtr transport, IntPtr remote, IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int git_transport_certificate_check_cb(git_certificate* cert, int valid, IntPtr hostname, IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_transport_register(
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string prefix,
            IntPtr transport_cb,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_transport_smart(
            out IntPtr transport,
            IntPtr remote,
            IntPtr definition);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_transport_smart_certificate_check(
            IntPtr transport,
            IntPtr cert,
            int valid,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string hostname);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_transport_smart_credentials(
            out IntPtr cred_out,
            IntPtr transport,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string user,
            int methods);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_transport_unregister(
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string prefix);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe uint git_tree_entry_filemode(git_tree_entry* entry);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_tree_entry* git_tree_entry_byindex(git_object* tree, UIntPtr idx);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_tree_entry_bypath(
            out git_tree_entry* tree,
            git_object* root,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string treeentry_path);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_tree_entry_free(git_tree_entry* treeEntry);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe git_oid* git_tree_entry_id(git_tree_entry* entry);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal static extern unsafe string git_tree_entry_name(git_tree_entry* entry);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe GitObjectType git_tree_entry_type(git_tree_entry* entry);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe UIntPtr git_tree_entrycount(git_object* tree);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_treebuilder_new(out git_treebuilder* builder, git_repository* repo, IntPtr src);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_treebuilder_insert(
            IntPtr entry_out,
            git_treebuilder* builder,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string treeentry_name,
            ref GitOid id,
            uint attributes);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_treebuilder_write(out GitOid id, git_treebuilder* bld);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_treebuilder_free(git_treebuilder* bld);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_blob_is_binary(git_object* blob);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_cherrypick(git_repository* repo, git_object* commit, GitCherryPickOptions options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_cherrypick_commit(out git_index* index,
            git_repository* repo,
            git_object* cherrypick_commit,
            git_object* our_commit,
            uint mainline,
            ref GitMergeOpts options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int git_transaction_commit(IntPtr txn);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void git_transaction_free(IntPtr txn);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int url_resolve_callback(
            IntPtr url_resolved,
            IntPtr url,
            int direction,
            IntPtr payload);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void git_worktree_free(git_worktree* worktree);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_worktree_lookup(
            out git_worktree* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_worktree_list(
            out GitStrArray array,
            git_repository* repo);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_repository_open_from_worktree(
            out git_repository* repository,
            git_worktree* worktree);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_worktree_is_locked(
            GitBuf reason,
            git_worktree* worktree);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_worktree_validate(
            git_worktree* worktree);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_worktree_lock(
            git_worktree* worktree,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string reason);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_worktree_unlock(
            git_worktree* worktree);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_worktree_add(
            out git_worktree* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path,
            git_worktree_add_options options);

        [DllImport(libgit2, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe int git_worktree_prune(
            git_worktree* worktree,
            git_worktree_prune_options options);
#endregion
    }
#else // with LIBGIT2_USE_INTERNAL_DLL

    internal static class NativeMethods
    {
        private static DLLFromMemory MemModule;

        #region delegate variables
        static internal Delegate_git_annotated_commit_free git_annotated_commit_free;
        static internal Delegate_git_annotated_commit_from_fetchhead git_annotated_commit_from_fetchhead;
        static internal Delegate_git_annotated_commit_from_ref git_annotated_commit_from_ref;
        static internal Delegate_git_annotated_commit_from_revspec git_annotated_commit_from_revspec;
        static internal Delegate_git_annotated_commit_id git_annotated_commit_id;
        static internal Delegate_git_annotated_commit_lookup git_annotated_commit_lookup;
        static internal Delegate_git_blame_file git_blame_file;
        static internal Delegate_git_blame_free git_blame_free;
        static internal Delegate_git_blame_get_hunk_byindex git_blame_get_hunk_byindex;
        static internal Delegate_git_blame_get_hunk_count git_blame_get_hunk_count;
        static internal Delegate_git_blob_create_from_disk git_blob_create_from_disk;
        static internal Delegate_git_blob_create_from_stream git_blob_create_from_stream;
        static internal Delegate_git_blob_create_from_stream_commit git_blob_create_from_stream_commit;
        static internal Delegate_git_blob_create_from_workdir git_blob_create_from_workdir;
        #if LIBGIT2_HAVE_DEPRECATE
        static internal Delegate_git_blob_filtered_content git_blob_filtered_content;
        #endif
        static internal Delegate_git_blob_is_binary git_blob_is_binary;
        static internal Delegate_git_blob_rawcontent git_blob_rawcontent;
        static internal Delegate_git_blob_rawsize git_blob_rawsize;
        static internal Delegate_git_branch_create_from_annotated git_branch_create_from_annotated;
        static internal Delegate_git_branch_delete git_branch_delete;
        static internal Delegate_git_branch_iterator_free git_branch_iterator_free;
        static internal Delegate_git_branch_iterator_new git_branch_iterator_new;
        static internal Delegate_git_branch_move git_branch_move;
        static internal Delegate_git_branch_next git_branch_next;
        static internal Delegate_git_branch_remote_name git_branch_remote_name;
        static internal Delegate_git_branch_upstream_name git_branch_upstream_name;
        static internal Delegate_git_buf_dispose git_buf_dispose;
        static internal Delegate_git_checkout_index git_checkout_index;
        static internal Delegate_git_checkout_tree git_checkout_tree;
        static internal Delegate_git_cherrypick git_cherrypick;
        static internal Delegate_git_cherrypick_commit git_cherrypick_commit;
        static internal Delegate_git_clone git_clone;
        static internal Delegate_git_commit_author git_commit_author;
        static internal Delegate_git_commit_committer git_commit_committer;
        static internal Delegate_git_commit_create_buffer git_commit_create_buffer;
        static internal Delegate_git_commit_create_from_ids git_commit_create_from_ids;
        static internal Delegate_git_commit_create_with_signature git_commit_create_with_signature;
        static internal Delegate_git_commit_extract_signature git_commit_extract_signature;
        static internal Delegate_git_commit_message git_commit_message;
        static internal Delegate_git_commit_message_encoding git_commit_message_encoding;
        static internal Delegate_git_commit_parent_id git_commit_parent_id;
        static internal Delegate_git_commit_parentcount git_commit_parentcount;
        static internal Delegate_git_commit_summary git_commit_summary;
        static internal Delegate_git_commit_tree_id git_commit_tree_id;
        static internal Delegate_git_config_add_file_ondisk git_config_add_file_ondisk;
        static internal Delegate_git_config_delete_entry git_config_delete_entry;
        static internal Delegate_git_config_delete_multivar git_config_delete_multivar;
        static internal Delegate_git_config_entry_free git_config_entry_free;
        static internal Delegate_git_config_find__Any git_config_find_global;
        static internal Delegate_git_config_find__Any git_config_find_programdata;
        static internal Delegate_git_config_find__Any git_config_find_system;
        static internal Delegate_git_config_find__Any git_config_find_xdg;
        static internal Delegate_git_config_foreach git_config_foreach;
        static internal Delegate_git_config_free git_config_free;
        static internal Delegate_git_config_get_entry git_config_get_entry;
        static internal Delegate_git_config_iterator_free git_config_iterator_free;
        static internal Delegate_git_config_iterator_glob_new git_config_iterator_glob_new;
        static internal Delegate_git_config_lock git_config_lock;
        static internal Delegate_git_config_new git_config_new;
        static internal Delegate_git_config_next git_config_next;
        static internal Delegate_git_config_open_level git_config_open_level;
        static internal Delegate_git_config_parse_bool git_config_parse_bool;
        static internal Delegate_git_config_parse_int32 git_config_parse_int32;
        static internal Delegate_git_config_parse_int64 git_config_parse_int64;
        static internal Delegate_git_config_set_bool git_config_set_bool;
        static internal Delegate_git_config_set_int32 git_config_set_int32;
        static internal Delegate_git_config_set_int64 git_config_set_int64;
        static internal Delegate_git_config_set_multivar git_config_set_multivar;
        static internal Delegate_git_config_set_string git_config_set_string;
        static internal Delegate_git_config_snapshot git_config_snapshot;
        static internal Delegate_git_credential_default_new git_credential_default_new;
        static internal Delegate_git_credential_free git_credential_free;
        static internal Delegate_git_credential_userpass_plaintext_new git_credential_userpass_plaintext_new;
        static internal Delegate_git_describe_commit git_describe_commit;
        static internal Delegate_git_describe_format git_describe_format;
        static internal Delegate_git_describe_result_free git_describe_result_free;
        static internal Delegate_git_diff_blobs git_diff_blobs;
        static internal Delegate_git_diff_find_similar git_diff_find_similar;
        static internal Delegate_git_diff_foreach git_diff_foreach;
        static internal Delegate_git_diff_free git_diff_free;
        static internal Delegate_git_diff_get_delta git_diff_get_delta;
        static internal Delegate_git_diff_index_to_workdir git_diff_index_to_workdir;
        static internal Delegate_git_diff_merge git_diff_merge;
        static internal Delegate_git_diff_num_deltas git_diff_num_deltas;
        static internal Delegate_git_diff_tree_to_index git_diff_tree_to_index;
        static internal Delegate_git_diff_tree_to_tree git_diff_tree_to_tree;
        static internal Delegate_git_diff_tree_to_workdir git_diff_tree_to_workdir;
        static internal Delegate_git_error_last git_error_last;
        static internal Delegate_git_error_set_oom git_error_set_oom;
        static internal Delegate_git_error_set_str git_error_set_str;
        static internal Delegate_git_filter_register git_filter_register;
        static internal Delegate_git_filter_source_mode git_filter_source_mode;
        static internal Delegate_git_filter_unregister git_filter_unregister;
        static internal Delegate_git_graph_ahead_behind git_graph_ahead_behind;
        static internal Delegate_git_graph_descendant_of git_graph_descendant_of;
        static internal Delegate_git_ignore_add_rule git_ignore_add_rule;
        static internal Delegate_git_ignore_clear_internal_rules git_ignore_clear_internal_rules;
        static internal Delegate_git_ignore_path_is_ignored git_ignore_path_is_ignored;
        static internal Delegate_git_index_add git_index_add;
        static internal Delegate_git_index_add_bypath git_index_add_bypath;
        static internal Delegate_git_index_clear git_index_clear;
        static internal Delegate_git_index_conflict_get git_index_conflict_get;
        static internal Delegate_git_index_conflict_iterator_free git_index_conflict_iterator_free;
        static internal Delegate_git_index_conflict_iterator_new git_index_conflict_iterator_new;
        static internal Delegate_git_index_conflict_next git_index_conflict_next;
        static internal Delegate_git_index_entry_stage git_index_entry_stage;
        static internal Delegate_git_index_entrycount git_index_entrycount;
        static internal Delegate_git_index_free git_index_free;
        static internal Delegate_git_index_get_byindex git_index_get_byindex;
        static internal Delegate_git_index_get_bypath git_index_get_bypath;
        static internal Delegate_git_index_has_conflicts git_index_has_conflicts;
        static internal Delegate_git_index_name_entrycount git_index_name_entrycount;
        static internal Delegate_git_index_name_get_byindex git_index_name_get_byindex;
        static internal Delegate_git_index_open git_index_open;
        static internal Delegate_git_index_read git_index_read;
        static internal Delegate_git_index_read_tree git_index_read_tree;
        static internal Delegate_git_index_remove_bypath git_index_remove_bypath;
        static internal Delegate_git_index_reuc_entrycount git_index_reuc_entrycount;
        static internal Delegate_git_index_reuc_get_byindex git_index_reuc_get_byindex;
        static internal Delegate_git_index_reuc_get_bypath git_index_reuc_get_bypath;
        static internal Delegate_git_index_write git_index_write;
        static internal Delegate_git_index_write_tree git_index_write_tree;
        static internal Delegate_git_index_write_tree_to git_index_write_tree_to;
        static internal Delegate_git_libgit2_features git_libgit2_features;
        static internal Delegate_git_libgit2_init git_libgit2_init;
        static internal Delegate_git_libgit2_opts__1 git_libgit2_opts__1;
        static internal Delegate_git_libgit2_opts__2 git_libgit2_opts__2;
        static internal Delegate_git_libgit2_opts__3 git_libgit2_opts__3;
        static internal Delegate_git_libgit2_opts__4 git_libgit2_opts__4;
        static internal Delegate_git_libgit2_opts__5 git_libgit2_opts__5;
        static internal Delegate_git_libgit2_opts__6 git_libgit2_opts__6;
        static internal Delegate_git_libgit2_opts__7 git_libgit2_opts__7;
        static internal Delegate_git_libgit2_shutdown git_libgit2_shutdown;
        static internal Delegate_git_merge git_merge;
        static internal Delegate_git_merge_analysis git_merge_analysis;
        static internal Delegate_git_merge_base_many git_merge_base_many;
        static internal Delegate_git_merge_base_octopus git_merge_base_octopus;
        static internal Delegate_git_merge_commits git_merge_commits;
        static internal Delegate_git_message_prettify git_message_prettify;
        static internal Delegate_git_note_create git_note_create;
        static internal Delegate_git_note_default_ref git_note_default_ref;
        static internal Delegate_git_note_foreach git_note_foreach;
        static internal Delegate_git_note_free git_note_free;
        static internal Delegate_git_note_id git_note_id;
        static internal Delegate_git_note_message git_note_message;
        static internal Delegate_git_note_read git_note_read;
        static internal Delegate_git_note_remove git_note_remove;
        static internal Delegate_git_object_free git_object_free;
        static internal Delegate_git_object_id git_object_id;
        static internal Delegate_git_object_lookup git_object_lookup;
        static internal Delegate_git_object_peel git_object_peel;
        static internal Delegate_git_object_short_id git_object_short_id;
        static internal Delegate_git_object_type git_object_type;
        static internal Delegate_git_odb_add_backend git_odb_add_backend;
        static internal Delegate_git_odb_backend_data_alloc git_odb_backend_data_alloc;
        static internal Delegate_git_odb_exists git_odb_exists;
        static internal Delegate_git_odb_foreach git_odb_foreach;
        static internal Delegate_git_odb_free git_odb_free;
        static internal Delegate_git_odb_open_wstream git_odb_open_wstream;
        static internal Delegate_git_odb_read_header git_odb_read_header;
        static internal Delegate_git_odb_stream_finalize_write git_odb_stream_finalize_write;
        static internal Delegate_git_odb_stream_free git_odb_stream_free;
        static internal Delegate_git_odb_stream_write git_odb_stream_write;
        static internal Delegate_git_odb_write git_odb_write;
        static internal Delegate_git_openssl_set_locking git_openssl_set_locking;
        static internal Delegate_git_packbuilder_free git_packbuilder_free;
        static internal Delegate_git_packbuilder_insert git_packbuilder_insert;
        static internal Delegate_git_packbuilder_insert_commit git_packbuilder_insert_commit;
        static internal Delegate_git_packbuilder_insert_recur git_packbuilder_insert_recur;
        static internal Delegate_git_packbuilder_insert_tree git_packbuilder_insert_tree;
        static internal Delegate_git_packbuilder_new git_packbuilder_new;
        static internal Delegate_git_packbuilder_object_count git_packbuilder_object_count;
        static internal Delegate_git_packbuilder_set_threads git_packbuilder_set_threads;
        static internal Delegate_git_packbuilder_write git_packbuilder_write;
        static internal Delegate_git_packbuilder_written git_packbuilder_written;
        static internal Delegate_git_patch_free git_patch_free;
        static internal Delegate_git_patch_from_diff git_patch_from_diff;
        static internal Delegate_git_patch_line_stats git_patch_line_stats;
        static internal Delegate_git_patch_print git_patch_print;
        static internal Delegate_git_rebase_abort git_rebase_abort;
        static internal Delegate_git_rebase_commit git_rebase_commit;
        static internal Delegate_git_rebase_finish git_rebase_finish;
        static internal Delegate_git_rebase_free git_rebase_free;
        static internal Delegate_git_rebase_init git_rebase_init;
        static internal Delegate_git_rebase_next git_rebase_next;
        static internal Delegate_git_rebase_open git_rebase_open;
        static internal Delegate_git_rebase_operation_byindex git_rebase_operation_byindex;
        static internal Delegate_git_rebase_operation_current git_rebase_operation_current;
        static internal Delegate_git_rebase_operation_entrycount git_rebase_operation_entrycount;
        static internal Delegate_git_reference_create git_reference_create;
        static internal Delegate_git_reference_ensure_log git_reference_ensure_log;
        static internal Delegate_git_reference_foreach_glob git_reference_foreach_glob;
        static internal Delegate_git_reference_free git_reference_free;
        static internal Delegate_git_reference_name_is_valid git_reference_name_is_valid;
        static internal Delegate_git_reference_list git_reference_list;
        static internal Delegate_git_reference_lookup git_reference_lookup;
        static internal Delegate_git_reference_name git_reference_name;
        static internal Delegate_git_reference_remove git_reference_remove;
        static internal Delegate_git_reference_rename git_reference_rename;
        static internal Delegate_git_reference_set_target git_reference_set_target;
        static internal Delegate_git_reference_symbolic_create git_reference_symbolic_create;
        static internal Delegate_git_reference_symbolic_set_target git_reference_symbolic_set_target;
        static internal Delegate_git_reference_symbolic_target git_reference_symbolic_target;
        static internal Delegate_git_reference_target git_reference_target;
        static internal Delegate_git_reference_type git_reference_type;
        static internal Delegate_git_reflog_entry_byindex git_reflog_entry_byindex;
        static internal Delegate_git_reflog_entry_committer git_reflog_entry_committer;
        static internal Delegate_git_reflog_entry_id_new git_reflog_entry_id_new;
        static internal Delegate_git_reflog_entry_id_old git_reflog_entry_id_old;
        static internal Delegate_git_reflog_entry_message git_reflog_entry_message;
        static internal Delegate_git_reflog_entrycount git_reflog_entrycount;
        static internal Delegate_git_reflog_free git_reflog_free;
        static internal Delegate_git_reflog_read git_reflog_read;
        static internal Delegate_git_refspec_direction git_refspec_direction;
        static internal Delegate_git_refspec_dst git_refspec_dst;
        static internal Delegate_git_refspec_dst_matches git_refspec_dst_matches;
        static internal Delegate_git_refspec_force git_refspec_force;
        static internal Delegate_git_refspec_rtransform git_refspec_rtransform;
        static internal Delegate_git_refspec_src git_refspec_src;
        static internal Delegate_git_refspec_src_matches git_refspec_src_matches;
        static internal Delegate_git_refspec_string git_refspec_string;
        static internal Delegate_git_refspec_transform git_refspec_transform;
        static internal Delegate_git_remote_add_fetch git_remote_add_fetch;
        static internal Delegate_git_remote_add_push git_remote_add_push;
        static internal Delegate_git_remote_autotag git_remote_autotag;
        static internal Delegate_git_remote_connect git_remote_connect;
        static internal Delegate_git_remote_create git_remote_create;
        static internal Delegate_git_remote_create_anonymous git_remote_create_anonymous;
        static internal Delegate_git_remote_create_with_fetchspec git_remote_create_with_fetchspec;
        static internal Delegate_git_remote_delete git_remote_delete;
        static internal Delegate_git_remote_fetch git_remote_fetch;
        static internal Delegate_git_remote_free git_remote_free;
        static internal Delegate_git_remote_get_fetch_refspecs git_remote_get_fetch_refspecs;
        static internal Delegate_git_remote_get_push_refspecs git_remote_get_push_refspecs;
        static internal Delegate_git_remote_get_refspec git_remote_get_refspec;
        static internal Delegate_git_remote_name_is_valid git_remote_name_is_valid;
        static internal Delegate_git_remote_list git_remote_list;
        static internal Delegate_git_remote_lookup git_remote_lookup;
        static internal Delegate_git_remote_ls git_remote_ls;
        static internal Delegate_git_remote_name git_remote_name;
        static internal Delegate_git_remote_push git_remote_push;
        static internal Delegate_git_remote_pushurl git_remote_pushurl;
        static internal Delegate_git_remote_refspec_count git_remote_refspec_count;
        static internal Delegate_git_remote_rename git_remote_rename;
        static internal Delegate_git_remote_set_autotag git_remote_set_autotag;
        static internal Delegate_git_remote_set_pushurl git_remote_set_pushurl;
        static internal Delegate_git_remote_set_url git_remote_set_url;
        static internal Delegate_git_remote_url git_remote_url;
        static internal Delegate_git_repository_discover git_repository_discover;
        static internal Delegate_git_repository_fetchhead_foreach git_repository_fetchhead_foreach;
        static internal Delegate_git_repository_free git_repository_free;
        static internal Delegate_git_repository__GetInt git_repository_head_detached;
        static internal Delegate_git_repository__GetInt git_repository_head_unborn;
        static internal Delegate_git_repository_ident git_repository_ident;
        static internal Delegate_git_repository_index git_repository_index;
        static internal Delegate_git_repository_init_ext git_repository_init_ext;
        static internal Delegate_git_repository__GetInt git_repository_is_bare;
        static internal Delegate_git_repository__GetInt git_repository_is_shallow;
        static internal Delegate_git_repository_mergehead_foreach git_repository_mergehead_foreach;
        static internal Delegate_git_repository_message git_repository_message;
        static internal Delegate_git_repository_new git_repository_new;
        static internal Delegate_git_repository_odb git_repository_odb;
        static internal Delegate_git_repository_open git_repository_open;
        static internal Delegate_git_repository_open_ext git_repository_open_ext;
        static internal Delegate_git_repository_open_from_worktree git_repository_open_from_worktree;
        static internal Delegate_git_repository_path git_repository_path;
        static internal Delegate_git_repository_set_config git_repository_set_config;
        static internal Delegate_git_repository_set_head git_repository_set_head;
        static internal Delegate_git_repository_set_head_detached git_repository_set_head_detached;
        static internal Delegate_git_repository_set_head_detached_from_annotated git_repository_set_head_detached_from_annotated;
        static internal Delegate_git_repository_set_ident git_repository_set_ident;
        static internal Delegate_git_repository_set_index git_repository_set_index;
        static internal Delegate_git_repository_set_workdir git_repository_set_workdir;
        static internal Delegate_git_repository_state git_repository_state;
        static internal Delegate_git_repository_state_cleanup git_repository_state_cleanup;
        static internal Delegate_git_repository_workdir__1 git_repository_workdir__1;
        static internal Delegate_git_repository_workdir__2 git_repository_workdir__2;
        static internal Delegate_git_reset git_reset;
        static internal Delegate_git_revert git_revert;
        static internal Delegate_git_revert_commit git_revert_commit;
        static internal Delegate_git_revparse_ext git_revparse_ext;
        static internal Delegate_git_revwalk_free git_revwalk_free;
        static internal Delegate_git_revwalk_hide git_revwalk_hide;
        static internal Delegate_git_revwalk_new git_revwalk_new;
        static internal Delegate_git_revwalk_next git_revwalk_next;
        static internal Delegate_git_revwalk_push git_revwalk_push;
        static internal Delegate_git_revwalk_reset git_revwalk_reset;
        static internal Delegate_git_revwalk_simplify_first_parent git_revwalk_simplify_first_parent;
        static internal Delegate_git_revwalk_sorting git_revwalk_sorting;
        static internal Delegate_git_signature_dup git_signature_dup;
        static internal Delegate_git_signature_free git_signature_free;
        static internal Delegate_git_signature_new git_signature_new;
        static internal Delegate_git_signature_now git_signature_now;
        static internal Delegate_git_stash_apply git_stash_apply;
        static internal Delegate_git_stash_drop git_stash_drop;
        static internal Delegate_git_stash_foreach git_stash_foreach;
        static internal Delegate_git_stash_pop git_stash_pop;
        static internal Delegate_git_stash_save git_stash_save;
        static internal Delegate_git_status_byindex git_status_byindex;
        static internal Delegate_git_status_file git_status_file;
        static internal Delegate_git_status_list_entrycount git_status_list_entrycount;
        static internal Delegate_git_status_list_free git_status_list_free;
        static internal Delegate_git_status_list_new git_status_list_new;
        static internal Delegate_git_strarray_dispose git_strarray_dispose;
        static internal Delegate_git_submodule_add_to_index git_submodule_add_to_index;
        static internal Delegate_git_submodule_fetch_recurse_submodules git_submodule_fetch_recurse_submodules;
        static internal Delegate_git_submodule_foreach git_submodule_foreach;
        static internal Delegate_git_submodule_free git_submodule_free;
        static internal Delegate_git_submodule_head_id git_submodule_head_id;
        static internal Delegate_git_submodule_ignore git_submodule_ignore;
        static internal Delegate_git_submodule_index_id git_submodule_index_id;
        static internal Delegate_git_submodule_init git_submodule_init;
        static internal Delegate_git_submodule_lookup git_submodule_lookup;
        static internal Delegate_git_submodule_path git_submodule_path;
        static internal Delegate_git_submodule_reload git_submodule_reload;
        static internal Delegate_git_submodule_resolve_url git_submodule_resolve_url;
        static internal Delegate_git_submodule_status git_submodule_status;
        static internal Delegate_git_submodule_update git_submodule_update;
        static internal Delegate_git_submodule_update_strategy git_submodule_update_strategy;
        static internal Delegate_git_submodule_url git_submodule_url;
        static internal Delegate_git_submodule_wd_id git_submodule_wd_id;
        static internal Delegate_git_tag_annotation_create git_tag_annotation_create;
        static internal Delegate_git_tag_create git_tag_create;
        static internal Delegate_git_tag_create_lightweight git_tag_create_lightweight;
        static internal Delegate_git_tag_delete git_tag_delete;
        static internal Delegate_git_tag_list git_tag_list;
        static internal Delegate_git_tag_message git_tag_message;
        static internal Delegate_git_tag_name git_tag_name;
        static internal Delegate_git_tag_tagger git_tag_tagger;
        static internal Delegate_git_tag_target_id git_tag_target_id;
        static internal Delegate_git_tag_target_type git_tag_target_type;
        static internal Delegate_git_trace_set git_trace_set;
        static internal Delegate_git_transaction_commit git_transaction_commit;
        static internal Delegate_git_transaction_free git_transaction_free;
        static internal Delegate_git_transport_register git_transport_register;
        static internal Delegate_git_transport_smart git_transport_smart;
        static internal Delegate_git_transport_smart_certificate_check git_transport_smart_certificate_check;
        static internal Delegate_git_transport_smart_credentials git_transport_smart_credentials;
        static internal Delegate_git_transport_unregister git_transport_unregister;
        static internal Delegate_git_tree_entry_byindex git_tree_entry_byindex;
        static internal Delegate_git_tree_entry_bypath git_tree_entry_bypath;
        static internal Delegate_git_tree_entry_filemode git_tree_entry_filemode;
        static internal Delegate_git_tree_entry_free git_tree_entry_free;
        static internal Delegate_git_tree_entry_id git_tree_entry_id;
        static internal Delegate_git_tree_entry_name git_tree_entry_name;
        static internal Delegate_git_tree_entry_type git_tree_entry_type;
        static internal Delegate_git_tree_entrycount git_tree_entrycount;
        static internal Delegate_git_treebuilder_free git_treebuilder_free;
        static internal Delegate_git_treebuilder_insert git_treebuilder_insert;
        static internal Delegate_git_treebuilder_new git_treebuilder_new;
        static internal Delegate_git_treebuilder_write git_treebuilder_write;
        static internal Delegate_git_worktree_add git_worktree_add;
        static internal Delegate_git_worktree_free git_worktree_free;
        static internal Delegate_git_worktree_is_locked git_worktree_is_locked;
        static internal Delegate_git_worktree_list git_worktree_list;
        static internal Delegate_git_worktree_lock git_worktree_lock;
        static internal Delegate_git_worktree_lookup git_worktree_lookup;
        static internal Delegate_git_worktree_prune git_worktree_prune;
        static internal Delegate_git_worktree_unlock git_worktree_unlock;
        static internal Delegate_git_worktree_validate git_worktree_validate;
        #endregion

        static NativeMethods()
        {
            #if PLATFORM_x64
            byte[] bufDLL = new byte[515584], bufComp = (byte[])(new System.Resources.ResourceManager("CozyGit.LibGit2x64", typeof(NativeMethods).Assembly)).GetObject("dll");
            #elif PLATFORM_x86
            byte[] bufDLL = new byte[430592], bufComp = (byte[])(new System.Resources.ResourceManager("CozyGit.LibGit2x86", typeof(NativeMethods).Assembly)).GetObject("dll");
            #else
            #error Unknown platform
            #endif
            using (System.IO.MemoryStream ms = new System.IO.MemoryStream(bufComp, false))
                using (System.IO.Compression.DeflateStream ds = new System.IO.Compression.DeflateStream(ms, System.IO.Compression.CompressionMode.Decompress, false))
                    ds.Read(bufDLL, 0, bufDLL.Length);

            MemModule = new DLLFromMemory(bufDLL);

            #region query delegates
            git_annotated_commit_free = MemModule.GetDelegateFromFuncName<Delegate_git_annotated_commit_free>("git_annotated_commit_free");
            git_annotated_commit_from_fetchhead = MemModule.GetDelegateFromFuncName<Delegate_git_annotated_commit_from_fetchhead>("git_annotated_commit_from_fetchhead");
            git_annotated_commit_from_ref = MemModule.GetDelegateFromFuncName<Delegate_git_annotated_commit_from_ref>("git_annotated_commit_from_ref");
            git_annotated_commit_from_revspec = MemModule.GetDelegateFromFuncName<Delegate_git_annotated_commit_from_revspec>("git_annotated_commit_from_revspec");
            git_annotated_commit_id = MemModule.GetDelegateFromFuncName<Delegate_git_annotated_commit_id>("git_annotated_commit_id");
            git_annotated_commit_lookup = MemModule.GetDelegateFromFuncName<Delegate_git_annotated_commit_lookup>("git_annotated_commit_lookup");
            git_blame_file = MemModule.GetDelegateFromFuncName<Delegate_git_blame_file>("git_blame_file");
            git_blame_free = MemModule.GetDelegateFromFuncName<Delegate_git_blame_free>("git_blame_free");
            git_blame_get_hunk_byindex = MemModule.GetDelegateFromFuncName<Delegate_git_blame_get_hunk_byindex>("git_blame_get_hunk_byindex");
            git_blame_get_hunk_count = MemModule.GetDelegateFromFuncName<Delegate_git_blame_get_hunk_count>("git_blame_get_hunk_count");
            git_blob_create_from_disk = MemModule.GetDelegateFromFuncName<Delegate_git_blob_create_from_disk>("git_blob_create_from_disk");
            git_blob_create_from_stream = MemModule.GetDelegateFromFuncName<Delegate_git_blob_create_from_stream>("git_blob_create_from_stream");
            git_blob_create_from_stream_commit = MemModule.GetDelegateFromFuncName<Delegate_git_blob_create_from_stream_commit>("git_blob_create_from_stream_commit");
            git_blob_create_from_workdir = MemModule.GetDelegateFromFuncName<Delegate_git_blob_create_from_workdir>("git_blob_create_from_workdir");
            #if LIBGIT2_HAVE_DEPRECATE
            git_blob_filtered_content = MemModule.GetDelegateFromFuncName<Delegate_git_blob_filtered_content>("git_blob_filtered_content");
            #endif
            git_blob_is_binary = MemModule.GetDelegateFromFuncName<Delegate_git_blob_is_binary>("git_blob_is_binary");
            git_blob_rawcontent = MemModule.GetDelegateFromFuncName<Delegate_git_blob_rawcontent>("git_blob_rawcontent");
            git_blob_rawsize = MemModule.GetDelegateFromFuncName<Delegate_git_blob_rawsize>("git_blob_rawsize");
            git_branch_create_from_annotated = MemModule.GetDelegateFromFuncName<Delegate_git_branch_create_from_annotated>("git_branch_create_from_annotated");
            git_branch_delete = MemModule.GetDelegateFromFuncName<Delegate_git_branch_delete>("git_branch_delete");
            git_branch_iterator_free = MemModule.GetDelegateFromFuncName<Delegate_git_branch_iterator_free>("git_branch_iterator_free");
            git_branch_iterator_new = MemModule.GetDelegateFromFuncName<Delegate_git_branch_iterator_new>("git_branch_iterator_new");
            git_branch_move = MemModule.GetDelegateFromFuncName<Delegate_git_branch_move>("git_branch_move");
            git_branch_next = MemModule.GetDelegateFromFuncName<Delegate_git_branch_next>("git_branch_next");
            git_branch_remote_name = MemModule.GetDelegateFromFuncName<Delegate_git_branch_remote_name>("git_branch_remote_name");
            git_branch_upstream_name = MemModule.GetDelegateFromFuncName<Delegate_git_branch_upstream_name>("git_branch_upstream_name");
            git_buf_dispose = MemModule.GetDelegateFromFuncName<Delegate_git_buf_dispose>("git_buf_dispose");
            git_checkout_index = MemModule.GetDelegateFromFuncName<Delegate_git_checkout_index>("git_checkout_index");
            git_checkout_tree = MemModule.GetDelegateFromFuncName<Delegate_git_checkout_tree>("git_checkout_tree");
            git_cherrypick = MemModule.GetDelegateFromFuncName<Delegate_git_cherrypick>("git_cherrypick");
            git_cherrypick_commit = MemModule.GetDelegateFromFuncName<Delegate_git_cherrypick_commit>("git_cherrypick_commit");
            git_clone = MemModule.GetDelegateFromFuncName<Delegate_git_clone>("git_clone");
            git_commit_author = MemModule.GetDelegateFromFuncName<Delegate_git_commit_author>("git_commit_author");
            git_commit_committer = MemModule.GetDelegateFromFuncName<Delegate_git_commit_committer>("git_commit_committer");
            git_commit_create_buffer = MemModule.GetDelegateFromFuncName<Delegate_git_commit_create_buffer>("git_commit_create_buffer");
            git_commit_create_from_ids = MemModule.GetDelegateFromFuncName<Delegate_git_commit_create_from_ids>("git_commit_create_from_ids");
            git_commit_create_with_signature = MemModule.GetDelegateFromFuncName<Delegate_git_commit_create_with_signature>("git_commit_create_with_signature");
            git_commit_extract_signature = MemModule.GetDelegateFromFuncName<Delegate_git_commit_extract_signature>("git_commit_extract_signature");
            git_commit_message = MemModule.GetDelegateFromFuncName<Delegate_git_commit_message>("git_commit_message");
            git_commit_message_encoding = MemModule.GetDelegateFromFuncName<Delegate_git_commit_message_encoding>("git_commit_message_encoding");
            git_commit_parent_id = MemModule.GetDelegateFromFuncName<Delegate_git_commit_parent_id>("git_commit_parent_id");
            git_commit_parentcount = MemModule.GetDelegateFromFuncName<Delegate_git_commit_parentcount>("git_commit_parentcount");
            git_commit_summary = MemModule.GetDelegateFromFuncName<Delegate_git_commit_summary>("git_commit_summary");
            git_commit_tree_id = MemModule.GetDelegateFromFuncName<Delegate_git_commit_tree_id>("git_commit_tree_id");
            git_config_add_file_ondisk = MemModule.GetDelegateFromFuncName<Delegate_git_config_add_file_ondisk>("git_config_add_file_ondisk");
            git_config_delete_entry = MemModule.GetDelegateFromFuncName<Delegate_git_config_delete_entry>("git_config_delete_entry");
            git_config_delete_multivar = MemModule.GetDelegateFromFuncName<Delegate_git_config_delete_multivar>("git_config_delete_multivar");
            git_config_entry_free = MemModule.GetDelegateFromFuncName<Delegate_git_config_entry_free>("git_config_entry_free");
            git_config_find_global = MemModule.GetDelegateFromFuncName<Delegate_git_config_find__Any>("git_config_find_global");
            git_config_find_programdata = MemModule.GetDelegateFromFuncName<Delegate_git_config_find__Any>("git_config_find_programdata");
            git_config_find_system = MemModule.GetDelegateFromFuncName<Delegate_git_config_find__Any>("git_config_find_system");
            git_config_find_xdg = MemModule.GetDelegateFromFuncName<Delegate_git_config_find__Any>("git_config_find_xdg");
            git_config_foreach = MemModule.GetDelegateFromFuncName<Delegate_git_config_foreach>("git_config_foreach");
            git_config_free = MemModule.GetDelegateFromFuncName<Delegate_git_config_free>("git_config_free");
            git_config_get_entry = MemModule.GetDelegateFromFuncName<Delegate_git_config_get_entry>("git_config_get_entry");
            git_config_iterator_free = MemModule.GetDelegateFromFuncName<Delegate_git_config_iterator_free>("git_config_iterator_free");
            git_config_iterator_glob_new = MemModule.GetDelegateFromFuncName<Delegate_git_config_iterator_glob_new>("git_config_iterator_glob_new");
            git_config_lock = MemModule.GetDelegateFromFuncName<Delegate_git_config_lock>("git_config_lock");
            git_config_new = MemModule.GetDelegateFromFuncName<Delegate_git_config_new>("git_config_new");
            git_config_next = MemModule.GetDelegateFromFuncName<Delegate_git_config_next>("git_config_next");
            git_config_open_level = MemModule.GetDelegateFromFuncName<Delegate_git_config_open_level>("git_config_open_level");
            git_config_parse_bool = MemModule.GetDelegateFromFuncName<Delegate_git_config_parse_bool>("git_config_parse_bool");
            git_config_parse_int32 = MemModule.GetDelegateFromFuncName<Delegate_git_config_parse_int32>("git_config_parse_int32");
            git_config_parse_int64 = MemModule.GetDelegateFromFuncName<Delegate_git_config_parse_int64>("git_config_parse_int64");
            git_config_set_bool = MemModule.GetDelegateFromFuncName<Delegate_git_config_set_bool>("git_config_set_bool");
            git_config_set_int32 = MemModule.GetDelegateFromFuncName<Delegate_git_config_set_int32>("git_config_set_int32");
            git_config_set_int64 = MemModule.GetDelegateFromFuncName<Delegate_git_config_set_int64>("git_config_set_int64");
            git_config_set_multivar = MemModule.GetDelegateFromFuncName<Delegate_git_config_set_multivar>("git_config_set_multivar");
            git_config_set_string = MemModule.GetDelegateFromFuncName<Delegate_git_config_set_string>("git_config_set_string");
            git_config_snapshot = MemModule.GetDelegateFromFuncName<Delegate_git_config_snapshot>("git_config_snapshot");
            git_credential_default_new = MemModule.GetDelegateFromFuncName<Delegate_git_credential_default_new>("git_credential_default_new");
            git_credential_free = MemModule.GetDelegateFromFuncName<Delegate_git_credential_free>("git_credential_free");
            git_credential_userpass_plaintext_new = MemModule.GetDelegateFromFuncName<Delegate_git_credential_userpass_plaintext_new>("git_credential_userpass_plaintext_new");
            git_describe_commit = MemModule.GetDelegateFromFuncName<Delegate_git_describe_commit>("git_describe_commit");
            git_describe_format = MemModule.GetDelegateFromFuncName<Delegate_git_describe_format>("git_describe_format");
            git_describe_result_free = MemModule.GetDelegateFromFuncName<Delegate_git_describe_result_free>("git_describe_result_free");
            git_diff_blobs = MemModule.GetDelegateFromFuncName<Delegate_git_diff_blobs>("git_diff_blobs");
            git_diff_find_similar = MemModule.GetDelegateFromFuncName<Delegate_git_diff_find_similar>("git_diff_find_similar");
            git_diff_foreach = MemModule.GetDelegateFromFuncName<Delegate_git_diff_foreach>("git_diff_foreach");
            git_diff_free = MemModule.GetDelegateFromFuncName<Delegate_git_diff_free>("git_diff_free");
            git_diff_get_delta = MemModule.GetDelegateFromFuncName<Delegate_git_diff_get_delta>("git_diff_get_delta");
            git_diff_index_to_workdir = MemModule.GetDelegateFromFuncName<Delegate_git_diff_index_to_workdir>("git_diff_index_to_workdir");
            git_diff_merge = MemModule.GetDelegateFromFuncName<Delegate_git_diff_merge>("git_diff_merge");
            git_diff_num_deltas = MemModule.GetDelegateFromFuncName<Delegate_git_diff_num_deltas>("git_diff_num_deltas");
            git_diff_tree_to_index = MemModule.GetDelegateFromFuncName<Delegate_git_diff_tree_to_index>("git_diff_tree_to_index");
            git_diff_tree_to_tree = MemModule.GetDelegateFromFuncName<Delegate_git_diff_tree_to_tree>("git_diff_tree_to_tree");
            git_diff_tree_to_workdir = MemModule.GetDelegateFromFuncName<Delegate_git_diff_tree_to_workdir>("git_diff_tree_to_workdir");
            git_error_last = MemModule.GetDelegateFromFuncName<Delegate_git_error_last>("git_error_last");
            git_error_set_oom = MemModule.GetDelegateFromFuncName<Delegate_git_error_set_oom>("git_error_set_oom");
            git_error_set_str = MemModule.GetDelegateFromFuncName<Delegate_git_error_set_str>("git_error_set_str");
            git_filter_register = MemModule.GetDelegateFromFuncName<Delegate_git_filter_register>("git_filter_register");
            git_filter_source_mode = MemModule.GetDelegateFromFuncName<Delegate_git_filter_source_mode>("git_filter_source_mode");
            git_filter_unregister = MemModule.GetDelegateFromFuncName<Delegate_git_filter_unregister>("git_filter_unregister");
            git_graph_ahead_behind = MemModule.GetDelegateFromFuncName<Delegate_git_graph_ahead_behind>("git_graph_ahead_behind");
            git_graph_descendant_of = MemModule.GetDelegateFromFuncName<Delegate_git_graph_descendant_of>("git_graph_descendant_of");
            git_ignore_add_rule = MemModule.GetDelegateFromFuncName<Delegate_git_ignore_add_rule>("git_ignore_add_rule");
            git_ignore_clear_internal_rules = MemModule.GetDelegateFromFuncName<Delegate_git_ignore_clear_internal_rules>("git_ignore_clear_internal_rules");
            git_ignore_path_is_ignored = MemModule.GetDelegateFromFuncName<Delegate_git_ignore_path_is_ignored>("git_ignore_path_is_ignored");
            git_index_add = MemModule.GetDelegateFromFuncName<Delegate_git_index_add>("git_index_add");
            git_index_add_bypath = MemModule.GetDelegateFromFuncName<Delegate_git_index_add_bypath>("git_index_add_bypath");
            git_index_clear = MemModule.GetDelegateFromFuncName<Delegate_git_index_clear>("git_index_clear");
            git_index_conflict_get = MemModule.GetDelegateFromFuncName<Delegate_git_index_conflict_get>("git_index_conflict_get");
            git_index_conflict_iterator_free = MemModule.GetDelegateFromFuncName<Delegate_git_index_conflict_iterator_free>("git_index_conflict_iterator_free");
            git_index_conflict_iterator_new = MemModule.GetDelegateFromFuncName<Delegate_git_index_conflict_iterator_new>("git_index_conflict_iterator_new");
            git_index_conflict_next = MemModule.GetDelegateFromFuncName<Delegate_git_index_conflict_next>("git_index_conflict_next");
            git_index_entry_stage = MemModule.GetDelegateFromFuncName<Delegate_git_index_entry_stage>("git_index_entry_stage");
            git_index_entrycount = MemModule.GetDelegateFromFuncName<Delegate_git_index_entrycount>("git_index_entrycount");
            git_index_free = MemModule.GetDelegateFromFuncName<Delegate_git_index_free>("git_index_free");
            git_index_get_byindex = MemModule.GetDelegateFromFuncName<Delegate_git_index_get_byindex>("git_index_get_byindex");
            git_index_get_bypath = MemModule.GetDelegateFromFuncName<Delegate_git_index_get_bypath>("git_index_get_bypath");
            git_index_has_conflicts = MemModule.GetDelegateFromFuncName<Delegate_git_index_has_conflicts>("git_index_has_conflicts");
            git_index_name_entrycount = MemModule.GetDelegateFromFuncName<Delegate_git_index_name_entrycount>("git_index_name_entrycount");
            git_index_name_get_byindex = MemModule.GetDelegateFromFuncName<Delegate_git_index_name_get_byindex>("git_index_name_get_byindex");
            git_index_open = MemModule.GetDelegateFromFuncName<Delegate_git_index_open>("git_index_open");
            git_index_read = MemModule.GetDelegateFromFuncName<Delegate_git_index_read>("git_index_read");
            git_index_read_tree = MemModule.GetDelegateFromFuncName<Delegate_git_index_read_tree>("git_index_read_tree");
            git_index_remove_bypath = MemModule.GetDelegateFromFuncName<Delegate_git_index_remove_bypath>("git_index_remove_bypath");
            git_index_reuc_entrycount = MemModule.GetDelegateFromFuncName<Delegate_git_index_reuc_entrycount>("git_index_reuc_entrycount");
            git_index_reuc_get_byindex = MemModule.GetDelegateFromFuncName<Delegate_git_index_reuc_get_byindex>("git_index_reuc_get_byindex");
            git_index_reuc_get_bypath = MemModule.GetDelegateFromFuncName<Delegate_git_index_reuc_get_bypath>("git_index_reuc_get_bypath");
            git_index_write = MemModule.GetDelegateFromFuncName<Delegate_git_index_write>("git_index_write");
            git_index_write_tree = MemModule.GetDelegateFromFuncName<Delegate_git_index_write_tree>("git_index_write_tree");
            git_index_write_tree_to = MemModule.GetDelegateFromFuncName<Delegate_git_index_write_tree_to>("git_index_write_tree_to");
            git_libgit2_features = MemModule.GetDelegateFromFuncName<Delegate_git_libgit2_features>("git_libgit2_features");
            git_libgit2_init = MemModule.GetDelegateFromFuncName<Delegate_git_libgit2_init>("git_libgit2_init");
            git_libgit2_opts__1 = MemModule.GetDelegateFromFuncName<Delegate_git_libgit2_opts__1>("git_libgit2_opts");
            git_libgit2_opts__2 = MemModule.GetDelegateFromFuncName<Delegate_git_libgit2_opts__2>("git_libgit2_opts");
            git_libgit2_opts__3 = MemModule.GetDelegateFromFuncName<Delegate_git_libgit2_opts__3>("git_libgit2_opts");
            git_libgit2_opts__4 = MemModule.GetDelegateFromFuncName<Delegate_git_libgit2_opts__4>("git_libgit2_opts");
            git_libgit2_opts__5 = MemModule.GetDelegateFromFuncName<Delegate_git_libgit2_opts__5>("git_libgit2_opts");
            git_libgit2_opts__6 = MemModule.GetDelegateFromFuncName<Delegate_git_libgit2_opts__6>("git_libgit2_opts");
            git_libgit2_opts__7 = MemModule.GetDelegateFromFuncName<Delegate_git_libgit2_opts__7>("git_libgit2_opts");
            git_libgit2_shutdown = MemModule.GetDelegateFromFuncName<Delegate_git_libgit2_shutdown>("git_libgit2_shutdown");
            git_merge = MemModule.GetDelegateFromFuncName<Delegate_git_merge>("git_merge");
            git_merge_analysis = MemModule.GetDelegateFromFuncName<Delegate_git_merge_analysis>("git_merge_analysis");
            git_merge_base_many = MemModule.GetDelegateFromFuncName<Delegate_git_merge_base_many>("git_merge_base_many");
            git_merge_base_octopus = MemModule.GetDelegateFromFuncName<Delegate_git_merge_base_octopus>("git_merge_base_octopus");
            git_merge_commits = MemModule.GetDelegateFromFuncName<Delegate_git_merge_commits>("git_merge_commits");
            git_message_prettify = MemModule.GetDelegateFromFuncName<Delegate_git_message_prettify>("git_message_prettify");
            git_note_create = MemModule.GetDelegateFromFuncName<Delegate_git_note_create>("git_note_create");
            git_note_default_ref = MemModule.GetDelegateFromFuncName<Delegate_git_note_default_ref>("git_note_default_ref");
            git_note_foreach = MemModule.GetDelegateFromFuncName<Delegate_git_note_foreach>("git_note_foreach");
            git_note_free = MemModule.GetDelegateFromFuncName<Delegate_git_note_free>("git_note_free");
            git_note_id = MemModule.GetDelegateFromFuncName<Delegate_git_note_id>("git_note_id");
            git_note_message = MemModule.GetDelegateFromFuncName<Delegate_git_note_message>("git_note_message");
            git_note_read = MemModule.GetDelegateFromFuncName<Delegate_git_note_read>("git_note_read");
            git_note_remove = MemModule.GetDelegateFromFuncName<Delegate_git_note_remove>("git_note_remove");
            git_object_free = MemModule.GetDelegateFromFuncName<Delegate_git_object_free>("git_object_free");
            git_object_id = MemModule.GetDelegateFromFuncName<Delegate_git_object_id>("git_object_id");
            git_object_lookup = MemModule.GetDelegateFromFuncName<Delegate_git_object_lookup>("git_object_lookup");
            git_object_peel = MemModule.GetDelegateFromFuncName<Delegate_git_object_peel>("git_object_peel");
            git_object_short_id = MemModule.GetDelegateFromFuncName<Delegate_git_object_short_id>("git_object_short_id");
            git_object_type = MemModule.GetDelegateFromFuncName<Delegate_git_object_type>("git_object_type");
            git_odb_add_backend = MemModule.GetDelegateFromFuncName<Delegate_git_odb_add_backend>("git_odb_add_backend");
            git_odb_backend_data_alloc = MemModule.GetDelegateFromFuncName<Delegate_git_odb_backend_data_alloc>("git_odb_backend_data_alloc");
            git_odb_exists = MemModule.GetDelegateFromFuncName<Delegate_git_odb_exists>("git_odb_exists");
            git_odb_foreach = MemModule.GetDelegateFromFuncName<Delegate_git_odb_foreach>("git_odb_foreach");
            git_odb_free = MemModule.GetDelegateFromFuncName<Delegate_git_odb_free>("git_odb_free");
            git_odb_open_wstream = MemModule.GetDelegateFromFuncName<Delegate_git_odb_open_wstream>("git_odb_open_wstream");
            git_odb_read_header = MemModule.GetDelegateFromFuncName<Delegate_git_odb_read_header>("git_odb_read_header");
            git_odb_stream_finalize_write = MemModule.GetDelegateFromFuncName<Delegate_git_odb_stream_finalize_write>("git_odb_stream_finalize_write");
            git_odb_stream_free = MemModule.GetDelegateFromFuncName<Delegate_git_odb_stream_free>("git_odb_stream_free");
            git_odb_stream_write = MemModule.GetDelegateFromFuncName<Delegate_git_odb_stream_write>("git_odb_stream_write");
            git_odb_write = MemModule.GetDelegateFromFuncName<Delegate_git_odb_write>("git_odb_write");
            git_openssl_set_locking = MemModule.GetDelegateFromFuncName<Delegate_git_openssl_set_locking>("git_openssl_set_locking");
            git_packbuilder_free = MemModule.GetDelegateFromFuncName<Delegate_git_packbuilder_free>("git_packbuilder_free");
            git_packbuilder_insert = MemModule.GetDelegateFromFuncName<Delegate_git_packbuilder_insert>("git_packbuilder_insert");
            git_packbuilder_insert_commit = MemModule.GetDelegateFromFuncName<Delegate_git_packbuilder_insert_commit>("git_packbuilder_insert_commit");
            git_packbuilder_insert_recur = MemModule.GetDelegateFromFuncName<Delegate_git_packbuilder_insert_recur>("git_packbuilder_insert_recur");
            git_packbuilder_insert_tree = MemModule.GetDelegateFromFuncName<Delegate_git_packbuilder_insert_tree>("git_packbuilder_insert_tree");
            git_packbuilder_new = MemModule.GetDelegateFromFuncName<Delegate_git_packbuilder_new>("git_packbuilder_new");
            git_packbuilder_object_count = MemModule.GetDelegateFromFuncName<Delegate_git_packbuilder_object_count>("git_packbuilder_object_count");
            git_packbuilder_set_threads = MemModule.GetDelegateFromFuncName<Delegate_git_packbuilder_set_threads>("git_packbuilder_set_threads");
            git_packbuilder_write = MemModule.GetDelegateFromFuncName<Delegate_git_packbuilder_write>("git_packbuilder_write");
            git_packbuilder_written = MemModule.GetDelegateFromFuncName<Delegate_git_packbuilder_written>("git_packbuilder_written");
            git_patch_free = MemModule.GetDelegateFromFuncName<Delegate_git_patch_free>("git_patch_free");
            git_patch_from_diff = MemModule.GetDelegateFromFuncName<Delegate_git_patch_from_diff>("git_patch_from_diff");
            git_patch_line_stats = MemModule.GetDelegateFromFuncName<Delegate_git_patch_line_stats>("git_patch_line_stats");
            git_patch_print = MemModule.GetDelegateFromFuncName<Delegate_git_patch_print>("git_patch_print");
            git_rebase_abort = MemModule.GetDelegateFromFuncName<Delegate_git_rebase_abort>("git_rebase_abort");
            git_rebase_commit = MemModule.GetDelegateFromFuncName<Delegate_git_rebase_commit>("git_rebase_commit");
            git_rebase_finish = MemModule.GetDelegateFromFuncName<Delegate_git_rebase_finish>("git_rebase_finish");
            git_rebase_free = MemModule.GetDelegateFromFuncName<Delegate_git_rebase_free>("git_rebase_free");
            git_rebase_init = MemModule.GetDelegateFromFuncName<Delegate_git_rebase_init>("git_rebase_init");
            git_rebase_next = MemModule.GetDelegateFromFuncName<Delegate_git_rebase_next>("git_rebase_next");
            git_rebase_open = MemModule.GetDelegateFromFuncName<Delegate_git_rebase_open>("git_rebase_open");
            git_rebase_operation_byindex = MemModule.GetDelegateFromFuncName<Delegate_git_rebase_operation_byindex>("git_rebase_operation_byindex");
            git_rebase_operation_current = MemModule.GetDelegateFromFuncName<Delegate_git_rebase_operation_current>("git_rebase_operation_current");
            git_rebase_operation_entrycount = MemModule.GetDelegateFromFuncName<Delegate_git_rebase_operation_entrycount>("git_rebase_operation_entrycount");
            git_reference_create = MemModule.GetDelegateFromFuncName<Delegate_git_reference_create>("git_reference_create");
            git_reference_ensure_log = MemModule.GetDelegateFromFuncName<Delegate_git_reference_ensure_log>("git_reference_ensure_log");
            git_reference_foreach_glob = MemModule.GetDelegateFromFuncName<Delegate_git_reference_foreach_glob>("git_reference_foreach_glob");
            git_reference_free = MemModule.GetDelegateFromFuncName<Delegate_git_reference_free>("git_reference_free");
            git_reference_name_is_valid = MemModule.GetDelegateFromFuncName<Delegate_git_reference_name_is_valid>("git_reference_name_is_valid");
            git_reference_list = MemModule.GetDelegateFromFuncName<Delegate_git_reference_list>("git_reference_list");
            git_reference_lookup = MemModule.GetDelegateFromFuncName<Delegate_git_reference_lookup>("git_reference_lookup");
            git_reference_name = MemModule.GetDelegateFromFuncName<Delegate_git_reference_name>("git_reference_name");
            git_reference_remove = MemModule.GetDelegateFromFuncName<Delegate_git_reference_remove>("git_reference_remove");
            git_reference_rename = MemModule.GetDelegateFromFuncName<Delegate_git_reference_rename>("git_reference_rename");
            git_reference_set_target = MemModule.GetDelegateFromFuncName<Delegate_git_reference_set_target>("git_reference_set_target");
            git_reference_symbolic_create = MemModule.GetDelegateFromFuncName<Delegate_git_reference_symbolic_create>("git_reference_symbolic_create");
            git_reference_symbolic_set_target = MemModule.GetDelegateFromFuncName<Delegate_git_reference_symbolic_set_target>("git_reference_symbolic_set_target");
            git_reference_symbolic_target = MemModule.GetDelegateFromFuncName<Delegate_git_reference_symbolic_target>("git_reference_symbolic_target");
            git_reference_target = MemModule.GetDelegateFromFuncName<Delegate_git_reference_target>("git_reference_target");
            git_reference_type = MemModule.GetDelegateFromFuncName<Delegate_git_reference_type>("git_reference_type");
            git_reflog_entry_byindex = MemModule.GetDelegateFromFuncName<Delegate_git_reflog_entry_byindex>("git_reflog_entry_byindex");
            git_reflog_entry_committer = MemModule.GetDelegateFromFuncName<Delegate_git_reflog_entry_committer>("git_reflog_entry_committer");
            git_reflog_entry_id_new = MemModule.GetDelegateFromFuncName<Delegate_git_reflog_entry_id_new>("git_reflog_entry_id_new");
            git_reflog_entry_id_old = MemModule.GetDelegateFromFuncName<Delegate_git_reflog_entry_id_old>("git_reflog_entry_id_old");
            git_reflog_entry_message = MemModule.GetDelegateFromFuncName<Delegate_git_reflog_entry_message>("git_reflog_entry_message");
            git_reflog_entrycount = MemModule.GetDelegateFromFuncName<Delegate_git_reflog_entrycount>("git_reflog_entrycount");
            git_reflog_free = MemModule.GetDelegateFromFuncName<Delegate_git_reflog_free>("git_reflog_free");
            git_reflog_read = MemModule.GetDelegateFromFuncName<Delegate_git_reflog_read>("git_reflog_read");
            git_refspec_direction = MemModule.GetDelegateFromFuncName<Delegate_git_refspec_direction>("git_refspec_direction");
            git_refspec_dst = MemModule.GetDelegateFromFuncName<Delegate_git_refspec_dst>("git_refspec_dst");
            git_refspec_dst_matches = MemModule.GetDelegateFromFuncName<Delegate_git_refspec_dst_matches>("git_refspec_dst_matches");
            git_refspec_force = MemModule.GetDelegateFromFuncName<Delegate_git_refspec_force>("git_refspec_force");
            git_refspec_rtransform = MemModule.GetDelegateFromFuncName<Delegate_git_refspec_rtransform>("git_refspec_rtransform");
            git_refspec_src = MemModule.GetDelegateFromFuncName<Delegate_git_refspec_src>("git_refspec_src");
            git_refspec_src_matches = MemModule.GetDelegateFromFuncName<Delegate_git_refspec_src_matches>("git_refspec_src_matches");
            git_refspec_string = MemModule.GetDelegateFromFuncName<Delegate_git_refspec_string>("git_refspec_string");
            git_refspec_transform = MemModule.GetDelegateFromFuncName<Delegate_git_refspec_transform>("git_refspec_transform");
            git_remote_add_fetch = MemModule.GetDelegateFromFuncName<Delegate_git_remote_add_fetch>("git_remote_add_fetch");
            git_remote_add_push = MemModule.GetDelegateFromFuncName<Delegate_git_remote_add_push>("git_remote_add_push");
            git_remote_autotag = MemModule.GetDelegateFromFuncName<Delegate_git_remote_autotag>("git_remote_autotag");
            git_remote_connect = MemModule.GetDelegateFromFuncName<Delegate_git_remote_connect>("git_remote_connect");
            git_remote_create = MemModule.GetDelegateFromFuncName<Delegate_git_remote_create>("git_remote_create");
            git_remote_create_anonymous = MemModule.GetDelegateFromFuncName<Delegate_git_remote_create_anonymous>("git_remote_create_anonymous");
            git_remote_create_with_fetchspec = MemModule.GetDelegateFromFuncName<Delegate_git_remote_create_with_fetchspec>("git_remote_create_with_fetchspec");
            git_remote_delete = MemModule.GetDelegateFromFuncName<Delegate_git_remote_delete>("git_remote_delete");
            git_remote_fetch = MemModule.GetDelegateFromFuncName<Delegate_git_remote_fetch>("git_remote_fetch");
            git_remote_free = MemModule.GetDelegateFromFuncName<Delegate_git_remote_free>("git_remote_free");
            git_remote_get_fetch_refspecs = MemModule.GetDelegateFromFuncName<Delegate_git_remote_get_fetch_refspecs>("git_remote_get_fetch_refspecs");
            git_remote_get_push_refspecs = MemModule.GetDelegateFromFuncName<Delegate_git_remote_get_push_refspecs>("git_remote_get_push_refspecs");
            git_remote_get_refspec = MemModule.GetDelegateFromFuncName<Delegate_git_remote_get_refspec>("git_remote_get_refspec");
            git_remote_name_is_valid = MemModule.GetDelegateFromFuncName<Delegate_git_remote_name_is_valid>("git_remote_name_is_valid");
            git_remote_list = MemModule.GetDelegateFromFuncName<Delegate_git_remote_list>("git_remote_list");
            git_remote_lookup = MemModule.GetDelegateFromFuncName<Delegate_git_remote_lookup>("git_remote_lookup");
            git_remote_ls = MemModule.GetDelegateFromFuncName<Delegate_git_remote_ls>("git_remote_ls");
            git_remote_name = MemModule.GetDelegateFromFuncName<Delegate_git_remote_name>("git_remote_name");
            git_remote_push = MemModule.GetDelegateFromFuncName<Delegate_git_remote_push>("git_remote_push");
            git_remote_pushurl = MemModule.GetDelegateFromFuncName<Delegate_git_remote_pushurl>("git_remote_pushurl");
            git_remote_refspec_count = MemModule.GetDelegateFromFuncName<Delegate_git_remote_refspec_count>("git_remote_refspec_count");
            git_remote_rename = MemModule.GetDelegateFromFuncName<Delegate_git_remote_rename>("git_remote_rename");
            git_remote_set_autotag = MemModule.GetDelegateFromFuncName<Delegate_git_remote_set_autotag>("git_remote_set_autotag");
            git_remote_set_pushurl = MemModule.GetDelegateFromFuncName<Delegate_git_remote_set_pushurl>("git_remote_set_pushurl");
            git_remote_set_url = MemModule.GetDelegateFromFuncName<Delegate_git_remote_set_url>("git_remote_set_url");
            git_remote_url = MemModule.GetDelegateFromFuncName<Delegate_git_remote_url>("git_remote_url");
            git_repository_discover = MemModule.GetDelegateFromFuncName<Delegate_git_repository_discover>("git_repository_discover");
            git_repository_fetchhead_foreach = MemModule.GetDelegateFromFuncName<Delegate_git_repository_fetchhead_foreach>("git_repository_fetchhead_foreach");
            git_repository_free = MemModule.GetDelegateFromFuncName<Delegate_git_repository_free>("git_repository_free");
            git_repository_head_detached = MemModule.GetDelegateFromFuncName<Delegate_git_repository__GetInt>("git_repository_head_detached");
            git_repository_head_unborn = MemModule.GetDelegateFromFuncName<Delegate_git_repository__GetInt>("git_repository_head_unborn");
            git_repository_ident = MemModule.GetDelegateFromFuncName<Delegate_git_repository_ident>("git_repository_ident");
            git_repository_index = MemModule.GetDelegateFromFuncName<Delegate_git_repository_index>("git_repository_index");
            git_repository_init_ext = MemModule.GetDelegateFromFuncName<Delegate_git_repository_init_ext>("git_repository_init_ext");
            git_repository_is_bare = MemModule.GetDelegateFromFuncName<Delegate_git_repository__GetInt>("git_repository_is_bare");
            git_repository_is_shallow = MemModule.GetDelegateFromFuncName<Delegate_git_repository__GetInt>("git_repository_is_shallow");
            git_repository_mergehead_foreach = MemModule.GetDelegateFromFuncName<Delegate_git_repository_mergehead_foreach>("git_repository_mergehead_foreach");
            git_repository_message = MemModule.GetDelegateFromFuncName<Delegate_git_repository_message>("git_repository_message");
            git_repository_new = MemModule.GetDelegateFromFuncName<Delegate_git_repository_new>("git_repository_new");
            git_repository_odb = MemModule.GetDelegateFromFuncName<Delegate_git_repository_odb>("git_repository_odb");
            git_repository_open = MemModule.GetDelegateFromFuncName<Delegate_git_repository_open>("git_repository_open");
            git_repository_open_ext = MemModule.GetDelegateFromFuncName<Delegate_git_repository_open_ext>("git_repository_open_ext");
            git_repository_open_from_worktree = MemModule.GetDelegateFromFuncName<Delegate_git_repository_open_from_worktree>("git_repository_open_from_worktree");
            git_repository_path = MemModule.GetDelegateFromFuncName<Delegate_git_repository_path>("git_repository_path");
            git_repository_set_config = MemModule.GetDelegateFromFuncName<Delegate_git_repository_set_config>("git_repository_set_config");
            git_repository_set_head = MemModule.GetDelegateFromFuncName<Delegate_git_repository_set_head>("git_repository_set_head");
            git_repository_set_head_detached = MemModule.GetDelegateFromFuncName<Delegate_git_repository_set_head_detached>("git_repository_set_head_detached");
            git_repository_set_head_detached_from_annotated = MemModule.GetDelegateFromFuncName<Delegate_git_repository_set_head_detached_from_annotated>("git_repository_set_head_detached_from_annotated");
            git_repository_set_ident = MemModule.GetDelegateFromFuncName<Delegate_git_repository_set_ident>("git_repository_set_ident");
            git_repository_set_index = MemModule.GetDelegateFromFuncName<Delegate_git_repository_set_index>("git_repository_set_index");
            git_repository_set_workdir = MemModule.GetDelegateFromFuncName<Delegate_git_repository_set_workdir>("git_repository_set_workdir");
            git_repository_state = MemModule.GetDelegateFromFuncName<Delegate_git_repository_state>("git_repository_state");
            git_repository_state_cleanup = MemModule.GetDelegateFromFuncName<Delegate_git_repository_state_cleanup>("git_repository_state_cleanup");
            git_repository_workdir__1 = MemModule.GetDelegateFromFuncName<Delegate_git_repository_workdir__1>("git_repository_workdir");
            git_repository_workdir__2 = MemModule.GetDelegateFromFuncName<Delegate_git_repository_workdir__2>("git_repository_workdir");
            git_reset = MemModule.GetDelegateFromFuncName<Delegate_git_reset>("git_reset");
            git_revert = MemModule.GetDelegateFromFuncName<Delegate_git_revert>("git_revert");
            git_revert_commit = MemModule.GetDelegateFromFuncName<Delegate_git_revert_commit>("git_revert_commit");
            git_revparse_ext = MemModule.GetDelegateFromFuncName<Delegate_git_revparse_ext>("git_revparse_ext");
            git_revwalk_free = MemModule.GetDelegateFromFuncName<Delegate_git_revwalk_free>("git_revwalk_free");
            git_revwalk_hide = MemModule.GetDelegateFromFuncName<Delegate_git_revwalk_hide>("git_revwalk_hide");
            git_revwalk_new = MemModule.GetDelegateFromFuncName<Delegate_git_revwalk_new>("git_revwalk_new");
            git_revwalk_next = MemModule.GetDelegateFromFuncName<Delegate_git_revwalk_next>("git_revwalk_next");
            git_revwalk_push = MemModule.GetDelegateFromFuncName<Delegate_git_revwalk_push>("git_revwalk_push");
            git_revwalk_reset = MemModule.GetDelegateFromFuncName<Delegate_git_revwalk_reset>("git_revwalk_reset");
            git_revwalk_simplify_first_parent = MemModule.GetDelegateFromFuncName<Delegate_git_revwalk_simplify_first_parent>("git_revwalk_simplify_first_parent");
            git_revwalk_sorting = MemModule.GetDelegateFromFuncName<Delegate_git_revwalk_sorting>("git_revwalk_sorting");
            git_signature_dup = MemModule.GetDelegateFromFuncName<Delegate_git_signature_dup>("git_signature_dup");
            git_signature_free = MemModule.GetDelegateFromFuncName<Delegate_git_signature_free>("git_signature_free");
            git_signature_new = MemModule.GetDelegateFromFuncName<Delegate_git_signature_new>("git_signature_new");
            git_signature_now = MemModule.GetDelegateFromFuncName<Delegate_git_signature_now>("git_signature_now");
            git_stash_apply = MemModule.GetDelegateFromFuncName<Delegate_git_stash_apply>("git_stash_apply");
            git_stash_drop = MemModule.GetDelegateFromFuncName<Delegate_git_stash_drop>("git_stash_drop");
            git_stash_foreach = MemModule.GetDelegateFromFuncName<Delegate_git_stash_foreach>("git_stash_foreach");
            git_stash_pop = MemModule.GetDelegateFromFuncName<Delegate_git_stash_pop>("git_stash_pop");
            git_stash_save = MemModule.GetDelegateFromFuncName<Delegate_git_stash_save>("git_stash_save");
            git_status_byindex = MemModule.GetDelegateFromFuncName<Delegate_git_status_byindex>("git_status_byindex");
            git_status_file = MemModule.GetDelegateFromFuncName<Delegate_git_status_file>("git_status_file");
            git_status_list_entrycount = MemModule.GetDelegateFromFuncName<Delegate_git_status_list_entrycount>("git_status_list_entrycount");
            git_status_list_free = MemModule.GetDelegateFromFuncName<Delegate_git_status_list_free>("git_status_list_free");
            git_status_list_new = MemModule.GetDelegateFromFuncName<Delegate_git_status_list_new>("git_status_list_new");
            git_strarray_dispose = MemModule.GetDelegateFromFuncName<Delegate_git_strarray_dispose>("git_strarray_dispose");
            git_submodule_add_to_index = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_add_to_index>("git_submodule_add_to_index");
            git_submodule_fetch_recurse_submodules = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_fetch_recurse_submodules>("git_submodule_fetch_recurse_submodules");
            git_submodule_foreach = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_foreach>("git_submodule_foreach");
            git_submodule_free = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_free>("git_submodule_free");
            git_submodule_head_id = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_head_id>("git_submodule_head_id");
            git_submodule_ignore = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_ignore>("git_submodule_ignore");
            git_submodule_index_id = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_index_id>("git_submodule_index_id");
            git_submodule_init = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_init>("git_submodule_init");
            git_submodule_lookup = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_lookup>("git_submodule_lookup");
            git_submodule_path = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_path>("git_submodule_path");
            git_submodule_reload = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_reload>("git_submodule_reload");
            git_submodule_resolve_url = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_resolve_url>("git_submodule_resolve_url");
            git_submodule_status = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_status>("git_submodule_status");
            git_submodule_update = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_update>("git_submodule_update");
            git_submodule_update_strategy = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_update_strategy>("git_submodule_update_strategy");
            git_submodule_url = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_url>("git_submodule_url");
            git_submodule_wd_id = MemModule.GetDelegateFromFuncName<Delegate_git_submodule_wd_id>("git_submodule_wd_id");
            git_tag_annotation_create = MemModule.GetDelegateFromFuncName<Delegate_git_tag_annotation_create>("git_tag_annotation_create");
            git_tag_create = MemModule.GetDelegateFromFuncName<Delegate_git_tag_create>("git_tag_create");
            git_tag_create_lightweight = MemModule.GetDelegateFromFuncName<Delegate_git_tag_create_lightweight>("git_tag_create_lightweight");
            git_tag_delete = MemModule.GetDelegateFromFuncName<Delegate_git_tag_delete>("git_tag_delete");
            git_tag_list = MemModule.GetDelegateFromFuncName<Delegate_git_tag_list>("git_tag_list");
            git_tag_message = MemModule.GetDelegateFromFuncName<Delegate_git_tag_message>("git_tag_message");
            git_tag_name = MemModule.GetDelegateFromFuncName<Delegate_git_tag_name>("git_tag_name");
            git_tag_tagger = MemModule.GetDelegateFromFuncName<Delegate_git_tag_tagger>("git_tag_tagger");
            git_tag_target_id = MemModule.GetDelegateFromFuncName<Delegate_git_tag_target_id>("git_tag_target_id");
            git_tag_target_type = MemModule.GetDelegateFromFuncName<Delegate_git_tag_target_type>("git_tag_target_type");
            git_trace_set = MemModule.GetDelegateFromFuncName<Delegate_git_trace_set>("git_trace_set");
            git_transaction_commit = MemModule.GetDelegateFromFuncName<Delegate_git_transaction_commit>("git_transaction_commit");
            git_transaction_free = MemModule.GetDelegateFromFuncName<Delegate_git_transaction_free>("git_transaction_free");
            git_transport_register = MemModule.GetDelegateFromFuncName<Delegate_git_transport_register>("git_transport_register");
            git_transport_smart = MemModule.GetDelegateFromFuncName<Delegate_git_transport_smart>("git_transport_smart");
            git_transport_smart_certificate_check = MemModule.GetDelegateFromFuncName<Delegate_git_transport_smart_certificate_check>("git_transport_smart_certificate_check");
            git_transport_smart_credentials = MemModule.GetDelegateFromFuncName<Delegate_git_transport_smart_credentials>("git_transport_smart_credentials");
            git_transport_unregister = MemModule.GetDelegateFromFuncName<Delegate_git_transport_unregister>("git_transport_unregister");
            git_tree_entry_byindex = MemModule.GetDelegateFromFuncName<Delegate_git_tree_entry_byindex>("git_tree_entry_byindex");
            git_tree_entry_bypath = MemModule.GetDelegateFromFuncName<Delegate_git_tree_entry_bypath>("git_tree_entry_bypath");
            git_tree_entry_filemode = MemModule.GetDelegateFromFuncName<Delegate_git_tree_entry_filemode>("git_tree_entry_filemode");
            git_tree_entry_free = MemModule.GetDelegateFromFuncName<Delegate_git_tree_entry_free>("git_tree_entry_free");
            git_tree_entry_id = MemModule.GetDelegateFromFuncName<Delegate_git_tree_entry_id>("git_tree_entry_id");
            git_tree_entry_name = MemModule.GetDelegateFromFuncName<Delegate_git_tree_entry_name>("git_tree_entry_name");
            git_tree_entry_type = MemModule.GetDelegateFromFuncName<Delegate_git_tree_entry_type>("git_tree_entry_type");
            git_tree_entrycount = MemModule.GetDelegateFromFuncName<Delegate_git_tree_entrycount>("git_tree_entrycount");
            git_treebuilder_free = MemModule.GetDelegateFromFuncName<Delegate_git_treebuilder_free>("git_treebuilder_free");
            git_treebuilder_insert = MemModule.GetDelegateFromFuncName<Delegate_git_treebuilder_insert>("git_treebuilder_insert");
            git_treebuilder_new = MemModule.GetDelegateFromFuncName<Delegate_git_treebuilder_new>("git_treebuilder_new");
            git_treebuilder_write = MemModule.GetDelegateFromFuncName<Delegate_git_treebuilder_write>("git_treebuilder_write");
            git_worktree_add = MemModule.GetDelegateFromFuncName<Delegate_git_worktree_add>("git_worktree_add");
            git_worktree_free = MemModule.GetDelegateFromFuncName<Delegate_git_worktree_free>("git_worktree_free");
            git_worktree_is_locked = MemModule.GetDelegateFromFuncName<Delegate_git_worktree_is_locked>("git_worktree_is_locked");
            git_worktree_list = MemModule.GetDelegateFromFuncName<Delegate_git_worktree_list>("git_worktree_list");
            git_worktree_lock = MemModule.GetDelegateFromFuncName<Delegate_git_worktree_lock>("git_worktree_lock");
            git_worktree_lookup = MemModule.GetDelegateFromFuncName<Delegate_git_worktree_lookup>("git_worktree_lookup");
            git_worktree_prune = MemModule.GetDelegateFromFuncName<Delegate_git_worktree_prune>("git_worktree_prune");
            git_worktree_unlock = MemModule.GetDelegateFromFuncName<Delegate_git_worktree_unlock>("git_worktree_unlock");
            git_worktree_validate = MemModule.GetDelegateFromFuncName<Delegate_git_worktree_validate>("git_worktree_validate");
            #endregion

            // Initialization can be called multiple times as long as there is a corresponding shutdown to each initialization.
            int initCounter = git_libgit2_init();
            System.Diagnostics.Debug.Assert(initCounter == 1);
            MemModule.OnDispose = () =>
            {
                int res = git_libgit2_shutdown();
                System.Diagnostics.Debug.Assert(res == (int)GitErrorCode.Ok);
            };

            // Configure the OpenSSL locking on the first initialization of the library in the current process.
            if (initCounter == 1)
            {
                git_openssl_set_locking();
            }
        }

        #region delegate definitions
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate GitError* Delegate_git_error_last();

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_error_set_str(
            GitErrorCategory error_class,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string errorString);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void Delegate_git_error_set_oom();

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UInt32 Delegate_git_blame_get_hunk_count(git_blame* blame);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_blame_hunk* Delegate_git_blame_get_hunk_byindex(
            git_blame* blame, UInt32 index);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_blame_file(
            out git_blame* blame,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path,
            git_blame_options options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_blame_free(git_blame* blame);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_blob_create_from_disk(
            ref GitOid id,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_blob_create_from_workdir(
            ref GitOid id,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath relative_path);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_blob_create_from_stream(
            out IntPtr stream,
            git_repository* repositoryPtr,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string hintpath);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_blob_create_from_stream_commit(
            ref GitOid oid,
            IntPtr stream);

        #if LIBGIT2_HAVE_DEPRECATE
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_blob_filtered_content(
            GitBuf buf,
            git_object* blob,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string as_path,
            [MarshalAs(UnmanagedType.Bool)] bool check_for_binary_data);
        #endif

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate IntPtr Delegate_git_blob_rawcontent(git_object* blob);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate Int64 Delegate_git_blob_rawsize(git_object* blob);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_branch_create_from_annotated(
            out git_reference* ref_out,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string branch_name,
            git_annotated_commit* target,
            [MarshalAs(UnmanagedType.Bool)] bool force);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_branch_delete(
            git_reference* reference);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int branch_foreach_callback(
            IntPtr branch_name,
            GitBranchType branch_type,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void Delegate_git_branch_iterator_free(
            IntPtr iterator);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_branch_iterator_new(
            out IntPtr iter_out,
            IntPtr repo,
            GitBranchType branch_type);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_branch_move(
            out git_reference* ref_out,
            git_reference* reference,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string new_branch_name,
            [MarshalAs(UnmanagedType.Bool)] bool force);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_branch_next(
            out IntPtr ref_out,
            out GitBranchType type_out,
            IntPtr iter);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_branch_remote_name(
            GitBuf buf,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string canonical_branch_name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int commit_signing_callback(
            IntPtr signature,
            IntPtr signature_field,
            IntPtr commit_content,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_rebase_init(
            out git_rebase* rebase,
            git_repository* repo,
            git_annotated_commit* branch,
            git_annotated_commit* upstream,
            git_annotated_commit* onto,
            GitRebaseOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_rebase_open(
            out git_rebase* rebase,
            git_repository* repo,
            GitRebaseOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UIntPtr Delegate_git_rebase_operation_entrycount(
            git_rebase* rebase);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UIntPtr Delegate_git_rebase_operation_current(
            git_rebase* rebase);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_rebase_operation* Delegate_git_rebase_operation_byindex(
            git_rebase* rebase,
            UIntPtr index);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_rebase_next(
            out git_rebase_operation* operation,
            git_rebase* rebase);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_rebase_commit(
            ref GitOid id,
            git_rebase* rebase,
            git_signature* author,
            git_signature* committer,
            IntPtr message_encoding,
            IntPtr message);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_rebase_abort(
            git_rebase* rebase);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_rebase_finish(
            git_rebase* repo,
            git_signature* signature);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_rebase_free(git_rebase* rebase);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_rename(
            ref GitStrArray problems,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string old_name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string new_name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_remote_rename_problem_cb(
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))] string problematic_refspec,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_branch_upstream_name(
            GitBuf buf,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string referenceName);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void Delegate_git_buf_dispose(GitBuf buf);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_checkout_tree(
            git_repository* repo,
            git_object* treeish,
            ref GitCheckoutOpts opts);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_checkout_index(
            git_repository* repo,
            git_object* treeish,
            ref GitCheckoutOpts opts);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_clone(
            out git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string origin_url,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath workdir_path,
            ref GitCloneOptions opts);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_signature* Delegate_git_commit_author(git_object* commit);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_signature* Delegate_git_commit_committer(git_object* commit);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_commit_create_from_ids(
            out GitOid id,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string updateRef,
            git_signature* author,
            git_signature* committer,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string encoding,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string message,
            ref GitOid tree,
            UIntPtr parentCount,
            [MarshalAs(UnmanagedType.LPArray)][In] IntPtr[] parents);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_commit_create_buffer(
            GitBuf res,
            git_repository* repo,
            git_signature* author,
            git_signature* committer,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string encoding,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string message,
            git_object* tree,
            UIntPtr parent_count,
            IntPtr* parents /* git_commit** originally */);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_commit_create_with_signature(
            out GitOid id,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string commit_content,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string signature,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string signature_field);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_commit_message(git_object* commit);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_commit_summary(git_object* commit);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_commit_message_encoding(git_object* commit);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_commit_parent_id(git_object* commit, uint n);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate uint Delegate_git_commit_parentcount(git_object* commit);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_commit_tree_id(git_object* commit);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_commit_extract_signature(
            GitBuf signature,
            GitBuf signed_data,
            git_repository* repo,
            ref GitOid commit_id,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string field);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_delete_entry(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_lock(out IntPtr txn, git_config* config);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_delete_multivar(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string regexp);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_set_multivar(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string regexp,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string value);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_config_find__Any(GitBuf path);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_config_free(git_config* cfg);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_config_entry_free(GitConfigEntry* entry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_get_entry(
            out GitConfigEntry* entry,
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_add_file_ondisk(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path,
            uint level,
            git_repository* repo,
            [MarshalAs(UnmanagedType.Bool)] bool force);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_new(out git_config* cfg);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_open_level(
            out git_config* cfg,
            git_config* parent,
            uint level);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_config_parse_bool(
            [MarshalAs(UnmanagedType.Bool)] out bool value,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string valueToParse);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_config_parse_int32(
            [MarshalAs(UnmanagedType.I4)] out int value,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string valueToParse);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_config_parse_int64(
            [MarshalAs(UnmanagedType.I8)] out long value,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string valueToParse);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_set_bool(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.Bool)] bool value);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_set_int32(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            int value);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_set_int64(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            long value);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_set_string(
            git_config* cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string value);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int config_foreach_callback(
            IntPtr entry,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_foreach(
            git_config* cfg,
            config_foreach_callback cb,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_config_iterator_glob_new(
            out IntPtr iter,
            IntPtr cfg,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string regexp);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_config_next(
            out IntPtr entry,
            IntPtr iter);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void Delegate_git_config_iterator_free(IntPtr iter);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_config_snapshot(out git_config* @out, git_config* config);

        // Ordinarily we would decorate the `url` parameter with the StrictUtf8Marshaler like we do everywhere
        // else, but apparently doing a native->managed callback with the 64-bit version of CLR 2.0 can
        // sometimes vomit when using a custom IMarshaler.  So yeah, don't do that.  If you need the url,
        // call StrictUtf8Marshaler.FromNative manually.  See the discussion here:
        // http://social.msdn.microsoft.com/Forums/en-US/netfx64bit/thread/1eb746c6-d695-4632-8a9e-16c4fa98d481
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_cred_acquire_cb(
            out IntPtr cred,
            IntPtr url,
            IntPtr username_from_url,
            GitCredentialType allowed_types,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_credential_default_new(out IntPtr cred);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_credential_userpass_plaintext_new(
            out IntPtr cred,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string username,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string password);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void Delegate_git_credential_free(IntPtr cred);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_describe_commit(
            out git_describe_result* describe,
            git_object* committish,
            ref GitDescribeOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_describe_format(
            GitBuf buf,
            git_describe_result* describe,
            ref GitDescribeFormatOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_describe_result_free(git_describe_result* describe);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_diff_free(git_diff* diff);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_diff_tree_to_tree(
            out git_diff* diff,
            git_repository* repo,
            git_object* oldTree,
            git_object* newTree,
            GitDiffOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_diff_tree_to_index(
            out git_diff* diff,
            git_repository* repo,
            git_object* oldTree,
            git_index* index,
            GitDiffOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_diff_merge(
            git_diff* onto,
            git_diff* from);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_diff_index_to_workdir(
            out git_diff* diff,
            git_repository* repo,
            git_index* index,
            GitDiffOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_diff_tree_to_workdir(
            out git_diff* diff,
            git_repository* repo,
            git_object* oldTree,
            GitDiffOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int git_diff_file_cb(
            [In] git_diff_delta* delta,
            float progress,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int git_diff_hunk_cb(
            [In] git_diff_delta* delta,
            [In] GitDiffHunk hunk,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int git_diff_line_cb(
            [In] git_diff_delta* delta,
            [In] GitDiffHunk hunk,
            [In] GitDiffLine line,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int git_diff_binary_cb(
            [In] git_diff_delta* delta,
            [In] GitDiffBinary binary,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_diff_blobs(
            git_object* oldBlob,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string old_as_path,
            git_object* newBlob,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string new_as_path,
            GitDiffOptions options,
            git_diff_file_cb fileCallback,
            git_diff_binary_cb binaryCallback,
            git_diff_hunk_cb hunkCallback,
            git_diff_line_cb lineCallback,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_diff_foreach(
            git_diff* diff,
            git_diff_file_cb fileCallback,
            git_diff_binary_cb binaryCallback,
            git_diff_hunk_cb hunkCallback,
            git_diff_line_cb lineCallback,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_diff_find_similar(
            git_diff* diff,
            GitDiffFindOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UIntPtr Delegate_git_diff_num_deltas(git_diff* diff);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_diff_delta* Delegate_git_diff_get_delta(git_diff* diff, UIntPtr idx);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_filter_register(
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            IntPtr gitFilter, int priority);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_filter_unregister(
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_filter_source_mode(git_filter_source* source);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_libgit2_features();

        #region git_libgit2_opts

        // Bindings for git_libgit2_opts(int option, ...):
        // Currently only GIT_OPT_GET_SEARCH_PATH and GIT_OPT_SET_SEARCH_PATH are supported,
        // but other overloads could be added using a similar pattern.
        // CallingConvention.Cdecl is used to allow binding the the C varargs signature, and each possible call signature must be enumerated.
        // __argslist was an option, but is an undocumented feature that should likely not be used here.

        // git_libgit2_opts(GIT_OPT_GET_SEARCH_PATH, int level, git_buf *buf)
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_libgit2_opts__1(int option, uint level, GitBuf buf);

        // git_libgit2_opts(GIT_OPT_SET_SEARCH_PATH, int level, const char *path)
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_libgit2_opts__2(int option, uint level,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        // git_libgit2_opts(GIT_OPT_ENABLE_*, int enabled)
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_libgit2_opts__3(int option, int enabled);

        // git_libgit2_opts(GIT_OPT_SET_USER_AGENT, const char *path)
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_libgit2_opts__4(int option,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        // git_libgit2_opts(GIT_OPT_GET_USER_AGENT, git_buf *buf)
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_libgit2_opts__5(int option, GitBuf buf);

        // git_libgit2_opts(GIT_OPT_SET_EXTENSIONS, const char **extensions, size_t len)
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_libgit2_opts__6(int option, IntPtr extensions, UIntPtr len);

        // git_libgit2_opts(GIT_OPT_GET_EXTENSIONS, git_strarray *out)
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_libgit2_opts__7(int option, out GitStrArray extensions);
        #endregion

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_graph_ahead_behind(out UIntPtr ahead, out UIntPtr behind, git_repository* repo, ref GitOid one, ref GitOid two);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_graph_descendant_of(
            git_repository* repo,
            ref GitOid commit,
            ref GitOid ancestor);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_ignore_add_rule(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string rules);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_ignore_clear_internal_rules(git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_ignore_path_is_ignored(
            out int ignored,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_add_bypath(
            git_index* index,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_add(
            git_index* index,
            git_index_entry* entry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_conflict_get(
            out git_index_entry* ancestor,
            out git_index_entry* ours,
            out git_index_entry* theirs,
            git_index* index,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_conflict_iterator_new(
            out git_index_conflict_iterator* iterator,
            git_index* index);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_conflict_next(
            out git_index_entry* ancestor,
            out git_index_entry* ours,
            out git_index_entry* theirs,
            git_index_conflict_iterator* iterator);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_index_conflict_iterator_free(
            git_index_conflict_iterator* iterator);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UIntPtr Delegate_git_index_entrycount(git_index* index);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_entry_stage(git_index_entry* indexentry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_index_free(git_index* index);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_index_entry* Delegate_git_index_get_byindex(git_index* index, UIntPtr n);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_index_entry* Delegate_git_index_get_bypath(
            git_index* index,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path,
            int stage);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_has_conflicts(git_index* index);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UIntPtr Delegate_git_index_name_entrycount(git_index* handle);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_index_name_entry* Delegate_git_index_name_get_byindex(git_index* handle, UIntPtr n);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_open(
            out git_index* index,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath indexpath);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_read(
            git_index* index,
            [MarshalAs(UnmanagedType.Bool)] bool force);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_remove_bypath(
            git_index* index,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UIntPtr Delegate_git_index_reuc_entrycount(git_index* handle);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_index_reuc_entry* Delegate_git_index_reuc_get_byindex(git_index* handle, UIntPtr n);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_index_reuc_entry* Delegate_git_index_reuc_get_bypath(
            git_index* handle,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_write(git_index* index);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_write_tree(out GitOid treeOid, git_index* index);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_write_tree_to(out GitOid treeOid, git_index* index, git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_read_tree(git_index* index, git_object* tree);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_index_clear(git_index* index);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_merge_base_many(
            out GitOid mergeBase,
            git_repository* repo,
            int length,
            [In] GitOid[] input_array);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_merge_base_octopus(
            out GitOid mergeBase,
            git_repository* repo,
            int length,
            [In] GitOid[] input_array);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_annotated_commit_from_ref(
            out git_annotated_commit* annotatedCommit,
            git_repository* repo,
            git_reference* reference);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_annotated_commit_from_fetchhead(
            out git_annotated_commit* annotatedCommit,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string branch_name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string remote_url,
            ref GitOid oid);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_annotated_commit_from_revspec(
            out git_annotated_commit* annotatedCommit,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string revspec);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_annotated_commit_lookup(
            out git_annotated_commit* annotatedCommit,
            git_repository* repo,
            ref GitOid id);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_annotated_commit_id(
            git_annotated_commit* annotatedCommit);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_merge(
            git_repository* repo,
            [In] IntPtr[] their_heads,
            UIntPtr their_heads_len,
            ref GitMergeOpts merge_opts,
            ref GitCheckoutOpts checkout_opts);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_merge_commits(
            out git_index* index,
            git_repository* repo,
            git_object* our_commit,
            git_object* their_commit,
            ref GitMergeOpts merge_opts);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_merge_analysis(
            out GitMergeAnalysis status_out,
            out GitMergePreference preference_out,
            git_repository* repo,
            [In] IntPtr[] their_heads,
            int their_heads_len);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_annotated_commit_free(git_annotated_commit* commit);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_message_prettify(
            GitBuf buf,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string message,
            [MarshalAs(UnmanagedType.Bool)] bool strip_comments,
            sbyte comment_char);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_note_create(
            out GitOid noteOid,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string notes_ref,
            git_signature* author,
            git_signature* committer,
            ref GitOid oid,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string note,
            int force);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_note_free(git_note* note);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_note_message(git_note* note);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_note_id(git_note* note);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_note_read(
            out git_note* note,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string notes_ref,
            ref GitOid oid);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_note_remove(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string notes_ref,
            git_signature* author,
            git_signature* committer,
            ref GitOid oid);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_note_default_ref(
            GitBuf notes_ref,
            git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_note_foreach_cb(
            ref GitOid blob_id,
            ref GitOid annotated_object_id,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_note_foreach(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string notes_ref,
            git_note_foreach_cb cb,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_odb_add_backend(git_odb* odb, IntPtr backend, int priority);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate IntPtr Delegate_git_odb_backend_data_alloc(IntPtr backend, UIntPtr len);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_odb_exists(git_odb* odb, ref GitOid id);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_odb_foreach_cb(
            IntPtr id,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_odb_foreach(
            git_odb* odb,
            git_odb_foreach_cb cb,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_odb_open_wstream(out git_odb_stream* stream, git_odb* odb, Int64 size, GitObjectType type);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_odb_free(git_odb* odb);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_odb_read_header(out UIntPtr len_out, out GitObjectType type, git_odb* odb, ref GitOid id);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_object_free(git_object* obj);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_odb_stream_write(git_odb_stream* Stream, IntPtr Buffer, UIntPtr len);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_odb_stream_finalize_write(out GitOid id, git_odb_stream* stream);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_odb_stream_free(git_odb_stream* stream);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_odb_write(out GitOid id, git_odb* odb, byte* data, UIntPtr len, GitObjectType type);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_object_id(git_object* obj);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_object_lookup(out git_object* obj, git_repository* repo, ref GitOid id, GitObjectType type);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_object_peel(
            out git_object* peeled,
            git_object* obj,
            GitObjectType type);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_object_short_id(
            GitBuf buf,
            git_object* obj);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate GitObjectType Delegate_git_object_type(git_object* obj);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_patch_from_diff(out git_patch* patch, git_diff* diff, UIntPtr idx);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_patch_print(git_patch* patch, git_diff_line_cb print_cb, IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_patch_line_stats(
            out UIntPtr total_context,
            out UIntPtr total_additions,
            out UIntPtr total_deletions,
            git_patch* patch);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_patch_free(git_patch* patch);

        /* Push network progress notification function */
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_push_transfer_progress(uint current, uint total, UIntPtr bytes, IntPtr payload);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_packbuilder_progress(int stage, uint current, uint total, IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_packbuilder_free(git_packbuilder* packbuilder);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_packbuilder_insert(
            git_packbuilder* packbuilder,
            ref GitOid id,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_packbuilder_insert_commit(
            git_packbuilder* packbuilder,
            ref GitOid id);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_packbuilder_insert_recur(
            git_packbuilder* packbuilder,
            ref GitOid id,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_packbuilder_insert_tree(
            git_packbuilder* packbuilder,
            ref GitOid id);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_packbuilder_new(out git_packbuilder* packbuilder, git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UIntPtr Delegate_git_packbuilder_object_count(git_packbuilder* packbuilder);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UInt32 Delegate_git_packbuilder_set_threads(git_packbuilder* packbuilder, UInt32 numThreads);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_packbuilder_write(
            git_packbuilder* packbuilder,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path,
            uint mode,
            IntPtr progressCallback,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UIntPtr Delegate_git_packbuilder_written(git_packbuilder* packbuilder);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reference_create(
            out git_reference* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            ref GitOid oid,
            [MarshalAs(UnmanagedType.Bool)] bool force,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string log_message);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reference_symbolic_create(
            out git_reference* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string target,
            [MarshalAs(UnmanagedType.Bool)] bool force,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string log_message);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int ref_glob_callback(
            IntPtr reference_name,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reference_foreach_glob(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string glob,
            ref_glob_callback cb,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_reference_free(git_reference* reference);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reference_name_is_valid(int* valid,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string refname);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reference_list(out GitStrArray array, git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reference_lookup(
            out git_reference* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_reference_name(git_reference* reference);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reference_remove(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_reference_target(git_reference* reference);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reference_rename(
            out git_reference* ref_out,
            git_reference* reference,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string newName,
            [MarshalAs(UnmanagedType.Bool)] bool force,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string log_message);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reference_set_target(
            out git_reference* ref_out,
            git_reference* reference,
            ref GitOid id,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string log_message);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reference_symbolic_set_target(
            out git_reference* ref_out,
            git_reference* reference,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string target,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string log_message);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_reference_symbolic_target(git_reference* reference);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate GitReferenceType Delegate_git_reference_type(git_reference* reference);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reference_ensure_log(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string refname);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_reflog_free(git_reflog* reflog);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reflog_read(
            out git_reflog* ref_out,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UIntPtr Delegate_git_reflog_entrycount
            (git_reflog* reflog);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_reflog_entry* Delegate_git_reflog_entry_byindex(
            git_reflog* reflog,
            UIntPtr idx);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_reflog_entry_id_old(
            git_reflog_entry* entry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_reflog_entry_id_new(
            git_reflog_entry* entry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_signature* Delegate_git_reflog_entry_committer(
            git_reflog_entry* entry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_reflog_entry_message(git_reflog_entry* entry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_refspec_transform(
            GitBuf buf,
            IntPtr refspec,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_refspec_rtransform(
            GitBuf buf,
            IntPtr refspec,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal delegate string Delegate_git_refspec_string(
            IntPtr refSpec);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate RefSpecDirection Delegate_git_refspec_direction(IntPtr refSpec);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal delegate string Delegate_git_refspec_dst(
            IntPtr refSpec);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal delegate string Delegate_git_refspec_src(
            IntPtr refspec);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate bool Delegate_git_refspec_force(IntPtr refSpec);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate bool Delegate_git_refspec_src_matches(
            IntPtr refspec,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string reference);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate bool Delegate_git_refspec_dst_matches(
            IntPtr refspec,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string reference);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_autotag(git_remote* remote);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_connect(
            git_remote* remote,
            GitDirection direction,
            ref GitRemoteCallbacks callbacks,
            ref GitProxyOptions proxy_options,
            ref GitStrArray custom_headers);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_create(
            out git_remote* remote,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_create_anonymous(
            out git_remote* remote,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_create_with_fetchspec(
            out git_remote* remote,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string refspec);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_delete(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_fetch(
            git_remote* remote,
            ref GitStrArray refspecs,
            GitFetchOptions fetch_opts,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string log_message);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_remote_free(git_remote* remote);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_get_fetch_refspecs(out GitStrArray array, git_remote* remote);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_refspec* Delegate_git_remote_get_refspec(git_remote* remote, UIntPtr n);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_get_push_refspecs(out GitStrArray array, git_remote* remote);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_push(
            git_remote* remote,
            ref GitStrArray refSpecs,
            GitPushOptions opts);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UIntPtr Delegate_git_remote_refspec_count(git_remote* remote);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_set_url(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string remote,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_add_fetch(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string remote,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_set_pushurl(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string remote,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_add_push(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string remote,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_name_is_valid(int* valid,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string remote_name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_list(out GitStrArray array, git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_lookup(
            out git_remote* remote,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_remote_ls(out git_remote_head** heads, out UIntPtr size, git_remote* remote);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_remote_name(git_remote* remote);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_remote_url(git_remote* remote);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_remote_pushurl(git_remote* remote);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_remote_set_autotag(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            TagFetchMode option);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int remote_progress_callback(IntPtr str, int len, IntPtr data);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int remote_completion_callback(RemoteCompletionType type, IntPtr data);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int remote_update_tips_callback(
            IntPtr refName,
            ref GitOid oldId,
            ref GitOid newId,
            IntPtr data);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int push_negotiation_callback(
            IntPtr updates,
            UIntPtr len,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int push_update_reference_callback(
            IntPtr refName,
            IntPtr status,
            IntPtr data
            );

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_repository_discover(
            GitBuf buf,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath start_path,
            [MarshalAs(UnmanagedType.Bool)] bool across_fs,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath ceiling_dirs);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_repository_fetchhead_foreach_cb(
            IntPtr remote_name,
            IntPtr remote_url,
            ref GitOid oid,
            [MarshalAs(UnmanagedType.Bool)] bool is_merge,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_fetchhead_foreach(
            git_repository* repo,
            git_repository_fetchhead_foreach_cb cb,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_repository_free(git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_repository__GetInt(IntPtr repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_ident(
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))] out string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))] out string email,
            git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_index(out git_index* index, git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_init_ext(
            out git_repository* repository,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path,
            GitRepositoryInitOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_state_cleanup(git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_repository_mergehead_foreach_cb(
            ref GitOid oid,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_mergehead_foreach(
            git_repository* repo,
            git_repository_mergehead_foreach_cb cb,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_message(
            GitBuf buf,
            git_repository* repository);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_new(
            out git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_odb(out git_odb* odb, git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_open(
            out git_repository* repository,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_open_ext(
            out git_repository* repository,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath path,
            RepositoryOpenFlags flags,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath ceilingDirs);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxFilePathNoCleanupMarshaler))]
        internal unsafe delegate FilePath Delegate_git_repository_path(git_repository* repository);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_set_config(
            git_repository* repository,
            git_config* config);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_set_ident(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string email);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_set_index(
            git_repository* repository,
            git_index* index);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_set_workdir(
            git_repository* repository,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath workdir,
            [MarshalAs(UnmanagedType.Bool)] bool update_gitlink);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_set_head_detached(
            git_repository* repo,
            ref GitOid commitish);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_set_head_detached_from_annotated(
            git_repository* repo,
            git_annotated_commit* commit);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_set_head(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string refname);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_state(
            git_repository* repository);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxFilePathNoCleanupMarshaler))]
        internal unsafe delegate FilePath Delegate_git_repository_workdir__1(git_repository* repository);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxFilePathNoCleanupMarshaler))]
        internal delegate FilePath Delegate_git_repository_workdir__2(IntPtr repository);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_reset(
            git_repository* repo,
            git_object* target,
            ResetMode reset_type,
            ref GitCheckoutOpts opts);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_revert(
            git_repository* repo,
            git_object* commit,
            GitRevertOpts opts);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_revert_commit(
            out git_index* index,
            git_repository* repo,
            git_object* revert_commit,
            git_object* our_commit,
            uint mainline,
            ref GitMergeOpts opts);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_revparse_ext(
            out git_object* obj,
            out git_reference* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string spec);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_revwalk_free(git_revwalk* walker);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_revwalk_hide(git_revwalk* walker, ref GitOid commit_id);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_revwalk_new(out git_revwalk* walker, git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_revwalk_next(out GitOid id, git_revwalk* walker);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_revwalk_push(git_revwalk* walker, ref GitOid id);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_revwalk_reset(git_revwalk* walker);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_revwalk_sorting(git_revwalk* walk, CommitSortStrategies sort);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_revwalk_simplify_first_parent(git_revwalk* walk);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_signature_free(git_signature* signature);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_signature_new(
            out git_signature* signature,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string email,
            long time,
            int offset);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_signature_now(
            out git_signature* signature,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string email);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_signature_dup(out git_signature* dest, git_signature* sig);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_stash_save(
            out GitOid id,
            git_repository* repo,
            git_signature* stasher,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string message,
            StashModifiers flags);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_stash_cb(
            UIntPtr index,
            IntPtr message,
            ref GitOid stash_id,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_stash_foreach(
            git_repository* repo,
            git_stash_cb cb,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_stash_drop(git_repository* repo, UIntPtr index);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_stash_apply(
            git_repository* repo,
            UIntPtr index,
            GitStashApplyOpts opts);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_stash_pop(
            git_repository* repo,
            UIntPtr index,
            GitStashApplyOpts opts);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_status_file(
            out FileStatus statusflags,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath filepath);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_status_list_new(
            out git_status_list* git_status_list,
            git_repository* repo,
            GitStatusOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_status_list_entrycount(
            git_status_list* statusList);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_status_entry* Delegate_git_status_byindex(
            git_status_list* list,
            UIntPtr idx);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_status_list_free(
            git_status_list* statusList);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void Delegate_git_strarray_dispose(
            ref GitStrArray array);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_submodule_lookup(
            out git_submodule* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_submodule_resolve_url(
            GitBuf buf,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string url);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_submodule_update(
            git_submodule* sm,
            [MarshalAs(UnmanagedType.Bool)] bool init,
            ref GitSubmoduleUpdateOptions submoduleUpdateOptions);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int submodule_callback(
            IntPtr sm,
            IntPtr name,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_submodule_foreach(
            git_repository* repo,
            submodule_callback cb,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_submodule_add_to_index(
            git_submodule* submodule,
            [MarshalAs(UnmanagedType.Bool)] bool write_index);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_submodule_free(git_submodule* submodule);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_submodule_path(
            git_submodule* submodule);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_submodule_url(
            git_submodule* submodule);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_submodule_index_id(
            git_submodule* submodule);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_submodule_head_id(
            git_submodule* submodule);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_submodule_wd_id(
            git_submodule* submodule);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate SubmoduleIgnore Delegate_git_submodule_ignore(
            git_submodule* submodule);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate SubmoduleUpdate Delegate_git_submodule_update_strategy(
            git_submodule* submodule);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate SubmoduleRecurse Delegate_git_submodule_fetch_recurse_submodules(
            git_submodule* submodule);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_submodule_reload(
            git_submodule* submodule,
            [MarshalAs(UnmanagedType.Bool)] bool force);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_submodule_status(
            out SubmoduleStatus status,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictFilePathMarshaler))] FilePath name,
            GitSubmoduleIgnore ignore);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_submodule_init(
            git_submodule* submodule,
            [MarshalAs(UnmanagedType.Bool)] bool overwrite);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_tag_annotation_create(
            out GitOid oid,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            git_object* target,
            git_signature* signature,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string message);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_tag_create(
            out GitOid oid,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            git_object* target,
            git_signature* signature,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string message,
            [MarshalAs(UnmanagedType.Bool)]
            bool force);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_tag_create_lightweight(
            out GitOid oid,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            git_object* target,
            [MarshalAs(UnmanagedType.Bool)]
            bool force);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_tag_delete(
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string tagName);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_tag_list(out GitStrArray array, git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_tag_message(git_object* tag);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_tag_name(git_object* tag);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_signature* Delegate_git_tag_tagger(git_object* tag);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_tag_target_id(git_object* tag);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate GitObjectType Delegate_git_tag_target_type(git_object* tag);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_libgit2_init();

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_libgit2_shutdown();

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_openssl_set_locking();

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void git_trace_cb(LogLevel level, IntPtr message);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_trace_set(LogLevel level, git_trace_cb trace_cb);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_transfer_progress_callback(ref GitTransferProgress stats, IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int git_transport_cb(out IntPtr transport, IntPtr remote, IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int git_transport_certificate_check_cb(git_certificate* cert, int valid, IntPtr hostname, IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_transport_register(
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string prefix,
            IntPtr transport_cb,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_transport_smart(
            out IntPtr transport,
            IntPtr remote,
            IntPtr definition);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_transport_smart_certificate_check(
            IntPtr transport,
            IntPtr cert,
            int valid,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string hostname);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_transport_smart_credentials(
            out IntPtr cred_out,
            IntPtr transport,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string user,
            int methods);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_transport_unregister(
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string prefix);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate uint Delegate_git_tree_entry_filemode(git_tree_entry* entry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_tree_entry* Delegate_git_tree_entry_byindex(git_object* tree, UIntPtr idx);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_tree_entry_bypath(
            out git_tree_entry* tree,
            git_object* root,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string treeentry_path);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_tree_entry_free(git_tree_entry* treeEntry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate git_oid* Delegate_git_tree_entry_id(git_tree_entry* entry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
        internal unsafe delegate string Delegate_git_tree_entry_name(git_tree_entry* entry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate GitObjectType Delegate_git_tree_entry_type(git_tree_entry* entry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate UIntPtr Delegate_git_tree_entrycount(git_object* tree);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_treebuilder_new(out git_treebuilder* builder, git_repository* repo, IntPtr src);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_treebuilder_insert(
            IntPtr entry_out,
            git_treebuilder* builder,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string treeentry_name,
            ref GitOid id,
            uint attributes);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_treebuilder_write(out GitOid id, git_treebuilder* bld);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_treebuilder_free(git_treebuilder* bld);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_blob_is_binary(git_object* blob);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_cherrypick(git_repository* repo, git_object* commit, GitCherryPickOptions options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_cherrypick_commit(out git_index* index,
            git_repository* repo,
            git_object* cherrypick_commit,
            git_object* our_commit,
            uint mainline,
            ref GitMergeOpts options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int Delegate_git_transaction_commit(IntPtr txn);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate void Delegate_git_transaction_free(IntPtr txn);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int url_resolve_callback(
            IntPtr url_resolved,
            IntPtr url,
            int direction,
            IntPtr payload);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate void Delegate_git_worktree_free(git_worktree* worktree);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_worktree_lookup(
            out git_worktree* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_worktree_list(
            out GitStrArray array,
            git_repository* repo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_repository_open_from_worktree(
            out git_repository* repository,
            git_worktree* worktree);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_worktree_is_locked(
            GitBuf reason,
            git_worktree* worktree);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_worktree_validate(
            git_worktree* worktree);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_worktree_lock(
            git_worktree* worktree,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string reason);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_worktree_unlock(
            git_worktree* worktree);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_worktree_add(
            out git_worktree* reference,
            git_repository* repo,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string name,
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalCookie = "git2", MarshalTypeRef = typeof(StrictUtf8Marshaler))] string path,
            git_worktree_add_options options);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal unsafe delegate int Delegate_git_worktree_prune(
            git_worktree* worktree,
            git_worktree_prune_options options);
        #endregion
    }
#endif

    internal class ObjectSafeWrapper : IDisposable
    {
        private readonly ObjectHandle objectPtr;

        public unsafe ObjectSafeWrapper(ObjectId id, RepositoryHandle handle, bool allowNullObjectId = false, bool throwIfMissing = false)
        {
            Ensure.ArgumentNotNull(handle, "handle");

            if (allowNullObjectId && id == null)
            {
                objectPtr = new ObjectHandle(null, false);
            }
            else
            {
                Ensure.ArgumentNotNull(id, "id");
                objectPtr = Proxy.git_object_lookup(handle, id, GitObjectType.Any);
            }

            if (objectPtr == null && throwIfMissing)
            {
                throw new NotFoundException("No valid git object identified by '"+id+"' exists in the repository.");
            }
        }

        public ObjectHandle ObjectPtr { get { return objectPtr; } }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            objectPtr.SafeDispose();
        }
    }

    internal struct git_tree_entry {}
    internal struct git_reference { }
    internal struct git_refspec {}
    internal struct git_repository {}
    internal struct git_status_list {}
    internal struct git_blame {}
    internal struct git_diff {}
    internal struct git_patch {}
    internal struct git_config {}
    internal struct git_index_conflict_iterator {}
    internal struct git_index {}
    internal struct git_reflog {}
    internal struct git_reflog_entry {}
    internal struct git_treebuilder {}
    internal struct git_packbuilder {}
    internal struct git_note {}
    internal struct git_describe_result {}
    internal struct git_submodule {}
    internal struct git_annotated_commit {}
    internal struct git_odb {}
    internal struct git_revwalk {}
    internal struct git_remote {}
    internal struct git_object {}
    internal struct git_rebase {}
    internal struct git_odb_stream {}
    internal struct git_worktree { }

    internal class PackbuilderCallbacks
    {
        private readonly PackBuilderProgressHandler onPackBuilderProgress;

        /// <summary>S
        /// Constructor to set up the native callback given managed delegate.
        /// </summary>
        /// <param name="onPackBuilderProgress">The <see cref="PackBuilderProgressHandler"/> delegate that the git_packbuilder_progress will call.</param>
        internal PackbuilderCallbacks(PackBuilderProgressHandler onPackBuilderProgress)
        {
            this.onPackBuilderProgress = onPackBuilderProgress;
        }

        /// <summary>
        /// Generates a delegate that matches the native git_packbuilder_progress function's signature and wraps the <see cref="PackBuilderProgressHandler"/> delegate.
        /// </summary>
        /// <returns>A delegate method with a signature that matches git_transfer_progress_callback.</returns>
        internal NativeMethods.git_packbuilder_progress GenerateCallback()
        {
            if (onPackBuilderProgress == null)
            {
                return null;
            }

            return new PackbuilderCallbacks(onPackBuilderProgress).OnGitPackBuilderProgress;
        }

        private int OnGitPackBuilderProgress(int stage, uint current, uint total, IntPtr payload)
        {
            return Proxy.ConvertResultToCancelFlag(onPackBuilderProgress((PackBuilderStage)stage, (int)current, (int)total));
        }
    }

    internal class PathCase
    {
        private readonly StringComparer comparer;
        private readonly StringComparison comparison;

        public PathCase(IRepository repo)
        {
            var value = repo.Config.Get<bool>("core.ignorecase");
            switch (value != null && value.Value)
            {
                case true:
                    comparer = StringComparer.OrdinalIgnoreCase;
                    comparison = StringComparison.OrdinalIgnoreCase;
                    break;

                default:
                    comparer = StringComparer.Ordinal;
                    comparison = StringComparison.Ordinal;
                    break;
            }
        }

        public StringComparer Comparer
        {
            get { return comparer; }
        }

        public bool StartsWith(string path, string value)
        {
            return path != null && path.StartsWith(value, comparison);
        }
    }

#if !LIBGIT2_USE_INTERNAL_DLL && LIBGIT2_ORIGINAL_DLL_LOADING
    internal enum OperatingSystemType
    {
        Windows,
        Unix,
        MacOSX
    }

    internal static class Platform
    {
        public static string ProcessorArchitecture { get { return RuntimeInformation.ProcessArchitecture.ToString().ToLowerInvariant(); } }

        public static OperatingSystemType OperatingSystem
        {
            get
            {
                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                {
                    return OperatingSystemType.Windows;
                }

                if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                {
                    return OperatingSystemType.Unix;
                }

                if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                {
                    return OperatingSystemType.MacOSX;
                }

                throw new PlatformNotSupportedException();
            }
        }

        public static string GetNativeLibraryExtension()
        {
            switch (OperatingSystem)
            {
                case OperatingSystemType.MacOSX:
                    return ".dylib";

                case OperatingSystemType.Unix:
                    return ".so";

                case OperatingSystemType.Windows:
                    return ".dll";
            }

            throw new PlatformNotSupportedException();
        }

        /// <summary>
        /// Returns true if the runtime is Mono.
        /// </summary>
        public static bool IsRunningOnMono()
            { return Type.GetType("Mono.Runtime") != null; }

        /// <summary>
        /// Returns true if the runtime is .NET Framework.
        /// </summary>
        public static bool IsRunningOnNetFramework()
            { return typeof(object).Assembly.GetName().Name == "mscorlib" && !IsRunningOnMono(); }

        /// <summary>
        /// Returns true if the runtime is .NET Core.
        /// </summary>
        public static bool IsRunningOnNetCore()
            { return typeof(object).Assembly.GetName().Name != "mscorlib"; }
    }
#endif

    internal class Proxy
    {
#if !LIBGIT2_USE_INTERNAL_DLL && LIBGIT2_ORIGINAL_DLL_LOADING
        internal static readonly bool isOSXArm64 = RuntimeInformation.ProcessArchitecture == Architecture.Arm64
                                                   && RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
#elif !LIBGIT2_USE_INTERNAL_DLL
        internal static readonly bool isOSXArm64 = false;
#endif

        #region git_blame_

        public static unsafe BlameHandle git_blame_file(
            RepositoryHandle repo,
            string path,
            git_blame_options options)
        {
            git_blame* ptr;
            int res = NativeMethods.git_blame_file(out ptr, repo, path, options);
            Ensure.ZeroResult(res);
            return new BlameHandle(ptr, true);
        }

        public static unsafe git_blame_hunk* git_blame_get_hunk_byindex(BlameHandle blame, uint idx)
        {
            return NativeMethods.git_blame_get_hunk_byindex(blame, idx);
        }

        #endregion

        #region git_blob_

        public static unsafe IntPtr git_blob_create_from_stream(RepositoryHandle repo, string hintpath)
        {
            IntPtr writestream_ptr;

            Ensure.ZeroResult(NativeMethods.git_blob_create_from_stream(out writestream_ptr, repo, hintpath));
            return writestream_ptr;
        }

        public static unsafe ObjectId git_blob_create_fromstream_commit(IntPtr writestream_ptr)
        {
            var oid = new GitOid();
            Ensure.ZeroResult(NativeMethods.git_blob_create_from_stream_commit(ref oid, writestream_ptr));
            return oid;
        }

        public static unsafe ObjectId git_blob_create_from_disk(RepositoryHandle repo, FilePath path)
        {
            var oid = new GitOid();
            int res = NativeMethods.git_blob_create_from_disk(ref oid, repo, path);
            Ensure.ZeroResult(res);

            return oid;
        }

        public static unsafe ObjectId git_blob_create_from_workdir(RepositoryHandle repo, FilePath path)
        {
            var oid = new GitOid();
            int res = NativeMethods.git_blob_create_from_workdir(ref oid, repo, path);
            Ensure.ZeroResult(res);

            return oid;
        }

#if LIBGIT2_HAVE_DEPRECATE
        public static unsafe UnmanagedMemoryStream git_blob_filtered_content_stream(RepositoryHandle repo, ObjectId id, string path, bool check_for_binary_data)
        {
            var buf = new GitBuf();
            var handle = new ObjectSafeWrapper(id, repo, throwIfMissing: true).ObjectPtr;

            return new RawContentStream(handle, h =>
            {
                Ensure.ZeroResult(NativeMethods.git_blob_filtered_content(buf, h, path, check_for_binary_data));
                return buf.ptr;
            },
            h => (long)buf.size,
            new[] { buf });
        }
#endif

        public static unsafe UnmanagedMemoryStream git_blob_rawcontent_stream(RepositoryHandle repo, ObjectId id, Int64 size)
        {
            var handle = new ObjectSafeWrapper(id, repo, throwIfMissing: true).ObjectPtr;
            return new RawContentStream(handle, h => NativeMethods.git_blob_rawcontent(h), h => size);
        }

        public static unsafe long git_blob_rawsize(ObjectHandle obj)
        {
            return NativeMethods.git_blob_rawsize(obj);
        }

        public static unsafe bool git_blob_is_binary(ObjectHandle obj)
        {
            int res = NativeMethods.git_blob_is_binary(obj);
            Ensure.BooleanResult(res);

            return (res == 1);
        }

        #endregion

        #region git_branch_

        public static unsafe ReferenceHandle git_branch_create_from_annotated(RepositoryHandle repo, string branch_name, string targetIdentifier, bool force)
        {
            git_reference* reference;

            using (var annotatedCommit = git_annotated_commit_from_revspec(repo, targetIdentifier))
            {
                int res = NativeMethods.git_branch_create_from_annotated(out reference, repo, branch_name, annotatedCommit, force);
                Ensure.ZeroResult(res);
            }

            return new ReferenceHandle(reference, true);
        }

        public static unsafe void git_branch_delete(ReferenceHandle reference)
        {
            int res = NativeMethods.git_branch_delete(reference);
            Ensure.ZeroResult(res);
        }

        public static IEnumerable<Branch> git_branch_iterator(Repository repo, GitBranchType branchType)
        {
            IntPtr iter;
            var res = NativeMethods.git_branch_iterator_new(out iter, repo.Handle.AsIntPtr(), branchType);
            Ensure.ZeroResult(res);

            try
            {
                while (true)
                {
                    IntPtr refPtr = IntPtr.Zero;
                    GitBranchType _branchType;
                    res = NativeMethods.git_branch_next(out refPtr, out _branchType, iter);
                    if (res == (int)GitErrorCode.IterOver)
                    {
                        yield break;
                    }
                    Ensure.ZeroResult(res);

                    Reference reference;
                    using (var refHandle = new ReferenceHandle(refPtr, true))
                    {
                        reference = Reference.BuildFromPtr<Reference>(refHandle, repo);
                    }
                    yield return new Branch(repo, reference, reference.CanonicalName);
                }
            }
            finally
            {
                NativeMethods.git_branch_iterator_free(iter);
            }
        }

        public static void git_branch_iterator_free(IntPtr iter)
        {
            NativeMethods.git_branch_iterator_free(iter);
        }

        public static unsafe ReferenceHandle git_branch_move(ReferenceHandle reference, string new_branch_name, bool force)
        {
            git_reference* ref_out;
            int res = NativeMethods.git_branch_move(out ref_out, reference, new_branch_name, force);
            Ensure.ZeroResult(res);
            return new ReferenceHandle(ref_out, true);
        }

        public static unsafe string git_branch_remote_name(RepositoryHandle repo, string canonical_branch_name, bool shouldThrowIfNotFound)
        {
            using (var buf = new GitBuf())
            {
                int res = NativeMethods.git_branch_remote_name(buf, repo, canonical_branch_name);

                if (!shouldThrowIfNotFound &&
                    (res == (int)GitErrorCode.NotFound || res == (int)GitErrorCode.Ambiguous))
                {
                    return null;
                }

                Ensure.ZeroResult(res);
                return LaxUtf8Marshaler.FromNative(buf.ptr);
            }
        }

        public static unsafe string git_branch_upstream_name(RepositoryHandle handle, string canonicalReferenceName)
        {
            using (var buf = new GitBuf())
            {
                int res = NativeMethods.git_branch_upstream_name(buf, handle, canonicalReferenceName);
                if (res == (int)GitErrorCode.NotFound)
                {
                    return null;
                }

                Ensure.ZeroResult(res);
                return LaxUtf8Marshaler.FromNative(buf.ptr);
            }
        }

        #endregion

        #region git_buf_

        public static void git_buf_dispose(GitBuf buf)
        {
            NativeMethods.git_buf_dispose(buf);
        }

        #endregion

        #region git_checkout_

        public static unsafe void git_checkout_tree(
            RepositoryHandle repo,
            ObjectId treeId,
            ref GitCheckoutOpts opts)
        {
            using (var osw = new ObjectSafeWrapper(treeId, repo))
            {
                int res = NativeMethods.git_checkout_tree(repo, osw.ObjectPtr, ref opts);
                Ensure.ZeroResult(res);
            }
        }

        public static unsafe void git_checkout_index(RepositoryHandle repo, ObjectHandle treeish, ref GitCheckoutOpts opts)
        {
            int res = NativeMethods.git_checkout_index(repo, treeish, ref opts);
            Ensure.ZeroResult(res);
        }

        #endregion

        #region git_cherry_pick_

        internal static unsafe void git_cherrypick(RepositoryHandle repo, ObjectId commit, GitCherryPickOptions options)
        {
            using (var nativeCommit = git_object_lookup(repo, commit, GitObjectType.Commit))
            {
                int res = NativeMethods.git_cherrypick(repo, nativeCommit, options);
                Ensure.ZeroResult(res);
            }
        }

        internal static unsafe IndexHandle git_cherrypick_commit(RepositoryHandle repo, ObjectHandle cherrypickCommit, ObjectHandle ourCommit, uint mainline, GitMergeOpts opts, out bool earlyStop)
        {
            git_index* index;
            int res = NativeMethods.git_cherrypick_commit(out index, repo, cherrypickCommit, ourCommit, mainline, ref opts);
            if (res == (int)GitErrorCode.MergeConflict)
            {
                earlyStop = true;
            }
            else
            {
                earlyStop = false;
                Ensure.ZeroResult(res);
            }
            return new IndexHandle(index, true);
        }
        #endregion

        #region git_clone_

        public static unsafe RepositoryHandle git_clone(
            string url,
            string workdir,
            ref GitCloneOptions opts)
        {
            git_repository *repo;
            int res = NativeMethods.git_clone(out repo, url, workdir, ref opts);
            Ensure.ZeroResult(res);
            return new RepositoryHandle(repo, true);
        }

        #endregion

        #region git_commit_

        public static unsafe Signature git_commit_author(ObjectHandle obj)
        {
            return new Signature(NativeMethods.git_commit_author(obj));
        }

        public static unsafe Signature git_commit_committer(ObjectHandle obj)
        {
            return new Signature(NativeMethods.git_commit_committer(obj));
        }

        public static unsafe ObjectId git_commit_create(
            RepositoryHandle repo,
            string referenceName,
            Signature author,
            Signature committer,
            string message,
            Tree tree,
            GitOid[] parentIds)
        {
            using (SignatureHandle authorHandle = author.BuildHandle())
            using (SignatureHandle committerHandle = committer.BuildHandle())
            using (var parentPtrs = new ArrayMarshaler<GitOid>(parentIds))
            {
                GitOid commitOid;

                var treeOid = tree.Id.Oid;

                int res = NativeMethods.git_commit_create_from_ids(out commitOid,
                                                                   repo,
                                                                   referenceName,
                                                                   authorHandle,
                                                                   committerHandle,
                                                                   null,
                                                                   message,
                                                                   ref treeOid,
                                                                   (UIntPtr)parentPtrs.Count,
                                                                   parentPtrs.ToArray());

                Ensure.ZeroResult(res);

                return commitOid;
            }
        }

        public static unsafe string git_commit_create_buffer(
            RepositoryHandle repo,
            Signature author,
            Signature committer,
            string message,
            Tree tree,
            Commit[] parents)
        {
            using (SignatureHandle authorHandle = author.BuildHandle())
            using (SignatureHandle committerHandle = committer.BuildHandle())
            using (var treeHandle = Proxy.git_object_lookup(tree.repo.Handle, tree.Id, GitObjectType.Tree))
            using (var buf = new GitBuf())
            {
                ObjectHandle[] handles = new ObjectHandle[0];
                try
                {
                    handles = parents.Select(c => Proxy.git_object_lookup(c.repo.Handle, c.Id, GitObjectType.Commit)).ToArray();
                    var ptrs = handles.Select(p => p.AsIntPtr()).ToArray();
                    int res;
                    fixed(IntPtr* objs = ptrs)
                    {
                        res = NativeMethods.git_commit_create_buffer(buf,
                            repo,
                            authorHandle,
                            committerHandle,
                            null,
                            message,
                            treeHandle,
                            new UIntPtr((ulong)parents.LongCount()),
                            objs);
                    }
                    Ensure.ZeroResult(res);
                }
                finally
                {
                    foreach (var handle in handles)
                    {
                        handle.Dispose();
                    }
                }

                return LaxUtf8Marshaler.FromNative(buf.ptr);
            }
        }

        public static unsafe ObjectId git_commit_create_with_signature(RepositoryHandle repo, string commitContent,
            string signature, string field)
        {
            GitOid id;
            int res = NativeMethods.git_commit_create_with_signature(out id, repo, commitContent, signature, field);
            Ensure.ZeroResult(res);

            return id;
        }

        public static unsafe string git_commit_message(ObjectHandle obj)
        {
            return NativeMethods.git_commit_message(obj);
        }

        public static unsafe string git_commit_summary(ObjectHandle obj)
        {
            return NativeMethods.git_commit_summary(obj);
        }

        public static unsafe string git_commit_message_encoding(ObjectHandle obj)
        {
            return NativeMethods.git_commit_message_encoding(obj);
        }

        public static unsafe ObjectId git_commit_parent_id(ObjectHandle obj, uint i)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_commit_parent_id(obj, i));
        }

        public static int git_commit_parentcount(RepositoryHandle repo, ObjectId id)
        {
            using (var obj = new ObjectSafeWrapper(id, repo))
            {
                return git_commit_parentcount(obj);
            }
        }

        public static unsafe int git_commit_parentcount(ObjectSafeWrapper obj)
        {
            return (int)NativeMethods.git_commit_parentcount(obj.ObjectPtr);
        }

        public static unsafe ObjectId git_commit_tree_id(ObjectHandle obj)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_commit_tree_id(obj));
        }

        public static unsafe SignatureInfo git_commit_extract_signature(RepositoryHandle repo, ObjectId id, string field)
        {
            using (var signature = new GitBuf())
            using (var signedData = new GitBuf())
            {
                var oid = id.Oid;
                Ensure.ZeroResult(NativeMethods.git_commit_extract_signature(signature, signedData, repo, ref oid, field));

                return new SignatureInfo()
                {
                    Signature = LaxUtf8Marshaler.FromNative(signature.ptr, signature.size.ConvertToInt()),
                    SignedData = LaxUtf8Marshaler.FromNative(signedData.ptr, signedData.size.ConvertToInt()),
                };
            }
        }

        #endregion

        #region git_config_

        public static unsafe void git_config_add_file_ondisk(ConfigurationHandle config, FilePath path, ConfigurationLevel level, RepositoryHandle repo)
        {
            // RepositoryHandle does implicit cast voodoo that is not null-safe, thus this explicit check
            git_repository* repoHandle = (repo != null) ? (git_repository*)repo : null;
            int res = NativeMethods.git_config_add_file_ondisk(config, path, (uint)level, repoHandle, true);
            Ensure.ZeroResult(res);
        }

        public static unsafe bool git_config_delete(ConfigurationHandle config, string name)
        {
            int res = NativeMethods.git_config_delete_entry(config, name);

            if (res == (int)GitErrorCode.NotFound)
            {
                return false;
            }

            Ensure.ZeroResult(res);
            return true;
        }

        const string anyValue = ".*";

        public static unsafe bool git_config_delete_multivar(ConfigurationHandle config, string name)
        {
            int res = NativeMethods.git_config_delete_multivar(config, name, anyValue);

            if (res == (int)GitErrorCode.NotFound)
            {
                return false;
            }

            Ensure.ZeroResult(res);
            return true;
        }

        public static FilePath git_config_find_global()
        {
            return ConvertPath(NativeMethods.git_config_find_global);
        }

        public static FilePath git_config_find_system()
        {
            return ConvertPath(NativeMethods.git_config_find_system);
        }

        public static FilePath git_config_find_xdg()
        {
            return ConvertPath(NativeMethods.git_config_find_xdg);
        }

        public static FilePath git_config_find_programdata()
        {
            return ConvertPath(NativeMethods.git_config_find_programdata);
        }

        public static unsafe void git_config_free(git_config *config)
        {
            NativeMethods.git_config_free(config);
        }

        public static unsafe ConfigurationEntry<T> git_config_get_entry<T>(ConfigurationHandle config, string key)
        {
            if (!configurationParser.ContainsKey(typeof(T)))
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "Generic Argument of type '{0}' is not supported.", typeof(T).FullName));
            }

            GitConfigEntry* entry = null;
            try
            {
                var res = NativeMethods.git_config_get_entry(out entry, config, key);
                if (res == (int)GitErrorCode.NotFound)
                {
                    return null;
                }

                Ensure.ZeroResult(res);
                return new ConfigurationEntry<T>(LaxUtf8Marshaler.FromNative(entry->namePtr),
                    (T)configurationParser[typeof(T)](LaxUtf8Marshaler.FromNative(entry->valuePtr)),
                    (ConfigurationLevel)entry->level);
            }
            finally
            {
                NativeMethods.git_config_entry_free(entry);
            }
        }

        public static unsafe ConfigurationHandle git_config_new()
        {
            git_config* handle;
            int res = NativeMethods.git_config_new(out handle);
            Ensure.ZeroResult(res);

            return new ConfigurationHandle(handle, true);
        }

        public static unsafe ConfigurationHandle git_config_open_level(ConfigurationHandle parent, ConfigurationLevel level)
        {
            git_config* handle;
            int res = NativeMethods.git_config_open_level(out handle, parent, (uint)level);

            if (res == (int)GitErrorCode.NotFound)
            {
                return null;
            }

            Ensure.ZeroResult(res);

            return new ConfigurationHandle(handle, true);
        }

        public static bool git_config_parse_bool(string value)
        {
            bool outVal;
            var res = NativeMethods.git_config_parse_bool(out outVal, value);

            Ensure.ZeroResult(res);
            return outVal;
        }

        public static int git_config_parse_int32(string value)
        {
            int outVal;
            var res = NativeMethods.git_config_parse_int32(out outVal, value);

            Ensure.ZeroResult(res);
            return outVal;
        }

        public static long git_config_parse_int64(string value)
        {
            long outVal;
            var res = NativeMethods.git_config_parse_int64(out outVal, value);

            Ensure.ZeroResult(res);
            return outVal;
        }

        public static unsafe void git_config_set_bool(ConfigurationHandle config, string name, bool value)
        {
            int res = NativeMethods.git_config_set_bool(config, name, value);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_config_set_int32(ConfigurationHandle config, string name, int value)
        {
            int res = NativeMethods.git_config_set_int32(config, name, value);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_config_set_int64(ConfigurationHandle config, string name, long value)
        {
            int res = NativeMethods.git_config_set_int64(config, name, value);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_config_set_string(ConfigurationHandle config, string name, string value)
        {
            int res = NativeMethods.git_config_set_string(config, name, value);
            Ensure.ZeroResult(res);
        }

        static readonly string non_existing_regex = Guid.NewGuid().ToString();

        public static unsafe void git_config_add_string(ConfigurationHandle config, string name, string value)
        {
            int res = NativeMethods.git_config_set_multivar(config, name, non_existing_regex, value);
            Ensure.ZeroResult(res);
        }

        public static unsafe ICollection<TResult> git_config_foreach<TResult>(
            ConfigurationHandle config,
            Func<IntPtr, TResult> resultSelector)
        {
            return git_foreach(resultSelector, c => NativeMethods.git_config_foreach(config, (e, p) => c(e, p), IntPtr.Zero));
        }

        public static IEnumerable<ConfigurationEntry<string>> git_config_iterator_glob(
            ConfigurationHandle config,
            string regexp)
        {
            IntPtr iter;
            var res = NativeMethods.git_config_iterator_glob_new(out iter, config.AsIntPtr(), regexp);
            Ensure.ZeroResult(res);
            try
            {
                while (true)
                {
                    IntPtr entry;
                    res = NativeMethods.git_config_next(out entry, iter);
                    if (res == (int)GitErrorCode.IterOver)
                    {
                        yield break;
                    }
                    Ensure.ZeroResult(res);

                    yield return Configuration.BuildConfigEntry(entry);
                }
            }
            finally
            {
                NativeMethods.git_config_iterator_free(iter);
            }
        }

        public static unsafe ConfigurationHandle git_config_snapshot(ConfigurationHandle config)
        {
            git_config* handle;
            int res = NativeMethods.git_config_snapshot(out handle, config);
            Ensure.ZeroResult(res);

            return new ConfigurationHandle(handle, true);
        }

        public static unsafe IntPtr git_config_lock(git_config* config)
        {
            IntPtr txn;
            int res = NativeMethods.git_config_lock(out txn, config);
            Ensure.ZeroResult(res);

            return txn;
        }

        #endregion

        #region git_cred_

        public static void git_cred_free(IntPtr cred)
        {
            NativeMethods.git_credential_free(cred);
        }

        #endregion

        #region git_describe_

        public static unsafe string git_describe_commit(
            RepositoryHandle repo,
            ObjectId committishId,
            DescribeOptions options)
        {
            Ensure.ArgumentPositiveInt32(options.MinimumCommitIdAbbreviatedSize, "options.MinimumCommitIdAbbreviatedSize");

            using (var osw = new ObjectSafeWrapper(committishId, repo))
            {
                GitDescribeOptions opts = new GitDescribeOptions
                {
                    Version = 1,
                    DescribeStrategy = options.Strategy,
                    MaxCandidatesTags = 10,
                    OnlyFollowFirstParent = options.OnlyFollowFirstParent,
                    ShowCommitOidAsFallback = options.UseCommitIdAsFallback,
                };

                DescribeResultHandle describeHandle = null;

                try
                {
                    git_describe_result* result;
                    int res = NativeMethods.git_describe_commit(out result, osw.ObjectPtr, ref opts);
                    Ensure.ZeroResult(res);
                    describeHandle = new DescribeResultHandle(result, true);

                    using (var buf = new GitBuf())
                    {
                        GitDescribeFormatOptions formatOptions = new GitDescribeFormatOptions
                        {
                            Version = 1,
                            MinAbbreviatedSize = (uint)options.MinimumCommitIdAbbreviatedSize,
                            AlwaysUseLongFormat = options.AlwaysRenderLongFormat,
                        };

                        res = NativeMethods.git_describe_format(buf, describeHandle, ref formatOptions);
                        Ensure.ZeroResult(res);

                        describeHandle.Dispose();
                        return LaxUtf8Marshaler.FromNative(buf.ptr);
                    }
                }
                finally
                {
                    if (describeHandle != null)
                    {
                        describeHandle.Dispose();
                    }
                }
            }
        }

        #endregion

        #region git_diff_

        public static unsafe void git_diff_blobs(
            RepositoryHandle repo,
            ObjectId oldBlob,
            ObjectId newBlob,
            GitDiffOptions options,
            NativeMethods.git_diff_file_cb fileCallback,
            NativeMethods.git_diff_hunk_cb hunkCallback,
            NativeMethods.git_diff_line_cb lineCallback)
        {
            using (var osw1 = new ObjectSafeWrapper(oldBlob, repo, true))
            using (var osw2 = new ObjectSafeWrapper(newBlob, repo, true))
            {
                int res = NativeMethods.git_diff_blobs(osw1.ObjectPtr,
                                                       null,
                                                       osw2.ObjectPtr,
                                                       null,
                                                       options,
                                                       fileCallback,
                                                       null,
                                                       hunkCallback,
                                                       lineCallback,
                                                       IntPtr.Zero);

                Ensure.ZeroResult(res);
            }
        }

        public static unsafe void git_diff_foreach(
            git_diff* diff,
            NativeMethods.git_diff_file_cb fileCallback,
            NativeMethods.git_diff_hunk_cb hunkCallback,
            NativeMethods.git_diff_line_cb lineCallback)
        {
            int res = NativeMethods.git_diff_foreach(diff, fileCallback, null, hunkCallback, lineCallback, IntPtr.Zero);
            Ensure.ZeroResult(res);
        }

        public static unsafe DiffHandle git_diff_tree_to_index(
            RepositoryHandle repo,
            IndexHandle index,
            ObjectId oldTree,
            GitDiffOptions options)
        {
            using (var osw = new ObjectSafeWrapper(oldTree, repo, true))
            {
                git_diff* diff;
                int res = NativeMethods.git_diff_tree_to_index(out diff, repo, osw.ObjectPtr, index, options);
                Ensure.ZeroResult(res);

                return new DiffHandle(diff, true);
            }
        }

        public static unsafe void git_diff_merge(DiffHandle onto, DiffHandle from)
        {
            int res = NativeMethods.git_diff_merge(onto, from);
            Ensure.ZeroResult(res);
        }

        public static unsafe DiffHandle git_diff_tree_to_tree(
            RepositoryHandle repo,
            ObjectId oldTree,
            ObjectId newTree,
            GitDiffOptions options)
        {
            using (var osw1 = new ObjectSafeWrapper(oldTree, repo, true, throwIfMissing: true))
            using (var osw2 = new ObjectSafeWrapper(newTree, repo, true, throwIfMissing: true))
            {
                git_diff* diff;
                int res = NativeMethods.git_diff_tree_to_tree(out diff, repo, osw1.ObjectPtr, osw2.ObjectPtr, options);
                Ensure.ZeroResult(res);

                return new DiffHandle(diff, true);
            }
        }

        public static unsafe DiffHandle git_diff_index_to_workdir(
            RepositoryHandle repo,
            IndexHandle index,
            GitDiffOptions options)
        {
            git_diff* diff;
            int res = NativeMethods.git_diff_index_to_workdir(out diff, repo, index, options);
            Ensure.ZeroResult(res);

            return new DiffHandle(diff, true);
        }

        public static unsafe DiffHandle git_diff_tree_to_workdir(
           RepositoryHandle repo,
           ObjectId oldTree,
           GitDiffOptions options)
        {
            using (var osw = new ObjectSafeWrapper(oldTree, repo, true))
            {
                git_diff* diff;
                int res = NativeMethods.git_diff_tree_to_workdir(out diff, repo, osw.ObjectPtr, options);
                Ensure.ZeroResult(res);

                return new DiffHandle(diff, true);
            }
        }

        public static unsafe void git_diff_find_similar(DiffHandle diff, GitDiffFindOptions options)
        {
            int res = NativeMethods.git_diff_find_similar(diff, options);
            Ensure.ZeroResult(res);
        }

        public static unsafe int git_diff_num_deltas(DiffHandle diff)
        {
            return (int)NativeMethods.git_diff_num_deltas(diff);
        }

        public static unsafe git_diff_delta* git_diff_get_delta(DiffHandle diff, int idx)
        {
            return NativeMethods.git_diff_get_delta(diff, (UIntPtr)idx);
        }

        #endregion

        #region git_error_

        public static int git_error_set_str(GitErrorCategory error_class, Exception exception)
        {
            if (exception is OutOfMemoryException)
            {
                NativeMethods.git_error_set_oom();
                return 0;
            }
            else
            {
                return NativeMethods.git_error_set_str(error_class, ErrorMessageFromException(exception));
            }
        }

        public static int git_error_set_str(GitErrorCategory error_class, String errorString)
        {
            return NativeMethods.git_error_set_str(error_class, errorString);
        }

        /// <summary>
        /// This method will take an exception and try to generate an error message
        /// that captures the important messages of the error.
        /// The formatting is a bit subjective.
        /// </summary>
        /// <param name="ex"></param>
        /// <returns></returns>
        public static string ErrorMessageFromException(Exception ex)
        {
            StringBuilder sb = new StringBuilder();
            BuildErrorMessageFromException(sb, 0, ex);
            return sb.ToString();
        }

        private static void BuildErrorMessageFromException(StringBuilder sb, int level, Exception ex)
        {
            string indent = new string(' ', level * 4);
            sb.AppendFormat("{0}{1}", indent, ex.Message);

            if (ex is AggregateException)
            {
                AggregateException aggregateException = ((AggregateException)ex).Flatten();

                if (aggregateException.InnerExceptions.Count == 1)
                {
                    sb.AppendLine();
                    sb.AppendLine();

                    sb.AppendFormat("{0}Contained Exception:{1}", indent, Environment.NewLine);
                    BuildErrorMessageFromException(sb, level + 1, aggregateException.InnerException);
                }
                else
                {
                    sb.AppendLine();
                    sb.AppendLine();

                    sb.AppendFormat("{0}Contained Exceptions:{1}", indent, Environment.NewLine);
                    for (int i = 0; i < aggregateException.InnerExceptions.Count; i++)
                    {
                        if (i != 0)
                        {
                            sb.AppendLine();
                            sb.AppendLine();
                        }

                        BuildErrorMessageFromException(sb, level + 1, aggregateException.InnerExceptions[i]);
                    }
                }
            }
            else if (ex.InnerException != null)
            {
                sb.AppendLine();
                sb.AppendLine();
                sb.AppendFormat("{0}Inner Exception:{1}", indent, Environment.NewLine);
                BuildErrorMessageFromException(sb, level + 1, ex.InnerException);
            }
        }

        #endregion

        #region git_filter_

        public static void git_filter_register(string name, IntPtr filterPtr, int priority)
        {
            int res = NativeMethods.git_filter_register(name, filterPtr, priority);
            if (res == (int)GitErrorCode.Exists)
            {
                throw new EntryExistsException("A filter with the name '{0}' is already registered", name);
            }
            Ensure.ZeroResult(res);
        }

        public static void git_filter_unregister(string name)
        {
            int res = NativeMethods.git_filter_unregister(name);
            Ensure.ZeroResult(res);
        }

        public static unsafe FilterMode git_filter_source_mode(git_filter_source* filterSource)
        {
            var res = NativeMethods.git_filter_source_mode(filterSource);
            return (FilterMode)res;
        }

        #endregion

        #region git_graph_

        public static unsafe Tuple<int?, int?> git_graph_ahead_behind(RepositoryHandle repo, Commit first, Commit second)
        {
            if (first == null || second == null)
            {
                return new Tuple<int?, int?>(null, null);
            }

            GitOid oid1 = first.Id.Oid;
            GitOid oid2 = second.Id.Oid;

            UIntPtr ahead;
            UIntPtr behind;

            int res = NativeMethods.git_graph_ahead_behind(out ahead, out behind, repo, ref oid1, ref oid2);

            Ensure.ZeroResult(res);

            return new Tuple<int?, int?>((int)ahead, (int)behind);
        }

        public static unsafe bool git_graph_descendant_of(RepositoryHandle repo, ObjectId commitId, ObjectId ancestorId)
        {
            GitOid oid1 = commitId.Oid;
            GitOid oid2 = ancestorId.Oid;
            int res = NativeMethods.git_graph_descendant_of(repo, ref oid1, ref oid2);

            Ensure.BooleanResult(res);

            return (res == 1);
        }

        #endregion

        #region git_ignore_

        public static unsafe void git_ignore_add_rule(RepositoryHandle repo, string rules)
        {
            int res = NativeMethods.git_ignore_add_rule(repo, rules);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_ignore_clear_internal_rules(RepositoryHandle repo)
        {
            int res = NativeMethods.git_ignore_clear_internal_rules(repo);
            Ensure.ZeroResult(res);
        }

        public static unsafe bool git_ignore_path_is_ignored(RepositoryHandle repo, string path)
        {
            int ignored;
            int res = NativeMethods.git_ignore_path_is_ignored(out ignored, repo, path);
            Ensure.ZeroResult(res);

            return (ignored != 0);
        }

        #endregion

        #region git_index_

        public static unsafe void git_index_add(IndexHandle index, git_index_entry* entry)
        {
            int res = NativeMethods.git_index_add(index, entry);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_index_add_bypath(IndexHandle index, FilePath path)
        {
            int res = NativeMethods.git_index_add_bypath(index, path);
            Ensure.ZeroResult(res);
        }

        public static unsafe Conflict git_index_conflict_get(
            IndexHandle index,
            string path)
        {
            git_index_entry* ancestor, ours, theirs;

            int res = NativeMethods.git_index_conflict_get(out ancestor,
                                                           out ours,
                                                           out theirs,
                                                           index,
                                                           path);

            if (res == (int)GitErrorCode.NotFound)
            {
                return null;
            }

            Ensure.ZeroResult(res);

            return new Conflict(IndexEntry.BuildFromPtr(ancestor),
                                IndexEntry.BuildFromPtr(ours),
                                IndexEntry.BuildFromPtr(theirs));
        }

        public static unsafe ConflictIteratorHandle git_index_conflict_iterator_new(IndexHandle index)
        {
            git_index_conflict_iterator* iter;
            int res = NativeMethods.git_index_conflict_iterator_new(out iter, index);
            Ensure.ZeroResult(res);

            return new ConflictIteratorHandle(iter, true);
        }

        public static unsafe Conflict git_index_conflict_next(ConflictIteratorHandle iterator)
        {
            git_index_entry* ancestor, ours, theirs;

            int res = NativeMethods.git_index_conflict_next(out ancestor, out ours, out theirs, iterator);

            if (res == (int)GitErrorCode.IterOver)
            {
                return null;
            }

            Ensure.ZeroResult(res);

            return new Conflict(IndexEntry.BuildFromPtr(ancestor),
                                IndexEntry.BuildFromPtr(ours),
                                IndexEntry.BuildFromPtr(theirs));
        }

        public static unsafe int git_index_entrycount(IndexHandle index)
        {
            return NativeMethods.git_index_entrycount(index)
                .ConvertToInt();
        }

        public static unsafe StageLevel git_index_entry_stage(git_index_entry* entry)
        {
            return (StageLevel)NativeMethods.git_index_entry_stage(entry);
        }

        public static unsafe git_index_entry* git_index_get_byindex(IndexHandle index, UIntPtr n)
        {
            return NativeMethods.git_index_get_byindex(index, n);
        }

        public static unsafe git_index_entry* git_index_get_bypath(IndexHandle index, string path, int stage)
        {
            return NativeMethods.git_index_get_bypath(index, path, stage);
        }

        public static unsafe bool git_index_has_conflicts(IndexHandle index)
        {
            int res = NativeMethods.git_index_has_conflicts(index);
            Ensure.BooleanResult(res);

            return res != 0;
        }

        public static unsafe int git_index_name_entrycount(IndexHandle index)
        {
            return NativeMethods.git_index_name_entrycount(index)
                .ConvertToInt();
        }

        public static unsafe git_index_name_entry* git_index_name_get_byindex(IndexHandle index, UIntPtr n)
        {
            return NativeMethods.git_index_name_get_byindex(index, n);
        }

        public static unsafe IndexHandle git_index_open(FilePath indexpath)
        {
            git_index* handle;
            int res = NativeMethods.git_index_open(out handle, indexpath);
            Ensure.ZeroResult(res);

            return new IndexHandle(handle, true);
        }

        public static unsafe void git_index_read(IndexHandle index)
        {
            int res = NativeMethods.git_index_read(index, false);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_index_remove_bypath(IndexHandle index, string path)
        {
            int res = NativeMethods.git_index_remove_bypath(index, path);
            Ensure.ZeroResult(res);
        }

        public static unsafe int git_index_reuc_entrycount(IndexHandle index)
        {
            return NativeMethods.git_index_reuc_entrycount(index)
                .ConvertToInt();
        }

        public static unsafe git_index_reuc_entry* git_index_reuc_get_byindex(IndexHandle index, UIntPtr n)
        {
            return NativeMethods.git_index_reuc_get_byindex(index, n);
        }

        public static unsafe git_index_reuc_entry* git_index_reuc_get_bypath(IndexHandle index, string path)
        {
            return NativeMethods.git_index_reuc_get_bypath(index, path);
        }

        public static unsafe void git_index_write(IndexHandle index)
        {
            int res = NativeMethods.git_index_write(index);
            Ensure.ZeroResult(res);
        }

        public static unsafe ObjectId git_index_write_tree(IndexHandle index)
        {
            GitOid treeOid;
            int res = NativeMethods.git_index_write_tree(out treeOid, index);
            Ensure.ZeroResult(res);

            return treeOid;
        }

        public static unsafe ObjectId git_index_write_tree_to(IndexHandle index, RepositoryHandle repo)
        {
            GitOid treeOid;
            int res = NativeMethods.git_index_write_tree_to(out treeOid, index, repo);
            Ensure.ZeroResult(res);

            return treeOid;
        }

        public static unsafe void git_index_read_fromtree(Index index, ObjectHandle tree)
        {
            int res = NativeMethods.git_index_read_tree(index.Handle, tree);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_index_clear(Index index)
        {
            int res = NativeMethods.git_index_clear(index.Handle);
            Ensure.ZeroResult(res);
        }

        #endregion

        #region git_merge_

        public static unsafe IndexHandle git_merge_commits(RepositoryHandle repo, ObjectHandle ourCommit, ObjectHandle theirCommit, GitMergeOpts opts, out bool earlyStop)
        {
            git_index* index;
            int res = NativeMethods.git_merge_commits(out index, repo, ourCommit, theirCommit, ref opts);
            if (res == (int)GitErrorCode.MergeConflict)
            {
                earlyStop = true;
            }
            else
            {
                earlyStop = false;
                Ensure.ZeroResult(res);
            }

            return new IndexHandle(index, true);
        }

        public static unsafe ObjectId git_merge_base_many(RepositoryHandle repo, GitOid[] commitIds)
        {
            GitOid ret;
            int res = NativeMethods.git_merge_base_many(out ret, repo, commitIds.Length, commitIds);

            if (res == (int)GitErrorCode.NotFound)
            {
                return null;
            }

            Ensure.ZeroResult(res);

            return ret;
        }

        public static unsafe ObjectId git_merge_base_octopus(RepositoryHandle repo, GitOid[] commitIds)
        {
            GitOid ret;
            int res = NativeMethods.git_merge_base_octopus(out ret, repo, commitIds.Length, commitIds);

            if (res == (int)GitErrorCode.NotFound)
            {
                return null;
            }

            Ensure.ZeroResult(res);

            return ret;
        }

        public static unsafe AnnotatedCommitHandle git_annotated_commit_from_fetchhead(RepositoryHandle repo, string branchName, string remoteUrl, GitOid oid)
        {
            git_annotated_commit* commit;

            int res = NativeMethods.git_annotated_commit_from_fetchhead(out commit, repo, branchName, remoteUrl, ref oid);

            Ensure.ZeroResult(res);

            return new AnnotatedCommitHandle(commit, true);
        }

        public static unsafe AnnotatedCommitHandle git_annotated_commit_lookup(RepositoryHandle repo, GitOid oid)
        {
            git_annotated_commit* commit;

            int res = NativeMethods.git_annotated_commit_lookup(out commit, repo, ref oid);

            Ensure.ZeroResult(res);

            return new AnnotatedCommitHandle(commit, true);
        }

        public static unsafe AnnotatedCommitHandle git_annotated_commit_from_ref(RepositoryHandle repo, ReferenceHandle reference)
        {
            git_annotated_commit* commit;

            int res = NativeMethods.git_annotated_commit_from_ref(out commit, repo, reference);

            Ensure.ZeroResult(res);

            return new AnnotatedCommitHandle(commit, true);
        }

        public static unsafe AnnotatedCommitHandle git_annotated_commit_from_revspec(RepositoryHandle repo, string revspec)
        {
            git_annotated_commit* commit;

            int res = NativeMethods.git_annotated_commit_from_revspec(out commit, repo, revspec);

            Ensure.ZeroResult(res);

            return new AnnotatedCommitHandle(commit, true);
        }

        public static unsafe ObjectId git_annotated_commit_id(AnnotatedCommitHandle mergeHead)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_annotated_commit_id(mergeHead));
        }

        public static unsafe void git_merge(RepositoryHandle repo, AnnotatedCommitHandle[] heads, GitMergeOpts mergeOptions, GitCheckoutOpts checkoutOptions, out bool earlyStop)
        {
            IntPtr[] their_heads = heads.Select(head => head.AsIntPtr()).ToArray();

            int res = NativeMethods.git_merge(repo,
                                              their_heads,
                                              (UIntPtr)their_heads.Length,
                                              ref mergeOptions,
                                              ref checkoutOptions);

            if (res == (int)GitErrorCode.MergeConflict)
            {
                earlyStop = true;
            }
            else
            {
                earlyStop = false;
                Ensure.ZeroResult(res);
            }
        }

        public static unsafe void git_merge_analysis(
            RepositoryHandle repo,
            AnnotatedCommitHandle[] heads,
            out GitMergeAnalysis analysis_out,
            out GitMergePreference preference_out)
        {
            IntPtr[] their_heads = heads.Select(head => head.AsIntPtr()).ToArray();

            int res = NativeMethods.git_merge_analysis(out analysis_out,
                                                       out preference_out,
                                                       repo,
                                                       their_heads,
                                                       their_heads.Length);

            Ensure.ZeroResult(res);
        }

        #endregion

        #region git_message_

        public static string git_message_prettify(string message, char? commentChar)
        {
            if (string.IsNullOrEmpty(message))
            {
                return string.Empty;
            }

            int comment = commentChar.GetValueOrDefault();
            if (comment > sbyte.MaxValue)
            {
                throw new InvalidOperationException("Only single byte characters are allowed as commentary characters in a message (eg. '#').");
            }

            using (var buf = new GitBuf())
            {
                int res = NativeMethods.git_message_prettify(buf, message, true, (sbyte)comment);
                Ensure.Int32Result(res);

                return LaxUtf8Marshaler.FromNative(buf.ptr) ?? string.Empty;
            }
        }

        #endregion

        #region git_note_

        public static unsafe ObjectId git_note_create(
            RepositoryHandle repo,
            string notes_ref,
            Signature author,
            Signature committer,
            ObjectId targetId,
            string note,
            bool force)
        {
            using (SignatureHandle authorHandle = author.BuildHandle())
            using (SignatureHandle committerHandle = committer.BuildHandle())
            {
                GitOid noteOid;
                GitOid oid = targetId.Oid;

                int res = NativeMethods.git_note_create(out noteOid, repo, notes_ref, authorHandle, committerHandle, ref oid, note, force ? 1 : 0);
                Ensure.ZeroResult(res);

                return noteOid;
            }
        }

        public static unsafe string git_note_default_ref(RepositoryHandle repo)
        {
            using (var buf = new GitBuf())
            {
                int res = NativeMethods.git_note_default_ref(buf, repo);
                Ensure.ZeroResult(res);

                return LaxUtf8Marshaler.FromNative(buf.ptr);
            }
        }

        public static unsafe ICollection<TResult> git_note_foreach<TResult>(RepositoryHandle repo, string notes_ref, Func<GitOid, GitOid, TResult> resultSelector)
        {
            return git_foreach(resultSelector, c => NativeMethods.git_note_foreach(repo,
                                                                                   notes_ref,
                                                                                   (ref GitOid x, ref GitOid y, IntPtr p) => c(x, y, p),
                                                                                   IntPtr.Zero), GitErrorCode.NotFound);
        }

        public static unsafe string git_note_message(NoteHandle note)
        {
            return NativeMethods.git_note_message(note);
        }

        public static unsafe ObjectId git_note_id(NoteHandle note)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_note_id(note));
        }

        public static unsafe NoteHandle git_note_read(RepositoryHandle repo, string notes_ref, ObjectId id)
        {
            GitOid oid = id.Oid;
            git_note* note;

            int res = NativeMethods.git_note_read(out note, repo, notes_ref, ref oid);

            if (res == (int)GitErrorCode.NotFound)
            {
                return null;
            }

            Ensure.ZeroResult(res);

            return new NoteHandle(note, true);
        }

        public static unsafe void git_note_remove(RepositoryHandle repo, string notes_ref, Signature author, Signature committer, ObjectId targetId)
        {
            using (SignatureHandle authorHandle = author.BuildHandle())
            using (SignatureHandle committerHandle = committer.BuildHandle())
            {
                GitOid oid = targetId.Oid;

                int res = NativeMethods.git_note_remove(repo, notes_ref, authorHandle, committerHandle, ref oid);

                if (res == (int)GitErrorCode.NotFound)
                {
                    return;
                }

                Ensure.ZeroResult(res);
            }
        }

        #endregion

        #region git_object_

        public static unsafe ObjectId git_object_id(ObjectHandle obj)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_object_id(obj));
        }

        public static unsafe ObjectHandle git_object_lookup(RepositoryHandle repo, ObjectId id, GitObjectType type)
        {
            git_object* handle;
            GitOid oid = id.Oid;

            int res = NativeMethods.git_object_lookup(out handle, repo, ref oid, type);
            switch (res)
            {
                case (int)GitErrorCode.NotFound:
                    return null;

                default:
                    Ensure.ZeroResult(res);
                    break;
            }

            return new ObjectHandle(handle, true);
        }

        public static unsafe ObjectHandle git_object_peel(RepositoryHandle repo, ObjectId id, GitObjectType type, bool throwsIfCanNotPeel)
        {
            git_object* peeled;
            int res;

            using (var obj = new ObjectSafeWrapper(id, repo))
            {
                res = NativeMethods.git_object_peel(out peeled, obj.ObjectPtr, type);
            }

            if (!throwsIfCanNotPeel &&
                (res == (int)GitErrorCode.NotFound || res == (int)GitErrorCode.Ambiguous ||
                 res == (int)GitErrorCode.InvalidSpecification || res == (int)GitErrorCode.Peel))
            {
                return null;
            }

            Ensure.ZeroResult(res);
            return new ObjectHandle(peeled, true);
        }

        public static unsafe string git_object_short_id(RepositoryHandle repo, ObjectId id)
        {
            using (var obj = new ObjectSafeWrapper(id, repo))
            using (var buf = new GitBuf())
            {
                int res = NativeMethods.git_object_short_id(buf, obj.ObjectPtr);
                Ensure.Int32Result(res);

                return LaxUtf8Marshaler.FromNative(buf.ptr);
            }
        }

        public static unsafe GitObjectType git_object_type(ObjectHandle obj)
        {
            return NativeMethods.git_object_type(obj);
        }

        #endregion

        #region git_odb_

        public static unsafe void git_odb_add_backend(ObjectDatabaseHandle odb, IntPtr backend, int priority)
        {
            Ensure.ZeroResult(NativeMethods.git_odb_add_backend(odb, backend, priority));
        }

        public static IntPtr git_odb_backend_data_alloc(IntPtr backend, UIntPtr len)
        {
            IntPtr toReturn = NativeMethods.git_odb_backend_data_alloc(backend, len);

            if (IntPtr.Zero == toReturn)
            {
                throw new LibGit2SharpException("Unable to allocate {0} bytes; out of memory",
                                                len,
                                                GitErrorCode.Error,
                                                GitErrorCategory.NoMemory);
            }

            return toReturn;
        }

        public static unsafe bool git_odb_exists(ObjectDatabaseHandle odb, ObjectId id)
        {
            GitOid oid = id.Oid;

            int res = NativeMethods.git_odb_exists(odb, ref oid);
            Ensure.BooleanResult(res);

            return (res == 1);
        }

        public static unsafe GitObjectMetadata git_odb_read_header(ObjectDatabaseHandle odb, ObjectId id)
        {
            GitOid oid = id.Oid;
            UIntPtr length;
            GitObjectType objectType;

            int res = NativeMethods.git_odb_read_header(out length, out objectType, odb, ref oid);
            Ensure.ZeroResult(res);

            return new GitObjectMetadata((long)length, objectType);
        }

        public static unsafe ICollection<ObjectId> git_odb_foreach(ObjectDatabaseHandle odb)
        {
            var list = new List<ObjectId>();

            NativeMethods.git_odb_foreach(odb, (p, _data) =>
                {
                    list.Add(ObjectId.BuildFromPtr(p));
                    return 0;
                }, IntPtr.Zero);

            return list;
        }

        public static unsafe OdbStreamHandle git_odb_open_wstream(ObjectDatabaseHandle odb, long size, GitObjectType type)
        {
            git_odb_stream* stream;
            int res = NativeMethods.git_odb_open_wstream(out stream, odb, size, type);
            Ensure.ZeroResult(res);

            return new OdbStreamHandle(stream, true);
        }

        public static void git_odb_stream_write(OdbStreamHandle stream, byte[] data, int len)
        {
            int res;
            unsafe
            {
                fixed (byte* p = data)
                {
                    res = NativeMethods.git_odb_stream_write(stream, (IntPtr)p, (UIntPtr)len);
                }
            }

            Ensure.ZeroResult(res);
        }

        public static unsafe ObjectId git_odb_stream_finalize_write(OdbStreamHandle stream)
        {
            GitOid id;
            int res = NativeMethods.git_odb_stream_finalize_write(out id, stream);
            Ensure.ZeroResult(res);

            return id;
        }

        public static unsafe ObjectId git_odb_write(ObjectDatabaseHandle odb, byte[] data, ObjectType type)
        {
            GitOid id;
            int res;
            fixed(byte* p = data)
            {
                res = NativeMethods.git_odb_write(out id, odb, p, new UIntPtr((ulong)data.LongLength), type.ToGitObjectType());
            }
            Ensure.ZeroResult(res);

            return id;
        }

#endregion

#region git_patch_

        public static unsafe PatchHandle git_patch_from_diff(DiffHandle diff, int idx)
        {
            git_patch* handle;
            int res = NativeMethods.git_patch_from_diff(out handle, diff, (UIntPtr)idx);
            Ensure.ZeroResult(res);
            return new PatchHandle(handle, true);
        }

        public static unsafe void git_patch_print(PatchHandle patch, NativeMethods.git_diff_line_cb printCallback)
        {
            int res = NativeMethods.git_patch_print(patch, printCallback, IntPtr.Zero);
            Ensure.ZeroResult(res);
        }

        public static unsafe Tuple<int, int> git_patch_line_stats(PatchHandle patch)
        {
            UIntPtr ctx, add, del;
            int res = NativeMethods.git_patch_line_stats(out ctx, out add, out del, patch);
            Ensure.ZeroResult(res);
            return new Tuple<int, int>((int)add, (int)del);
        }

#endregion

#region git_packbuilder_

        public static unsafe PackBuilderHandle git_packbuilder_new(RepositoryHandle repo)
        {
            git_packbuilder* handle;

            int res = NativeMethods.git_packbuilder_new(out handle, repo);
            Ensure.ZeroResult(res);

            return new PackBuilderHandle(handle, true);
        }

        public static unsafe void git_packbuilder_insert(PackBuilderHandle packbuilder, ObjectId targetId, string name)
        {
            GitOid oid = targetId.Oid;

            int res = NativeMethods.git_packbuilder_insert(packbuilder, ref oid, name);
            Ensure.ZeroResult(res);
        }

        internal static unsafe void git_packbuilder_insert_commit(PackBuilderHandle packbuilder, ObjectId targetId)
        {
            GitOid oid = targetId.Oid;

            int res = NativeMethods.git_packbuilder_insert_commit(packbuilder, ref oid);
            Ensure.ZeroResult(res);
        }

        internal static unsafe void git_packbuilder_insert_tree(PackBuilderHandle packbuilder, ObjectId targetId)
        {
            GitOid oid = targetId.Oid;

            int res = NativeMethods.git_packbuilder_insert_tree(packbuilder, ref oid);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_packbuilder_insert_recur(PackBuilderHandle packbuilder, ObjectId targetId, string name)
        {
            GitOid oid = targetId.Oid;

            int res = NativeMethods.git_packbuilder_insert_recur(packbuilder, ref oid, name);
            Ensure.ZeroResult(res);
        }

        public static unsafe uint git_packbuilder_set_threads(PackBuilderHandle packbuilder, uint numThreads)
        {
            return NativeMethods.git_packbuilder_set_threads(packbuilder, numThreads);
        }

        public static unsafe void git_packbuilder_write(PackBuilderHandle packbuilder, FilePath path)
        {
            int res = NativeMethods.git_packbuilder_write(packbuilder, path, 0, IntPtr.Zero, IntPtr.Zero);
            Ensure.ZeroResult(res);
        }

        public static unsafe UIntPtr git_packbuilder_object_count(PackBuilderHandle packbuilder)
        {
            return NativeMethods.git_packbuilder_object_count(packbuilder);
        }

        public static unsafe UIntPtr git_packbuilder_written(PackBuilderHandle packbuilder)
        {
            return NativeMethods.git_packbuilder_written(packbuilder);
        }
#endregion

#region git_rebase

        public static unsafe RebaseHandle git_rebase_init(
            RepositoryHandle repo,
            AnnotatedCommitHandle branch,
            AnnotatedCommitHandle upstream,
            AnnotatedCommitHandle onto,
            GitRebaseOptions options)
        {
            git_rebase* rebase = null;

            int result = NativeMethods.git_rebase_init(out rebase, repo, branch, upstream, onto, options);
            Ensure.ZeroResult(result);

            return new RebaseHandle(rebase, true);
        }

        public static unsafe RebaseHandle git_rebase_open(RepositoryHandle repo, GitRebaseOptions options)
        {
            git_rebase* rebase = null;

            int result = NativeMethods.git_rebase_open(out rebase, repo, options);
            Ensure.ZeroResult(result);

            return new RebaseHandle(rebase, true);
        }

        public static unsafe long git_rebase_operation_entrycount(RebaseHandle rebase)
        {
            return NativeMethods.git_rebase_operation_entrycount(rebase).ConvertToLong();
        }

        public static unsafe long git_rebase_operation_current(RebaseHandle rebase)
        {
            UIntPtr result = NativeMethods.git_rebase_operation_current(rebase);

            if (result == GIT_REBASE_NO_OPERATION)
            {
                return RebaseNoOperation;
            }
            else
            {
                return result.ConvertToLong();
            }
        }

        /// <summary>
        /// The value from the native layer indicating that no rebase operation is in progress.
        /// </summary>
        private static UIntPtr GIT_REBASE_NO_OPERATION
        {
            get
            {
                return UIntPtr.Size == 4 ? new UIntPtr(uint.MaxValue) : new UIntPtr(ulong.MaxValue);
            }
        }

        public const long RebaseNoOperation = -1;

        public static unsafe git_rebase_operation* git_rebase_operation_byindex(
            RebaseHandle rebase,
            long index)
        {
            Debug.Assert(index >= 0);
            return NativeMethods.git_rebase_operation_byindex(rebase, ((UIntPtr)index));
        }

        /// <summary>
        /// Returns null when finished.
        /// </summary>
        /// <param name="rebase"></param>
        /// <returns></returns>
        public static unsafe git_rebase_operation* git_rebase_next(RebaseHandle rebase)
        {
            git_rebase_operation* ptr;
            int result = NativeMethods.git_rebase_next(out ptr, rebase);
            if (result == (int)GitErrorCode.IterOver)
            {
                return null;
            }
            Ensure.ZeroResult(result);

            return ptr;
        }

        public static unsafe GitRebaseCommitResult git_rebase_commit(
            RebaseHandle rebase,
            Identity author,
            Identity committer)
        {
            Ensure.ArgumentNotNull(rebase, "rebase");
            Ensure.ArgumentNotNull(committer, "committer");

            using (SignatureHandle committerHandle = committer.BuildNowSignatureHandle())
            using (SignatureHandle authorHandle = author.SafeBuildNowSignatureHandle())
            {
                GitRebaseCommitResult commitResult = new GitRebaseCommitResult();

                int result = NativeMethods.git_rebase_commit(ref commitResult.CommitId, rebase, authorHandle, committerHandle, IntPtr.Zero, IntPtr.Zero);

                if (result == (int)GitErrorCode.Applied)
                {
                    commitResult.CommitId = GitOid.Empty;
                    commitResult.WasPatchAlreadyApplied = true;
                }
                else
                {
                    Ensure.ZeroResult(result);
                }

                return commitResult;
            }
        }

        /// <summary>
        /// Struct to report the result of calling git_rebase_commit.
        /// </summary>
        public struct GitRebaseCommitResult
        {
            /// <summary>
            /// The ID of the commit that was generated, if any
            /// </summary>
            public GitOid CommitId;

            /// <summary>
            /// bool to indicate if the patch was already applied.
            /// If Patch was already applied, then CommitId will be empty (all zeros).
            /// </summary>
            public bool WasPatchAlreadyApplied;
        }

        public static unsafe void git_rebase_abort(
            RebaseHandle rebase)
        {
            Ensure.ArgumentNotNull(rebase, "rebase");

            int result = NativeMethods.git_rebase_abort(rebase);
            Ensure.ZeroResult(result);
        }

        public static unsafe void git_rebase_finish(
            RebaseHandle rebase,
            Identity committer)
        {
            Ensure.ArgumentNotNull(rebase, "rebase");
            Ensure.ArgumentNotNull(committer, "committer");

            using (var signatureHandle = committer.BuildNowSignatureHandle())
            {
                int result = NativeMethods.git_rebase_finish(rebase, signatureHandle);
                Ensure.ZeroResult(result);
            }
        }

#endregion

#region git_reference_

        public static unsafe ReferenceHandle git_reference_create(
            RepositoryHandle repo,
            string name,
            ObjectId targetId,
            bool allowOverwrite,
            string logMessage)
        {
            GitOid oid = targetId.Oid;
            git_reference* handle;

            int res = NativeMethods.git_reference_create(out handle, repo, name, ref oid, allowOverwrite, logMessage);
            Ensure.ZeroResult(res);

            return new ReferenceHandle(handle, true);
        }

        public static unsafe ReferenceHandle git_reference_symbolic_create(
            RepositoryHandle repo,
            string name,
            string target,
            bool allowOverwrite,
            string logMessage)
        {
            git_reference* handle;
            int res = NativeMethods.git_reference_symbolic_create(out handle, repo, name, target, allowOverwrite,
                logMessage);
            Ensure.ZeroResult(res);

            return new ReferenceHandle(handle, true);
        }

        public static unsafe ICollection<TResult> git_reference_foreach_glob<TResult>(
            RepositoryHandle repo,
            string glob,
            Func<IntPtr, TResult> resultSelector)
        {
            return git_foreach(resultSelector, c => NativeMethods.git_reference_foreach_glob(repo, glob, (x, p) => c(x, p), IntPtr.Zero));
        }

        public static unsafe bool git_reference_is_valid_name(string refname)
        {
            int res;
            NativeMethods.git_reference_name_is_valid(&res, refname);
            Ensure.BooleanResult(res);

            return (res == 1);
        }

        public static unsafe IList<string> git_reference_list(RepositoryHandle repo)
        {
            var array = new GitStrArrayNative();

            try
            {
                int res = NativeMethods.git_reference_list(out array.Array, repo);
                Ensure.ZeroResult(res);

                return array.ReadStrings();
            }
            finally
            {
                array.Dispose();
            }
        }

        public static unsafe ReferenceHandle git_reference_lookup(RepositoryHandle repo, string name, bool shouldThrowIfNotFound)
        {
            git_reference* handle;
            int res = NativeMethods.git_reference_lookup(out handle, repo, name);

            if (!shouldThrowIfNotFound && res == (int)GitErrorCode.NotFound)
            {
                return null;
            }

            Ensure.ZeroResult(res);

            return new ReferenceHandle(handle, true);
        }

        public static unsafe string git_reference_name(git_reference* reference)
        {
            return NativeMethods.git_reference_name(reference);
        }

        public static unsafe void git_reference_remove(RepositoryHandle repo, string name)
        {
            int res = NativeMethods.git_reference_remove(repo, name);
            Ensure.ZeroResult(res);
        }

        public static unsafe ObjectId git_reference_target(git_reference* reference)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_reference_target(reference));
        }

        public static unsafe ReferenceHandle git_reference_rename(
            ReferenceHandle reference,
            string newName,
            bool allowOverwrite,
            string logMessage)
        {
            git_reference* ref_out;

            int res = NativeMethods.git_reference_rename(out ref_out, reference, newName, allowOverwrite, logMessage);
            Ensure.ZeroResult(res);

            return new ReferenceHandle(ref_out, true);
        }

        public static unsafe ReferenceHandle git_reference_set_target(ReferenceHandle reference, ObjectId id, string logMessage)
        {
            GitOid oid = id.Oid;
            git_reference* ref_out;

            int res = NativeMethods.git_reference_set_target(out ref_out, reference, ref oid, logMessage);
            Ensure.ZeroResult(res);

            return new ReferenceHandle(ref_out, true);
        }

        public static unsafe ReferenceHandle git_reference_symbolic_set_target(ReferenceHandle reference, string target, string logMessage)
        {
            git_reference* ref_out;

            int res = NativeMethods.git_reference_symbolic_set_target(out ref_out, reference, target, logMessage);
            Ensure.ZeroResult(res);

            return new ReferenceHandle(ref_out, true);
        }

        public static unsafe string git_reference_symbolic_target(git_reference* reference)
        {
            return NativeMethods.git_reference_symbolic_target(reference);
        }

        public static unsafe GitReferenceType git_reference_type(git_reference* reference)
        {
            return NativeMethods.git_reference_type(reference);
        }

        public static unsafe void git_reference_ensure_log(RepositoryHandle repo, string refname)
        {
            int res = NativeMethods.git_reference_ensure_log(repo, refname);
            Ensure.ZeroResult(res);
        }

#endregion

#region git_reflog_

        public static unsafe ReflogHandle git_reflog_read(RepositoryHandle repo, string canonicalName)
        {
            git_reflog* reflog_out;

            int res = NativeMethods.git_reflog_read(out reflog_out, repo, canonicalName);
            Ensure.ZeroResult(res);

            return new ReflogHandle(reflog_out, true);
        }

        public static unsafe int git_reflog_entrycount(ReflogHandle reflog)
        {
            return (int)NativeMethods.git_reflog_entrycount(reflog);
        }

        public static unsafe git_reflog_entry* git_reflog_entry_byindex(ReflogHandle reflog, int idx)
        {
            return NativeMethods.git_reflog_entry_byindex(reflog, (UIntPtr)idx);
        }

        public static unsafe ObjectId git_reflog_entry_id_old(git_reflog_entry* entry)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_reflog_entry_id_old(entry));
        }

        public static unsafe ObjectId git_reflog_entry_id_new(git_reflog_entry* entry)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_reflog_entry_id_new(entry));
        }

        public static unsafe Signature git_reflog_entry_committer(git_reflog_entry* entry)
        {
            return new Signature(NativeMethods.git_reflog_entry_committer(entry));
        }

        public static unsafe string git_reflog_entry_message(git_reflog_entry* entry)
        {
            return NativeMethods.git_reflog_entry_message(entry);
        }

#endregion

#region git_refspec

        public static unsafe string git_refspec_transform(IntPtr refSpecPtr, string name)
        {
            using (var buf = new GitBuf())
            {
                int res = NativeMethods.git_refspec_transform(buf, refSpecPtr, name);
                Ensure.ZeroResult(res);

                return LaxUtf8Marshaler.FromNative(buf.ptr) ?? string.Empty;
            }
        }

        public static unsafe string git_refspec_rtransform(IntPtr refSpecPtr, string name)
        {
            using (var buf = new GitBuf())
            {
                int res = NativeMethods.git_refspec_rtransform(buf, refSpecPtr, name);
                Ensure.ZeroResult(res);

                return LaxUtf8Marshaler.FromNative(buf.ptr) ?? string.Empty;
            }
        }

        public static unsafe string git_refspec_string(IntPtr refspec)
        {
            return NativeMethods.git_refspec_string(refspec);
        }

        public static unsafe string git_refspec_src(IntPtr refSpec)
        {
            return NativeMethods.git_refspec_src(refSpec);
        }

        public static unsafe string git_refspec_dst(IntPtr refSpec)
        {
            return NativeMethods.git_refspec_dst(refSpec);
        }

        public static unsafe RefSpecDirection git_refspec_direction(IntPtr refSpec)
        {
            return NativeMethods.git_refspec_direction(refSpec);
        }

        public static unsafe bool git_refspec_force(IntPtr refSpec)
        {
            return NativeMethods.git_refspec_force(refSpec);
        }

        public static bool git_refspec_src_matches(IntPtr refspec, string reference)
        {
            return NativeMethods.git_refspec_src_matches(refspec, reference);
        }

        public static bool git_refspec_dst_matches(IntPtr refspec, string reference)
        {
            return NativeMethods.git_refspec_dst_matches(refspec, reference);
        }

#endregion

#region git_remote_

        public static unsafe TagFetchMode git_remote_autotag(RemoteHandle remote)
        {
            return (TagFetchMode)NativeMethods.git_remote_autotag(remote);
        }

        public static unsafe RemoteHandle git_remote_create(RepositoryHandle repo, string name, string url)
        {
            git_remote* handle;
            int res = NativeMethods.git_remote_create(out handle, repo, name, url);
            Ensure.ZeroResult(res);

            return new RemoteHandle(handle, true);
        }

        public static unsafe RemoteHandle git_remote_create_with_fetchspec(RepositoryHandle repo, string name, string url, string refspec)
        {
            git_remote* handle;
            int res = NativeMethods.git_remote_create_with_fetchspec(out handle, repo, name, url, refspec);
            Ensure.ZeroResult(res);

            return new RemoteHandle(handle, true);
        }

        public static unsafe RemoteHandle git_remote_create_anonymous(RepositoryHandle repo, string url)
        {
            git_remote* handle;
            int res = NativeMethods.git_remote_create_anonymous(out handle, repo, url);
            Ensure.ZeroResult(res);

            return new RemoteHandle(handle, true);
        }

        public static unsafe void git_remote_connect(RemoteHandle remote, GitDirection direction, ref GitRemoteCallbacks remoteCallbacks, ref GitProxyOptions proxyOptions)
        {
            GitStrArrayManaged customHeaders = new GitStrArrayManaged();

            try
            {
                int res = NativeMethods.git_remote_connect(remote, direction, ref remoteCallbacks, ref proxyOptions, ref customHeaders.Array);
                Ensure.ZeroResult(res);
            }
            catch (Exception)
            {
                customHeaders.Dispose();
                throw;
            }
        }

        public static unsafe void git_remote_delete(RepositoryHandle repo, string name)
        {
            int res = NativeMethods.git_remote_delete(repo, name);

            if (res == (int)GitErrorCode.NotFound)
            {
                return;
            }

            Ensure.ZeroResult(res);
        }

        public static unsafe git_refspec* git_remote_get_refspec(RemoteHandle remote, int n)
        {
            return NativeMethods.git_remote_get_refspec(remote, (UIntPtr)n);
        }

        public static unsafe int git_remote_refspec_count(RemoteHandle remote)
        {
            return (int)NativeMethods.git_remote_refspec_count(remote);
        }

        public static unsafe IList<string> git_remote_get_fetch_refspecs(RemoteHandle remote)
        {
            var array = new GitStrArrayNative();

            try
            {
                int res = NativeMethods.git_remote_get_fetch_refspecs(out array.Array, remote);
                Ensure.ZeroResult(res);

                return array.ReadStrings();
            }
            finally
            {
                array.Dispose();
            }
        }

        public static unsafe IList<string> git_remote_get_push_refspecs(RemoteHandle remote)
        {
            var array = new GitStrArrayNative();

            try
            {
                int res = NativeMethods.git_remote_get_push_refspecs(out array.Array, remote);
                Ensure.ZeroResult(res);

                return array.ReadStrings();
            }
            finally
            {
                array.Dispose();
            }
        }

        public static unsafe void git_remote_push(RemoteHandle remote, IEnumerable<string> refSpecs, GitPushOptions opts)
        {
            var array = new GitStrArrayManaged();

            try
            {
                array = GitStrArrayManaged.BuildFrom(refSpecs.ToArray());

                int res = NativeMethods.git_remote_push(remote, ref array.Array, opts);
                Ensure.ZeroResult(res);
            }
            finally
            {
                array.Dispose();
            }
        }

        public static unsafe void git_remote_set_url(RepositoryHandle repo, string remote, string url)
        {
            int res = NativeMethods.git_remote_set_url(repo, remote, url);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_remote_add_fetch(RepositoryHandle repo, string remote, string url)
        {
            int res = NativeMethods.git_remote_add_fetch(repo, remote, url);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_remote_set_pushurl(RepositoryHandle repo, string remote, string url)
        {
            int res = NativeMethods.git_remote_set_pushurl(repo, remote, url);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_remote_add_push(RepositoryHandle repo, string remote, string url)
        {
            int res = NativeMethods.git_remote_add_push(repo, remote, url);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_remote_fetch(
            RemoteHandle remote, IEnumerable<string> refSpecs,
            GitFetchOptions fetchOptions, string logMessage)
        {
            var array = new GitStrArrayManaged();

            try
            {
                array = GitStrArrayManaged.BuildFrom(refSpecs.ToArray());

                int res = NativeMethods.git_remote_fetch(remote, ref array.Array, fetchOptions, logMessage);
                Ensure.ZeroResult(res);
            }
            finally
            {
                array.Dispose();
            }
        }

        public static unsafe bool git_remote_is_valid_name(string refname)
        {
            int res;
            NativeMethods.git_remote_name_is_valid(&res, refname);
            Ensure.BooleanResult(res);

            return (res == 1);
        }

        public static unsafe IList<string> git_remote_list(RepositoryHandle repo)
        {
            var array = new GitStrArrayNative();

            try
            {
                int res = NativeMethods.git_remote_list(out array.Array, repo);
                Ensure.ZeroResult(res);

                return array.ReadStrings();
            }
            finally
            {
                array.Dispose();
            }
        }

        public static unsafe IEnumerable<Reference> git_remote_ls(Repository repository, RemoteHandle remote)
        {
            git_remote_head** heads;
            UIntPtr count;

            int res = NativeMethods.git_remote_ls(out heads, out count, remote);
            Ensure.ZeroResult(res);

            var intCount = checked(count.ToUInt32());
            var directRefs = new Dictionary<string, Reference>();
            var symRefs = new Dictionary<string, string>();

            for (int i = 0; i < intCount; i++)
            {
                git_remote_head* currentHead = heads[i];
                string name = LaxUtf8Marshaler.FromNative(currentHead->Name);
                string symRefTarget = LaxUtf8Marshaler.FromNative(currentHead->SymrefTarget);

                // The name pointer should never be null - if it is,
                // this indicates a bug somewhere (libgit2, server, etc).
                if (string.IsNullOrEmpty(name))
                {
                    throw new InvalidOperationException("Not expecting null value for reference name.");
                }

                if (!string.IsNullOrEmpty(symRefTarget))
                {
                    symRefs.Add(name, symRefTarget);
                }
                else
                {
                    directRefs.Add(name, new DirectReference(name, repository, new ObjectId(currentHead->Oid.Id)));
                }
            }

            for (int i = 0; i < symRefs.Count; i++)
            {
                var symRef = symRefs.ElementAt(i);

                if (!directRefs.ContainsKey(symRef.Value))
                {
                    throw new InvalidOperationException("Symbolic reference target not found in direct reference results.");
                }

                directRefs.Add(symRef.Key, new SymbolicReference(repository, symRef.Key, symRef.Value, directRefs[symRef.Value]));
            }

            var refs = directRefs.Values.ToList();
            refs.Sort((r1, r2) => String.CompareOrdinal(r1.CanonicalName, r2.CanonicalName));

            return refs;
        }

        public static unsafe RemoteHandle git_remote_lookup(RepositoryHandle repo, string name, bool throwsIfNotFound)
        {
            git_remote* handle;
            int res = NativeMethods.git_remote_lookup(out handle, repo, name);

            if (res == (int)GitErrorCode.NotFound && !throwsIfNotFound)
            {
                return null;
            }

            Ensure.ZeroResult(res);
            return new RemoteHandle(handle, true);
        }

        public static unsafe string git_remote_name(RemoteHandle remote)
        {
            return NativeMethods.git_remote_name(remote);
        }

        public static unsafe void git_remote_rename(RepositoryHandle repo, string name, string new_name, RemoteRenameFailureHandler callback)
        {
            if (callback == null)
            {
                callback = problem => { };
            }

            var array = new GitStrArrayNative();

            try
            {
                int res = NativeMethods.git_remote_rename(ref array.Array,
                                                          repo,
                                                          name,
                                                          new_name);

                if (res == (int)GitErrorCode.NotFound)
                {
                    throw new NotFoundException("Remote '{0}' does not exist and cannot be renamed.", name);
                }

                Ensure.ZeroResult(res);

                foreach (var item in array.ReadStrings())
                {
                    callback(item);
                }
            }
            finally
            {
                array.Dispose();
            }
        }

        public static unsafe void git_remote_set_autotag(RepositoryHandle repo, string remote, TagFetchMode value)
        {
            NativeMethods.git_remote_set_autotag(repo, remote, value);
        }

        public static unsafe string git_remote_url(RemoteHandle remote)
        {
            return NativeMethods.git_remote_url(remote);
        }

        public static unsafe string git_remote_pushurl(RemoteHandle remote)
        {
            return NativeMethods.git_remote_pushurl(remote);
        }

#endregion

#region git_repository_

        public static FilePath git_repository_discover(FilePath start_path)
        {
            return ConvertPath(buf => NativeMethods.git_repository_discover(buf, start_path, false, null));
        }

        public static unsafe bool git_repository_head_detached(RepositoryHandle repo)
        {
            return RepositoryStateChecker(repo, NativeMethods.git_repository_head_detached);
        }

        public static unsafe ICollection<TResult> git_repository_fetchhead_foreach<TResult>(
            RepositoryHandle repo,
            Func<string, string, GitOid, bool, TResult> resultSelector)
        {
            return git_foreach(resultSelector,
                               c => NativeMethods.git_repository_fetchhead_foreach(repo,
                                                                                   (IntPtr w, IntPtr x, ref GitOid y, bool z, IntPtr p)
                                                                                       => c(LaxUtf8Marshaler.FromNative(w), LaxUtf8Marshaler.FromNative(x), y, z, p),
                                                                                   IntPtr.Zero),
                               GitErrorCode.NotFound);
        }

        public static bool git_repository_head_unborn(RepositoryHandle repo)
        {
            return RepositoryStateChecker(repo, NativeMethods.git_repository_head_unborn);
        }

        public static unsafe IndexHandle git_repository_index(RepositoryHandle repo)
        {
            git_index* handle;
            int res = NativeMethods.git_repository_index(out handle, repo);
            Ensure.ZeroResult(res);

            return new IndexHandle(handle, true);
        }

        public static unsafe RepositoryHandle git_repository_init_ext(
            FilePath workdirPath,
            FilePath gitdirPath,
            bool isBare)
        {
            using (var opts = GitRepositoryInitOptions.BuildFrom(workdirPath, isBare))
            {
                git_repository* repo;
                int res = NativeMethods.git_repository_init_ext(out repo, gitdirPath, opts);
                Ensure.ZeroResult(res);

                return new RepositoryHandle(repo, true);
            }
        }

        public static unsafe bool git_repository_is_bare(RepositoryHandle repo)
        {
            return RepositoryStateChecker(repo, NativeMethods.git_repository_is_bare);
        }

        public static unsafe bool git_repository_is_shallow(RepositoryHandle repo)
        {
            return RepositoryStateChecker(repo, NativeMethods.git_repository_is_shallow);
        }

        public static unsafe void git_repository_state_cleanup(RepositoryHandle repo)
        {
            int res = NativeMethods.git_repository_state_cleanup(repo);
            Ensure.ZeroResult(res);
        }

        public static unsafe ICollection<TResult> git_repository_mergehead_foreach<TResult>(
            RepositoryHandle repo,
            Func<GitOid, TResult> resultSelector)
        {
            return git_foreach(resultSelector,
                               c => NativeMethods.git_repository_mergehead_foreach(repo,
                                                                                   (ref GitOid x, IntPtr p) => c(x, p), IntPtr.Zero),
                               GitErrorCode.NotFound);
        }

        public static unsafe string git_repository_message(RepositoryHandle repo)
        {
            using (var buf = new GitBuf())
            {
                int res = NativeMethods.git_repository_message(buf, repo);
                if (res == (int)GitErrorCode.NotFound)
                {
                    return null;
                }
                Ensure.ZeroResult(res);

                return LaxUtf8Marshaler.FromNative(buf.ptr);
            }
        }

        public static unsafe ObjectDatabaseHandle git_repository_odb(RepositoryHandle repo)
        {
            git_odb* handle;
            int res = NativeMethods.git_repository_odb(out handle, repo);
            Ensure.ZeroResult(res);

            return new ObjectDatabaseHandle(handle, true);
        }

        public static unsafe RepositoryHandle git_repository_open(string path)
        {
            git_repository* repo;
            int res = NativeMethods.git_repository_open(out repo, path);

            if (res == (int)GitErrorCode.NotFound)
            {
                throw new RepositoryNotFoundException("Path '{0}' doesn't point at a valid Git repository or workdir.",
                                                                    path);
            }

            Ensure.ZeroResult(res);

            return new RepositoryHandle(repo, true);
        }

        public static unsafe RepositoryHandle git_repository_new()
        {
            git_repository* repo;
            int res = NativeMethods.git_repository_new(out repo);

            Ensure.ZeroResult(res);

            return new RepositoryHandle(repo, true);
        }

        public static unsafe void git_repository_open_ext(string path, RepositoryOpenFlags flags, string ceilingDirs)
        {
            int res;
            git_repository *repo;

            res = NativeMethods.git_repository_open_ext(out repo, path, flags, ceilingDirs);
            NativeMethods.git_repository_free(repo);

            if (res == (int)GitErrorCode.NotFound)
            {
                throw new RepositoryNotFoundException("Path '{0}' doesn't point at a valid Git repository or workdir.",
                                                                    path);
            }

            Ensure.ZeroResult(res);
        }

        public static unsafe FilePath git_repository_path(RepositoryHandle repo)
        {
            return NativeMethods.git_repository_path(repo);
        }

        public static unsafe int git_repository_set_config(RepositoryHandle repo, ConfigurationHandle config)
        {
            return NativeMethods.git_repository_set_config(repo, config);
        }

        public static unsafe void git_repository_set_ident(RepositoryHandle repo, string name, string email)
        {
            int res = NativeMethods.git_repository_set_ident(repo, name, email);
            Ensure.ZeroResult(res);
        }

        public static unsafe int git_repository_set_index(RepositoryHandle repo, IndexHandle index)
        {
            return NativeMethods.git_repository_set_index(repo, index);
        }

        public static unsafe void git_repository_set_workdir(RepositoryHandle repo, FilePath workdir)
        {
            int res = NativeMethods.git_repository_set_workdir(repo, workdir, false);
            Ensure.ZeroResult(res);
        }

        public static unsafe CurrentOperation git_repository_state(RepositoryHandle repo)
        {
            int res = NativeMethods.git_repository_state(repo);
            Ensure.Int32Result(res);
            return (CurrentOperation)res;
        }

        public static unsafe FilePath git_repository_workdir(RepositoryHandle repo)
        {
#if !LIBGIT2_USE_INTERNAL_DLL
            return NativeMethods.git_repository_workdir(repo);
#else
            return NativeMethods.git_repository_workdir__1(repo);
#endif
        }

        public static FilePath git_repository_workdir(IntPtr repo)
        {
#if !LIBGIT2_USE_INTERNAL_DLL
            return NativeMethods.git_repository_workdir(repo);
#else
            return NativeMethods.git_repository_workdir__2(repo);
#endif
        }

        public static unsafe void git_repository_set_head_detached(RepositoryHandle repo, ObjectId commitish)
        {
            GitOid oid = commitish.Oid;
            int res = NativeMethods.git_repository_set_head_detached(repo, ref oid);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_repository_set_head_detached_from_annotated(RepositoryHandle repo, AnnotatedCommitHandle commit)
        {
            int res = NativeMethods.git_repository_set_head_detached_from_annotated(repo, commit);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_repository_set_head(RepositoryHandle repo, string refname)
        {
            int res = NativeMethods.git_repository_set_head(repo, refname);
            Ensure.ZeroResult(res);
        }

#endregion

#region git_reset_

        public static unsafe void git_reset(
            RepositoryHandle repo,
            ObjectId committishId,
            ResetMode resetKind,
            ref GitCheckoutOpts checkoutOptions)
        {
            using (var osw = new ObjectSafeWrapper(committishId, repo))
            {
                int res = NativeMethods.git_reset(repo, osw.ObjectPtr, resetKind, ref checkoutOptions);
                Ensure.ZeroResult(res);
            }
        }

#endregion

#region git_revert_

        public static unsafe void git_revert(
            RepositoryHandle repo,
            ObjectId commit,
            GitRevertOpts opts)
        {
            using (var nativeCommit = git_object_lookup(repo, commit, GitObjectType.Commit))
            {
                int res = NativeMethods.git_revert(repo, nativeCommit, opts);
                Ensure.ZeroResult(res);
            }
        }

        internal static unsafe IndexHandle git_revert_commit(RepositoryHandle repo, ObjectHandle revertCommit, ObjectHandle ourCommit, uint mainline, GitMergeOpts opts, out bool earlyStop)
        {
            git_index* index;
            int res = NativeMethods.git_revert_commit(out index, repo, revertCommit, ourCommit, mainline, ref opts);
            if (res == (int)GitErrorCode.MergeConflict)
            {
                earlyStop = true;
            }
            else
            {
                earlyStop = false;
                Ensure.ZeroResult(res);
            }
            return new IndexHandle(index, true);
        }
        #endregion

        #region git_revparse_

        public static unsafe Tuple<ObjectHandle, ReferenceHandle> git_revparse_ext(RepositoryHandle repo, string objectish)
        {
            git_object* obj;
            git_reference* reference;
            int res = NativeMethods.git_revparse_ext(out obj, out reference, repo, objectish);

            switch (res)
            {
                case (int)GitErrorCode.NotFound:
                    return null;

                case (int)GitErrorCode.Ambiguous:
                    throw new AmbiguousSpecificationException("Provided abbreviated ObjectId '{0}' is too short.",
                                                              objectish);

                default:
                    Ensure.ZeroResult(res);
                    break;
            }

            return new Tuple<ObjectHandle, ReferenceHandle>(new ObjectHandle(obj, true), new ReferenceHandle(reference, true));
        }

        public static ObjectHandle git_revparse_single(RepositoryHandle repo, string objectish)
        {
            var handles = git_revparse_ext(repo, objectish);

            if (handles == null)
            {
                return null;
            }

            handles.Item2.Dispose();

            return handles.Item1;
        }

#endregion

#region git_revwalk_

        public static unsafe void git_revwalk_hide(RevWalkerHandle walker, ObjectId commit_id)
        {
            GitOid oid = commit_id.Oid;
            int res = NativeMethods.git_revwalk_hide(walker, ref oid);
            Ensure.ZeroResult(res);
        }

        public static unsafe RevWalkerHandle git_revwalk_new(RepositoryHandle repo)
        {
            git_revwalk* handle;
            int res = NativeMethods.git_revwalk_new(out handle, repo);
            Ensure.ZeroResult(res);

            return new RevWalkerHandle(handle, true);
        }

        public static unsafe ObjectId git_revwalk_next(RevWalkerHandle walker)
        {
            GitOid ret;
            int res = NativeMethods.git_revwalk_next(out ret, walker);

            if (res == (int)GitErrorCode.IterOver)
            {
                return null;
            }

            Ensure.ZeroResult(res);

            return ret;
        }

        public static unsafe void git_revwalk_push(RevWalkerHandle walker, ObjectId id)
        {
            GitOid oid = id.Oid;
            int res = NativeMethods.git_revwalk_push(walker, ref oid);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_revwalk_reset(RevWalkerHandle walker)
        {
            NativeMethods.git_revwalk_reset(walker);
        }

        public static unsafe int git_revwalk_sorting(RevWalkerHandle walker, CommitSortStrategies options)
        {
            return NativeMethods.git_revwalk_sorting(walker, options);
        }

        public static unsafe int git_revwalk_simplify_first_parent(RevWalkerHandle walker)
        {
            return NativeMethods.git_revwalk_simplify_first_parent(walker);
        }

#endregion

#region git_signature_

        public static unsafe SignatureHandle git_signature_new(string name, string email, DateTimeOffset when)
        {
            git_signature* ptr;

            int res = NativeMethods.git_signature_new(out ptr, name, email, when.ToUnixTimeSeconds(),
                                                      (int)when.Offset.TotalMinutes);
            Ensure.ZeroResult(res);

            return new SignatureHandle(ptr, true);
        }

        public static unsafe SignatureHandle git_signature_now(string name, string email)
        {
            git_signature* ptr;
            int res = NativeMethods.git_signature_now(out ptr, name, email);
            Ensure.ZeroResult(res);

            return new SignatureHandle(ptr, true);
        }

        public static unsafe git_signature* git_signature_dup(git_signature* sig)
        {
            git_signature* handle;
            int res = NativeMethods.git_signature_dup(out handle, sig);
            Ensure.ZeroResult(res);
            return handle;
        }

#endregion

#region git_stash_

        public static unsafe ObjectId git_stash_save(
            RepositoryHandle repo,
            Signature stasher,
            string prettifiedMessage,
            StashModifiers options)
        {
            using (SignatureHandle sigHandle = stasher.BuildHandle())
            {
                GitOid stashOid;

                int res = NativeMethods.git_stash_save(out stashOid, repo, sigHandle, prettifiedMessage, options);

                if (res == (int)GitErrorCode.NotFound)
                {
                    return null;
                }

                Ensure.Int32Result(res);

                return new ObjectId(stashOid);
            }
        }

        public static unsafe ICollection<TResult> git_stash_foreach<TResult>(
            RepositoryHandle repo,
            Func<int, IntPtr, GitOid, TResult> resultSelector)
        {
            return git_foreach(resultSelector,
                               c => NativeMethods.git_stash_foreach(repo,
                                                                    (UIntPtr i, IntPtr m, ref GitOid x, IntPtr p)
                                                                        => c((int)i, m, x, p),
                                                                    IntPtr.Zero),
                               GitErrorCode.NotFound);
        }

        public static unsafe void git_stash_drop(RepositoryHandle repo, int index)
        {
            int res = NativeMethods.git_stash_drop(repo, (UIntPtr)index);
            Ensure.BooleanResult(res);
        }

        private static StashApplyStatus get_stash_status(int res)
        {
            if (res == (int)GitErrorCode.Conflict)
            {
                return StashApplyStatus.Conflicts;
            }

            if (res == (int)GitErrorCode.Uncommitted)
            {
                return StashApplyStatus.UncommittedChanges;
            }

            if (res == (int)GitErrorCode.NotFound)
            {
                return StashApplyStatus.NotFound;
            }

            Ensure.ZeroResult(res);
            return StashApplyStatus.Applied;
        }

        public static unsafe StashApplyStatus git_stash_apply(
            RepositoryHandle repo,
            int index,
            GitStashApplyOpts opts)
        {
            return get_stash_status(NativeMethods.git_stash_apply(repo, (UIntPtr)index, opts));
        }

        public static unsafe StashApplyStatus git_stash_pop(
            RepositoryHandle repo,
            int index,
            GitStashApplyOpts opts)
        {
            return get_stash_status(NativeMethods.git_stash_pop(repo, (UIntPtr)index, opts));
        }

#endregion

#region git_status_

        public static unsafe FileStatus git_status_file(RepositoryHandle repo, FilePath path)
        {
            FileStatus status;
            int res = NativeMethods.git_status_file(out status, repo, path);

            switch (res)
            {
                case (int)GitErrorCode.NotFound:
                    return FileStatus.Nonexistent;

                case (int)GitErrorCode.Ambiguous:
                    throw new AmbiguousSpecificationException("More than one file matches the pathspec '{0}'. " +
                                                              "You can either force a literal path evaluation " +
                                                              "(GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH), or use git_status_foreach().",
                                                              path);

                default:
                    Ensure.ZeroResult(res);
                    break;
            }

            return status;
        }

        public static unsafe StatusListHandle git_status_list_new(RepositoryHandle repo, GitStatusOptions options)
        {
            git_status_list* ptr;
            int res = NativeMethods.git_status_list_new(out ptr, repo, options);
            Ensure.ZeroResult(res);
            return new StatusListHandle(ptr, true);
        }

        public static unsafe int git_status_list_entrycount(StatusListHandle list)
        {
            int res = NativeMethods.git_status_list_entrycount(list);
            Ensure.Int32Result(res);
            return res;
        }

        public static unsafe git_status_entry* git_status_byindex(StatusListHandle list, long idx)
        {
            return NativeMethods.git_status_byindex(list, (UIntPtr)idx);
        }

#endregion

#region git_submodule_

        /// <summary>
        /// Returns a handle to the corresponding submodule,
        /// or an invalid handle if a submodule is not found.
        /// </summary>
        public static unsafe SubmoduleHandle git_submodule_lookup(RepositoryHandle repo, string name)
        {
            git_submodule* submodule;
            var res = NativeMethods.git_submodule_lookup(out submodule, repo, name);

            switch (res)
            {
                case (int)GitErrorCode.NotFound:
                case (int)GitErrorCode.Exists:
                case (int)GitErrorCode.OrphanedHead:
                    return null;

                default:
                    Ensure.ZeroResult(res);
                    return new SubmoduleHandle(submodule, true);
            }
        }

        public static unsafe string git_submodule_resolve_url(RepositoryHandle repo, string url)
        {
            using (var buf = new GitBuf())
            {
                int res = NativeMethods.git_submodule_resolve_url(buf, repo, url);

                Ensure.ZeroResult(res);
                return LaxUtf8Marshaler.FromNative(buf.ptr);
            }
        }

        public static unsafe ICollection<TResult> git_submodule_foreach<TResult>(RepositoryHandle repo, Func<IntPtr, IntPtr, TResult> resultSelector)
        {
            return git_foreach(resultSelector, c => NativeMethods.git_submodule_foreach(repo, (x, y, p) => c(x, y, p), IntPtr.Zero));
        }

        public static unsafe void git_submodule_add_to_index(SubmoduleHandle submodule, bool write_index)
        {
            var res = NativeMethods.git_submodule_add_to_index(submodule, write_index);
            Ensure.ZeroResult(res);
        }

        public static unsafe void git_submodule_update(SubmoduleHandle submodule, bool init, ref GitSubmoduleUpdateOptions options)
        {
            var res = NativeMethods.git_submodule_update(submodule, init, ref options);
            Ensure.ZeroResult(res);
        }

        public static unsafe string git_submodule_path(SubmoduleHandle submodule)
        {
            return NativeMethods.git_submodule_path(submodule);
        }

        public static unsafe string git_submodule_url(SubmoduleHandle submodule)
        {
            return NativeMethods.git_submodule_url(submodule);
        }

        public static unsafe ObjectId git_submodule_index_id(SubmoduleHandle submodule)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_submodule_index_id(submodule));
        }

        public static unsafe ObjectId git_submodule_head_id(SubmoduleHandle submodule)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_submodule_head_id(submodule));
        }

        public static unsafe ObjectId git_submodule_wd_id(SubmoduleHandle submodule)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_submodule_wd_id(submodule));
        }

        public static unsafe SubmoduleIgnore git_submodule_ignore(SubmoduleHandle submodule)
        {
            return NativeMethods.git_submodule_ignore(submodule);
        }

        public static unsafe SubmoduleUpdate git_submodule_update_strategy(SubmoduleHandle submodule)
        {
            return NativeMethods.git_submodule_update_strategy(submodule);
        }

        public static unsafe SubmoduleRecurse git_submodule_fetch_recurse_submodules(SubmoduleHandle submodule)
        {
            return NativeMethods.git_submodule_fetch_recurse_submodules(submodule);
        }

        public static unsafe void git_submodule_reload(SubmoduleHandle submodule)
        {
            var res = NativeMethods.git_submodule_reload(submodule, false);
            Ensure.ZeroResult(res);
        }

        public static unsafe SubmoduleStatus git_submodule_status(RepositoryHandle repo, string name)
        {
            SubmoduleStatus status;
            var res = NativeMethods.git_submodule_status(out status, repo, name, GitSubmoduleIgnore.Unspecified);
            Ensure.ZeroResult(res);
            return status;
        }

        public static unsafe void git_submodule_init(SubmoduleHandle submodule, bool overwrite)
        {
            var res = NativeMethods.git_submodule_init(submodule, overwrite);
            Ensure.ZeroResult(res);
        }

#endregion

#region git_tag_

        public static unsafe ObjectId git_tag_annotation_create(
            RepositoryHandle repo,
            string name,
            GitObject target,
            Signature tagger,
            string message)
        {
            using (var objectPtr = new ObjectSafeWrapper(target.Id, repo))
            using (SignatureHandle sigHandle = tagger.BuildHandle())
            {
                GitOid oid;
                int res = NativeMethods.git_tag_annotation_create(out oid, repo, name, objectPtr.ObjectPtr, sigHandle, message);
                Ensure.ZeroResult(res);

                return oid;
            }
        }

        public static unsafe ObjectId git_tag_create(
            RepositoryHandle repo,
            string name,
            GitObject target,
            Signature tagger,
            string message,
            bool allowOverwrite)
        {
            using (var objectPtr = new ObjectSafeWrapper(target.Id, repo))
            using (SignatureHandle sigHandle = tagger.BuildHandle())
            {
                GitOid oid;
                int res = NativeMethods.git_tag_create(out oid, repo, name, objectPtr.ObjectPtr, sigHandle, message, allowOverwrite);
                Ensure.ZeroResult(res);

                return oid;
            }
        }

        public static unsafe ObjectId git_tag_create_lightweight(RepositoryHandle repo, string name, GitObject target, bool allowOverwrite)
        {
            using (var objectPtr = new ObjectSafeWrapper(target.Id, repo))
            {
                GitOid oid;
                int res = NativeMethods.git_tag_create_lightweight(out oid, repo, name, objectPtr.ObjectPtr, allowOverwrite);
                Ensure.ZeroResult(res);

                return oid;
            }
        }

        public static unsafe void git_tag_delete(RepositoryHandle repo, string name)
        {
            int res = NativeMethods.git_tag_delete(repo, name);
            Ensure.ZeroResult(res);
        }

        public static unsafe IList<string> git_tag_list(RepositoryHandle repo)
        {
            var array = new GitStrArrayNative();

            try
            {
                int res = NativeMethods.git_tag_list(out array.Array, repo);
                Ensure.ZeroResult(res);

                return array.ReadStrings();
            }
            finally
            {
                array.Dispose();
            }
        }

        public static unsafe string git_tag_message(ObjectHandle tag)
        {
            return NativeMethods.git_tag_message(tag);
        }

        public static unsafe string git_tag_name(ObjectHandle tag)
        {
            return NativeMethods.git_tag_name(tag);
        }

        public static unsafe Signature git_tag_tagger(ObjectHandle tag)
        {
            git_signature* taggerHandle = NativeMethods.git_tag_tagger(tag);

            // Not all tags have a tagger signature - we need to handle
            // this case.
            Signature tagger = null;
            if (taggerHandle != null)
            {
                tagger = new Signature(taggerHandle);
            }

            return tagger;
        }

        public static unsafe ObjectId git_tag_target_id(ObjectHandle tag)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_tag_target_id(tag));
        }

        public static unsafe GitObjectType git_tag_target_type(ObjectHandle tag)
        {
            return NativeMethods.git_tag_target_type(tag);
        }

#endregion

#region git_trace_

        /// <summary>
        /// Install/Enable logging inside of LibGit2 to send messages back to LibGit2Sharp.
        ///
        /// Since the given callback will be passed into and retained by C code,
        /// it is very important that you pass an actual delegate here (and don't
        /// let the compiler create/cast a temporary one for you).  Furthermore, you
        /// must hold a reference to this delegate until you turn off logging.
        ///
        /// This callback is unlike other callbacks because logging persists in the
        /// process until disabled; in contrast, most callbacks are only defined for
        /// the duration of the down-call.
        /// </summary>
        public static void git_trace_set(LogLevel level, NativeMethods.git_trace_cb callback)
        {
            int res = NativeMethods.git_trace_set(level, callback);
            Ensure.ZeroResult(res);
        }

#endregion

#region git_transport_

        public static void git_transport_register(String prefix, IntPtr transport_cb, IntPtr param)
        {
            int res = NativeMethods.git_transport_register(prefix, transport_cb, param);

            if (res == (int)GitErrorCode.Exists)
            {
                throw new EntryExistsException("A custom transport for '{0}' is already registered",
                    prefix);
            }

            Ensure.ZeroResult(res);
        }

        public static void git_transport_unregister(String prefix)
        {
            int res = NativeMethods.git_transport_unregister(prefix);

            if (res == (int)GitErrorCode.NotFound)
            {
                throw new NotFoundException("The given transport was not found");
            }

            Ensure.ZeroResult(res);
        }

#endregion

#region git_transport_smart_

        public static int git_transport_smart_credentials(out IntPtr cred, IntPtr transport, string user, int methods)
        {
            return NativeMethods.git_transport_smart_credentials(out cred, transport, user, methods);
        }

#endregion

#region git_tree_

        public static unsafe Mode git_tree_entry_attributes(git_tree_entry* entry)
        {
            return (Mode)NativeMethods.git_tree_entry_filemode(entry);
        }

        public static unsafe TreeEntryHandle git_tree_entry_byindex(ObjectHandle tree, long idx)
        {
            var handle = NativeMethods.git_tree_entry_byindex(tree, (UIntPtr)idx);
            if (handle == null)
            {
                return null;
            }

            return new TreeEntryHandle(handle, false);
        }

        public static unsafe TreeEntryHandle git_tree_entry_bypath(RepositoryHandle repo, ObjectId id, string treeentry_path)
        {
            using (var obj = new ObjectSafeWrapper(id, repo, throwIfMissing: true))
            {
                git_tree_entry* treeEntryPtr;
                int res = NativeMethods.git_tree_entry_bypath(out treeEntryPtr, obj.ObjectPtr, treeentry_path);

                if (res == (int)GitErrorCode.NotFound)
                {
                    return null;
                }

                Ensure.ZeroResult(res);

                return new TreeEntryHandle(treeEntryPtr, true);
            }
        }

        public static unsafe ObjectId git_tree_entry_id(git_tree_entry* entry)
        {
            return ObjectId.BuildFromPtr(NativeMethods.git_tree_entry_id(entry));
        }

        public static unsafe string git_tree_entry_name(git_tree_entry* entry)
        {
            return NativeMethods.git_tree_entry_name(entry);
        }

        public static unsafe GitObjectType git_tree_entry_type(git_tree_entry* entry)
        {
            return NativeMethods.git_tree_entry_type(entry);
        }

        public static unsafe int git_tree_entrycount(ObjectHandle tree)
        {
            return (int)NativeMethods.git_tree_entrycount(tree);
        }

#endregion

#region git_treebuilder_

        public static unsafe TreeBuilderHandle git_treebuilder_new(RepositoryHandle repo)
        {
            git_treebuilder* builder;
            int res = NativeMethods.git_treebuilder_new(out builder, repo, IntPtr.Zero);
            Ensure.ZeroResult(res);

            return new TreeBuilderHandle(builder, true);
        }

        public static unsafe void git_treebuilder_insert(TreeBuilderHandle builder, string treeentry_name, TreeEntryDefinition treeEntryDefinition)
        {
            GitOid oid = treeEntryDefinition.TargetId.Oid;
            int res = NativeMethods.git_treebuilder_insert(IntPtr.Zero, builder, treeentry_name, ref oid,
                (uint)treeEntryDefinition.Mode);
            Ensure.ZeroResult(res);
        }

        public static unsafe ObjectId git_treebuilder_write(TreeBuilderHandle bld)
        {
            GitOid oid;
            int res = NativeMethods.git_treebuilder_write(out oid, bld);
            Ensure.ZeroResult(res);

            return oid;
        }

#endregion

#region git_transaction_

        public static void git_transaction_commit(IntPtr txn)
        {
            NativeMethods.git_transaction_commit(txn);
        }

        public static void git_transaction_free(IntPtr txn)
        {
            NativeMethods.git_transaction_free(txn);
        }

#endregion

#region git_libgit2_

        /// <summary>
        /// Returns the features with which libgit2 was compiled.
        /// </summary>
        public static BuiltInFeatures git_libgit2_features()
        {
            return (BuiltInFeatures)NativeMethods.git_libgit2_features();
        }

        // C# equivalent of libgit2's git_libgit2_opt_t
        private enum LibGit2Option
        {
            GetMWindowSize,                  // GIT_OPT_GET_MWINDOW_SIZE
            SetMWindowSize,                  // GIT_OPT_SET_MWINDOW_SIZE
            GetMWindowMappedLimit,           // GIT_OPT_GET_MWINDOW_MAPPED_LIMIT
            SetMWindowMappedLimit,           // GIT_OPT_SET_MWINDOW_MAPPED_LIMIT
            GetSearchPath,                   // GIT_OPT_GET_SEARCH_PATH
            SetSearchPath,                   // GIT_OPT_SET_SEARCH_PATH
            SetCacheObjectLimit,             // GIT_OPT_SET_CACHE_OBJECT_LIMIT
            SetCacheMaxSize,                 // GIT_OPT_SET_CACHE_MAX_SIZE
            EnableCaching,                   // GIT_OPT_ENABLE_CACHING
            GetCachedMemory,                 // GIT_OPT_GET_CACHED_MEMORY
            GetTemplatePath,                 // GIT_OPT_GET_TEMPLATE_PATH
            SetTemplatePath,                 // GIT_OPT_SET_TEMPLATE_PATH
            SetSslCertLocations,             // GIT_OPT_SET_SSL_CERT_LOCATIONS
            SetUserAgent,                    // GIT_OPT_SET_USER_AGENT
            EnableStrictObjectCreation,      // GIT_OPT_ENABLE_STRICT_OBJECT_CREATION
            EnableStrictSymbolicRefCreation, // GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION
            SetSslCiphers,                   // GIT_OPT_SET_SSL_CIPHERS
            GetUserAgent,                    // GIT_OPT_GET_USER_AGENT
            EnableOfsDelta,                  // GIT_OPT_ENABLE_OFS_DELTA
            EnableFsyncGitdir,               // GIT_OPT_ENABLE_FSYNC_GITDIR
            GetWindowsSharemode,             // GIT_OPT_GET_WINDOWS_SHAREMODE
            SetWindowsSharemode,             // GIT_OPT_SET_WINDOWS_SHAREMODE
            EnableStrictHashVerification,    // GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION
            SetAllocator,                    // GIT_OPT_SET_ALLOCATOR,
            EnableUnsavedIndexSafety,        // GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY,
            GetPackMaxObject,                // GIT_OPT_GET_PACK_MAX_OBJECTS,
            SetPackMaxObjects,               // GIT_OPT_SET_PACK_MAX_OBJECTS,
            DisabledPackKeepFileChecks,      // GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS,
            EnableHttpExpectContinue,        // GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE,
            GetMWindowFileLimit,             // GIT_OPT_GET_MWINDOW_FILE_LIMIT,
            SetMWindowFileLimit,             // GIT_OPT_SET_MWINDOW_FILE_LIMIT,
            SetOdbPackedPriority,            // GIT_OPT_SET_ODB_PACKED_PRIORITY,
            SetOdbLoosePriority,             // GIT_OPT_SET_ODB_LOOSE_PRIORITY,
            GetExtensions,                   // GIT_OPT_GET_EXTENSIONS,
            SetExtensions,                   // GIT_OPT_SET_EXTENSIONS
        }

        /// <summary>
        /// Get the paths under which libgit2 searches for the configuration file of a given level.
        /// </summary>
        /// <param name="level">The level (global/system/XDG) of the config.</param>
        /// <returns>
        ///     The paths delimited by 'GIT_PATH_LIST_SEPARATOR'.
        /// </returns>
        public static string git_libgit2_opts_get_search_path(ConfigurationLevel level)
        {
            string path;

            using (var buf = new GitBuf())
            {
#if !LIBGIT2_USE_INTERNAL_DLL
                int res;
                if (isOSXArm64)
                    res = NativeMethods.git_libgit2_opts_osxarm64((int)LibGit2Option.GetSearchPath, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, (uint)level, buf);
                else
                    res = NativeMethods.git_libgit2_opts((int)LibGit2Option.GetSearchPath, (uint)level, buf);
#else
                int res = NativeMethods.git_libgit2_opts__1((int)LibGit2Option.GetSearchPath, (uint)level, buf);
#endif
                Ensure.ZeroResult(res);

                path = LaxUtf8Marshaler.FromNative(buf.ptr) ?? string.Empty;
            }

            return path;
        }

        public static void git_libgit2_opts_enable_strict_hash_verification(bool enabled)
        {
#if !LIBGIT2_USE_INTERNAL_DLL
            if (isOSXArm64)
                NativeMethods.git_libgit2_opts_osxarm64((int)LibGit2Option.EnableStrictHashVerification, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, enabled ? 1 : 0);
            else
                NativeMethods.git_libgit2_opts((int)LibGit2Option.EnableStrictHashVerification, enabled ? 1 : 0);
#else
            NativeMethods.git_libgit2_opts__3((int)LibGit2Option.EnableStrictHashVerification, enabled ? 1 : 0);
#endif
        }

        /// <summary>
        /// Set the path(s) under which libgit2 searches for the configuration file of a given level.
        /// </summary>
        /// <param name="level">The level (global/system/XDG) of the config.</param>
        /// <param name="path">
        ///     A string of paths delimited by 'GIT_PATH_LIST_SEPARATOR'.
        ///     Pass null to reset the search path to the default.
        /// </param>
        public static void git_libgit2_opts_set_search_path(ConfigurationLevel level, string path)
        {
#if !LIBGIT2_USE_INTERNAL_DLL
            int res;
                if (isOSXArm64)
                    res = NativeMethods.git_libgit2_opts_osxarm64((int)LibGit2Option.SetSearchPath, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, (uint)level, path);
                else
                    res = NativeMethods.git_libgit2_opts((int)LibGit2Option.SetSearchPath, (uint)level, path);
#else
            int res = NativeMethods.git_libgit2_opts__2((int)LibGit2Option.SetSearchPath, (uint)level, path);
#endif
            Ensure.ZeroResult(res);
        }

        /// <summary>
        /// Enable or disable the libgit2 cache
        /// </summary>
        /// <param name="enabled">true to enable the cache, false otherwise</param>
        public static void git_libgit2_opts_set_enable_caching(bool enabled)
        {
            // libgit2 expects non-zero value for true
#if !LIBGIT2_USE_INTERNAL_DLL
            int res;
                if (isOSXArm64)
                    res = NativeMethods.git_libgit2_opts_osxarm64((int)LibGit2Option.EnableCaching, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, enabled ? 1 : 0);
                else
                    res = NativeMethods.git_libgit2_opts((int)LibGit2Option.EnableCaching, enabled ? 1 : 0);
#else
            int res = NativeMethods.git_libgit2_opts__3((int)LibGit2Option.EnableCaching, enabled ? 1 : 0);
#endif
            Ensure.ZeroResult(res);
        }

        /// <summary>
        /// Enable or disable the ofs_delta capabilty
        /// </summary>
        /// <param name="enabled">true to enable the ofs_delta capabilty, false otherwise</param>
        public static void git_libgit2_opts_set_enable_ofsdelta(bool enabled)
        {
            // libgit2 expects non-zero value for true
#if !LIBGIT2_USE_INTERNAL_DLL
            int res;
                if (isOSXArm64)
                    res = NativeMethods.git_libgit2_opts_osxarm64((int)LibGit2Option.EnableOfsDelta, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, enabled ? 1 : 0);
                else
                    res = NativeMethods.git_libgit2_opts((int)LibGit2Option.EnableOfsDelta, enabled ? 1 : 0);
#else
            int res = NativeMethods.git_libgit2_opts__3((int)LibGit2Option.EnableOfsDelta, enabled ? 1 : 0);
#endif
            Ensure.ZeroResult(res);
        }

        /// <summary>
        /// Enable or disable the strict_object_creation capabilty
        /// </summary>
        /// <param name="enabled">true to enable the strict_object_creation capabilty, false otherwise</param>
        public static void git_libgit2_opts_set_enable_strictobjectcreation(bool enabled)
        {
            // libgit2 expects non-zero value for true
#if !LIBGIT2_USE_INTERNAL_DLL
            int res;
                if (isOSXArm64)
                    res = NativeMethods.git_libgit2_opts_osxarm64((int)LibGit2Option.EnableStrictObjectCreation, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, enabled ? 1 : 0);
                else
                    res = NativeMethods.git_libgit2_opts((int)LibGit2Option.EnableStrictObjectCreation, enabled ? 1 : 0);
#else
            int res = NativeMethods.git_libgit2_opts__3((int)LibGit2Option.EnableStrictObjectCreation, enabled ? 1 : 0);
#endif
            Ensure.ZeroResult(res);
        }

        /// <summary>
        /// Sets the user-agent string to be used by the HTTP(S) transport.
        /// Note that "git/2.0" will be prepended for compatibility.
        /// </summary>
        /// <param name="userAgent">The user-agent string to use</param>
        public static void git_libgit2_opts_set_user_agent(string userAgent)
        {
#if !LIBGIT2_USE_INTERNAL_DLL
            int res;
                if (isOSXArm64)
                    res = NativeMethods.git_libgit2_opts_osxarm64((int)LibGit2Option.SetUserAgent, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, userAgent);
                else
                    res = NativeMethods.git_libgit2_opts((int)LibGit2Option.SetUserAgent, userAgent);
#else
            int res = NativeMethods.git_libgit2_opts__4((int)LibGit2Option.SetUserAgent, userAgent);
#endif
            Ensure.ZeroResult(res);
        }

        /// <summary>
        /// Gets the user-agent string used by libgit2.
        /// <returns>
        /// The user-agent string.
        /// </returns>
        /// </summary>
        public static string git_libgit2_opts_get_user_agent()
        {
            string userAgent;

            using (var buf = new GitBuf())
            {
#if !LIBGIT2_USE_INTERNAL_DLL
                int res;
                if (isOSXArm64)
                    res = NativeMethods.git_libgit2_opts_osxarm64((int)LibGit2Option.GetUserAgent, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, buf);
                else
                    res = NativeMethods.git_libgit2_opts((int)LibGit2Option.GetUserAgent, buf);
#else
                int res = NativeMethods.git_libgit2_opts__5((int)LibGit2Option.GetUserAgent, buf);
#endif
                Ensure.ZeroResult(res);

                userAgent = LaxUtf8Marshaler.FromNative(buf.ptr) ?? string.Empty;
            }

            return userAgent;
        }

        public static void git_libgit2_opts_set_extensions(string[] extensions)
        {
            using (var array = GitStrArrayManaged.BuildFrom(extensions))
            {
#if !LIBGIT2_USE_INTERNAL_DLL
                int res;
                if (isOSXArm64)
                    res = NativeMethods.git_libgit2_opts_osxarm64((int)LibGit2Option.SetExtensions, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, array.Array.Strings, array.Array.Count);
                else
                    res = NativeMethods.git_libgit2_opts((int)LibGit2Option.SetExtensions, array.Array.Strings, array.Array.Count);
#else
                int res = NativeMethods.git_libgit2_opts__6((int)LibGit2Option.SetExtensions, array.Array.Strings, array.Array.Count);
#endif
                Ensure.ZeroResult(res);
            }
        }

        public static string[] git_libgit2_opts_get_extensions()
        {
            var array = new GitStrArrayNative();

            try
            {
#if !LIBGIT2_USE_INTERNAL_DLL
                int res;
                if (isOSXArm64)
                    res = NativeMethods.git_libgit2_opts_osxarm64((int)LibGit2Option.GetExtensions, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, out array.Array);
                else
                    res = NativeMethods.git_libgit2_opts((int)LibGit2Option.GetExtensions, out array.Array);
#else
                int res = NativeMethods.git_libgit2_opts__7((int)LibGit2Option.GetExtensions, out array.Array);
#endif
                Ensure.ZeroResult(res);

                return array.ReadStrings();
            }
            finally
            {
                array.Dispose();
            }
        }

        #endregion

        #region git_worktree_

        /// <summary>
        /// Returns a handle to the corresponding worktree,
        /// or an invalid handle if a worktree is not found.
        /// </summary>
        public static unsafe WorktreeHandle git_worktree_lookup(RepositoryHandle repo, string name)
        {
            git_worktree* worktree;
            var res = NativeMethods.git_worktree_lookup(out worktree, repo, name);

            switch (res)
            {
                case (int)GitErrorCode.Error:
                case (int)GitErrorCode.NotFound:
                case (int)GitErrorCode.Exists:
                case (int)GitErrorCode.OrphanedHead:
                    return null;

                default:
                    Ensure.ZeroResult(res);
                    return new WorktreeHandle(worktree, true);
            }
        }

        public static unsafe IList<string> git_worktree_list(RepositoryHandle repo)
        {
            var array = new GitStrArrayNative();

            try
            {
                int res = NativeMethods.git_worktree_list(out array.Array, repo);
                Ensure.ZeroResult(res);

                return array.ReadStrings();
            }
            finally
            {
                array.Dispose();
            }
        }

        public static unsafe RepositoryHandle git_repository_open_from_worktree(WorktreeHandle handle)
        {
            git_repository* repo;
            int res = NativeMethods.git_repository_open_from_worktree(out repo, handle);

            if (res == (int)GitErrorCode.NotFound)
            {
                throw new RepositoryNotFoundException("Handle doesn't point at a valid Git repository or workdir.");
            }

            Ensure.ZeroResult(res);

            return new RepositoryHandle(repo, true);
        }

        public static unsafe WorktreeLock git_worktree_is_locked(WorktreeHandle worktree)
        {
            using (var buf = new GitBuf())
            {
                int res = NativeMethods.git_worktree_is_locked(buf, worktree);

                if(res < 0)
                {
                    // error
                    return null;
                }

                if (res == (int)GitErrorCode.Ok)
                {
                    return new WorktreeLock();
                }

                return new WorktreeLock(true, LaxUtf8Marshaler.FromNative(buf.ptr));
            }
        }

        public static unsafe bool git_worktree_validate(WorktreeHandle worktree)
        {
            int res = NativeMethods.git_worktree_validate(worktree);

            return res == (int)GitErrorCode.Ok;
        }

        public static unsafe bool git_worktree_unlock(WorktreeHandle worktree)
        {
            int res = NativeMethods.git_worktree_unlock(worktree);

            return res == (int)GitErrorCode.Ok;
        }

        public static unsafe bool git_worktree_lock(WorktreeHandle worktree, string reason)
        {
            int res = NativeMethods.git_worktree_lock(worktree, reason);

            return res == (int)GitErrorCode.Ok;
        }

        public static unsafe WorktreeHandle git_worktree_add(
            RepositoryHandle repo,
            string name,
            string path,
            git_worktree_add_options options)
        {
            git_worktree* worktree;
            int res = NativeMethods.git_worktree_add(out worktree, repo, name, path, options);
            Ensure.ZeroResult(res);
            return new WorktreeHandle(worktree, true);
        }

        public static unsafe bool git_worktree_prune(WorktreeHandle worktree,
            git_worktree_prune_options options)
        {
            int res = NativeMethods.git_worktree_prune(worktree, options);
            Ensure.ZeroResult(res);
            return true;
        }

        #endregion

        private static ICollection<TResult> git_foreach<T, TResult>(
            Func<T, TResult> resultSelector,
            Func<Func<T, IntPtr, int>, int> iterator,
            params GitErrorCode[] ignoredErrorCodes)
        {
            var result = new List<TResult>();
            var res = iterator((x, payload) =>
            {
                result.Add(resultSelector(x));
                return 0;
            });

            if (ignoredErrorCodes != null && ignoredErrorCodes.Contains((GitErrorCode)res))
            {
                return new TResult[0];
            }

            Ensure.ZeroResult(res);
            return result;
        }

        private static ICollection<TResult> git_foreach<T1, T2, TResult>(
            Func<T1, T2, TResult> resultSelector,
            Func<Func<T1, T2, IntPtr, int>, int> iterator,
            params GitErrorCode[] ignoredErrorCodes)
        {
            var result = new List<TResult>();
            var res = iterator((x, y, payload) =>
            {
                result.Add(resultSelector(x, y));
                return 0;
            });

            if (ignoredErrorCodes != null && ignoredErrorCodes.Contains((GitErrorCode)res))
            {
                return new TResult[0];
            }

            Ensure.ZeroResult(res);
            return result;
        }

        private static ICollection<TResult> git_foreach<T1, T2, T3, TResult>(
            Func<T1, T2, T3, TResult> resultSelector,
            Func<Func<T1, T2, T3, IntPtr, int>, int> iterator,
            params GitErrorCode[] ignoredErrorCodes)
        {
            var result = new List<TResult>();
            var res = iterator((w, x, y, payload) =>
            {
                result.Add(resultSelector(w, x, y));
                return 0;
            });

            if (ignoredErrorCodes != null && ignoredErrorCodes.Contains((GitErrorCode)res))
            {
                return new TResult[0];
            }

            Ensure.ZeroResult(res);
            return result;
        }

        public delegate TResult Func<T1, T2, T3, T4, T5, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);

        private static ICollection<TResult> git_foreach<T1, T2, T3, T4, TResult>(
            Func<T1, T2, T3, T4, TResult> resultSelector,
            Func<Func<T1, T2, T3, T4, IntPtr, int>, int> iterator,
            params GitErrorCode[] ignoredErrorCodes)
        {
            var result = new List<TResult>();
            var res = iterator((w, x, y, z, payload) =>
            {
                result.Add(resultSelector(w, x, y, z));
                return 0;
            });

            if (ignoredErrorCodes != null && ignoredErrorCodes.Contains((GitErrorCode)res))
            {
                return new TResult[0];
            }

            Ensure.ZeroResult(res);
            return result;
        }

#if !LIBGIT2_USE_INTERNAL_DLL
        private static unsafe bool RepositoryStateChecker(RepositoryHandle repo, Func<IntPtr, int> checker)
#else
        private static unsafe bool RepositoryStateChecker(RepositoryHandle repo, NativeMethods.Delegate_git_repository__GetInt checker)
#endif
        {
            int res = checker(repo.AsIntPtr());
            Ensure.BooleanResult(res);

            return (res == 1);
        }

#if !LIBGIT2_USE_INTERNAL_DLL
        private static FilePath ConvertPath(Func<GitBuf, int> pathRetriever)
#else
        private static FilePath ConvertPath(NativeMethods.Delegate_git_config_find__Any pathRetriever)
#endif
        {
            using (var buf = new GitBuf())
            {
                int result = pathRetriever(buf);

                if (result == (int)GitErrorCode.NotFound)
                {
                    return null;
                }

                Ensure.ZeroResult(result);
                return LaxFilePathMarshaler.FromNative(buf.ptr);
            }
        }

        private static readonly IDictionary<Type, Func<string, object>> configurationParser = new Dictionary<Type, Func<string, object>>
        {
            { typeof(int), value => git_config_parse_int32(value) },
            { typeof(long), value => git_config_parse_int64(value) },
            { typeof(bool), value => git_config_parse_bool(value) },
            { typeof(string), value => value },
        };

        /// <summary>
        /// Helper method for consistent conversion of return value on
        /// Callbacks that support cancellation from bool to native type.
        /// True indicates that function should continue, false indicates
        /// user wants to cancel.
        /// </summary>
        /// <param name="result"></param>
        /// <returns></returns>
        internal static int ConvertResultToCancelFlag(bool result)
        {
            return result ? 0 : (int)GitErrorCode.User;
        }
    }

    /// <summary>
    /// Class to hold extension methods used by the proxy class.
    /// </summary>
    static class ProxyExtensions
    {
        /// <summary>
        /// Convert a UIntPtr to a int value. Will throw
        /// exception if there is an overflow.
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public static int ConvertToInt(this UIntPtr input)
        {
            ulong ulongValue = (ulong)input;
            if (ulongValue > int.MaxValue)
            {
                throw new LibGit2SharpException("value exceeds size of an int");
            }

            return (int)input;
        }

        /// <summary>
        /// Convert a UIntPtr to a long value. Will throw
        /// exception if there is an overflow.
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public static long ConvertToLong(this UIntPtr input)
        {
            ulong ulongValue = (ulong)input;
            if (ulongValue > long.MaxValue)
            {
                throw new LibGit2SharpException("value exceeds size of long");
            }

            return (long)input;
        }
    }

    internal class PushTransferCallbacks
    {
        private readonly PushTransferProgressHandler onPushTransferProgress;

        /// <summary>
        /// Constructor to set up the native callback given managed delegate.
        /// </summary>
        /// <param name="onPushTransferProgress">The <see cref="TransferProgressHandler"/> delegate that the git_transfer_progress_callback will call.</param>
        internal PushTransferCallbacks(PushTransferProgressHandler onPushTransferProgress)
        {
            this.onPushTransferProgress = onPushTransferProgress;
        }

        /// <summary>
        /// Generates a delegate that matches the native git_transfer_progress_callback function's signature and wraps the <see cref="PushTransferProgressHandler"/> delegate.
        /// </summary>
        /// <returns>A delegate method with a signature that matches git_transfer_progress_callback.</returns>
        internal NativeMethods.git_push_transfer_progress GenerateCallback()
        {
            if (onPushTransferProgress == null)
            {
                return null;
            }

            return new PushTransferCallbacks(onPushTransferProgress).OnGitTransferProgress;
        }

        private int OnGitTransferProgress(uint current, uint total, UIntPtr bytes, IntPtr payload)
        {
            return Proxy.ConvertResultToCancelFlag(onPushTransferProgress((int)current, (int)total, (long)bytes));
        }
    }

    internal class RawContentStream : UnmanagedMemoryStream
    {
        private readonly ObjectHandle handle;
        private readonly ICollection<IDisposable> linkedResources;

        internal unsafe RawContentStream(
            ObjectHandle handle,
            Func<ObjectHandle, IntPtr> bytePtrProvider,
            Func<ObjectHandle, long> sizeProvider,
            ICollection<IDisposable> linkedResources = null)
            : base((byte*)Wrap(handle, bytePtrProvider, linkedResources).ToPointer(),
            Wrap(handle, sizeProvider, linkedResources))
        {
            this.handle = handle;
            this.linkedResources = linkedResources;
        }

        private static T Wrap<T>(
            ObjectHandle handle,
            Func<ObjectHandle, T> provider,
            IEnumerable<IDisposable> linkedResources)
        {
            T value;

            try
            {
                value = provider(handle);
            }
            catch
            {
                Dispose(handle, linkedResources);
                throw;
            }

            return value;
        }

        private static void Dispose(
            ObjectHandle handle,
            IEnumerable<IDisposable> linkedResources)
        {
            handle.SafeDispose();

            if (linkedResources == null)
            {
                return;
            }

            foreach (IDisposable linkedResource in linkedResources)
            {
                linkedResource.Dispose();
            }
        }

        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            Dispose(handle, linkedResources);
        }
    }

    /// <summary>
    /// Option flags for `git_repository_open_ext`
    /// </summary>
    [Flags]
    internal enum RepositoryOpenFlags
    {
        /// <summary>
        /// Only open the repository if it can be
        ///  *   immediately found in the start_path.  Do not walk up from the
        ///  *   start_path looking at parent directories.
        /// </summary>
        NoSearch = (1 << 0), /* GIT_REPOSITORY_OPEN_NO_SEARCH */

        /// <summary>
        /// Unless this flag is set, open will not
        ///  *   continue searching across filesystem boundaries (i.e. when `st_dev`
        ///  *   changes from the `stat` system call).  (E.g. Searching in a user's home
        ///  *   directory "/home/user/source/" will not return "/.git/" as the found
        ///  *   repo if "/" is a different filesystem than "/home".)
        /// </summary>
        CrossFS = (1 << 1), /* GIT_REPOSITORY_OPEN_CROSS_FS */
    }

    internal static class StringExtensions
    {
        public static int OctalToInt32(this string octal)
        {
            return Convert.ToInt32(octal, 8);
        }
    }

    internal class SubmoduleLazyGroup : LazyGroup<SubmoduleHandle>
    {
        private readonly string name;

        public SubmoduleLazyGroup(Repository repo, string name)
            : base(repo)
        {
            this.name = name;
        }

        protected override void EvaluateInternal(Action<SubmoduleHandle> evaluator)
        {
            repo.Submodules.Lookup(name,
                                   handle =>
                                   {
                                       evaluator(handle);
                                       return default(object);
                                   },
                                   true);
        }
    }

    /// <summary>
    /// This marshaler is to be used for capturing a UTF-8 string owned by libgit2 and
    /// converting it to a managed String instance. The marshaler will not attempt to
    /// free the native pointer after conversion, because the memory is owned by libgit2.
    ///
    /// Use this marshaler for return values, for example:
    /// [return: MarshalAs(UnmanagedType.CustomMarshaler,
    ///                    MarshalCookie = "git2",
    ///                    MarshalTypeRef = typeof(LaxUtf8NoCleanupMarshaler))]
    /// </summary>
    internal class LaxUtf8NoCleanupMarshaler : LaxUtf8Marshaler
    {
        private static readonly LaxUtf8NoCleanupMarshaler staticInstance = new LaxUtf8NoCleanupMarshaler();

        public new static ICustomMarshaler GetInstance(string cookie)
        {
            return staticInstance;
        }

        #region ICustomMarshaler

        public override void CleanUpNativeData(IntPtr pNativeData)
        { }

        #endregion
    }

    /// <summary>
    /// This marshaler is to be used for sending managed String instances to libgit2.
    /// The marshaler will allocate a buffer in native memory to hold the UTF-8 string
    /// and perform the encoding conversion using that buffer as the target. The pointer
    /// received by libgit2 will be to this buffer. After the function call completes, the
    /// native buffer is freed.
    ///
    /// Use this marshaler for function parameters, for example:
    /// [DllImport(libgit2)]
    /// internal static extern int git_tag_delete(RepositorySafeHandle repo,
    ///     [MarshalAs(UnmanagedType.CustomMarshaler
    ///                MarshalCookie = "git2",
    ///                MarshalTypeRef = typeof(StrictUtf8Marshaler))] String tagName);
    /// </summary>
    internal class StrictUtf8Marshaler : EncodingMarshaler
    {
        private static readonly StrictUtf8Marshaler staticInstance;
        private static readonly Encoding encoding;

        static StrictUtf8Marshaler()
        {
            encoding = new UTF8Encoding(false, true);
            staticInstance = new StrictUtf8Marshaler();
        }

        public StrictUtf8Marshaler() : base(encoding)
        { }

        public static ICustomMarshaler GetInstance(string cookie)
        {
            return staticInstance;
        }

        #region ICustomMarshaler

        public override Object MarshalNativeToManaged(IntPtr pNativeData)
        {
            throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture,
                                                              "{0} cannot be used to retrieve data from libgit2.",
                                                              GetType().Name));
        }

        #endregion

        public static IntPtr FromManaged(String value)
        {
            return FromManaged(encoding, value);
        }
    }

    /// <summary>
    /// This marshaler is to be used for capturing a UTF-8 string allocated by libgit2 and
    /// converting it to a managed String instance. The marshaler will free the native pointer
    /// after conversion.
    /// </summary>
    internal class LaxUtf8Marshaler : EncodingMarshaler
    {
        private static readonly LaxUtf8Marshaler staticInstance = new LaxUtf8Marshaler();

        public static readonly Encoding Encoding = new UTF8Encoding(false, false);

        public LaxUtf8Marshaler() : base(Encoding)
        { }

        public static ICustomMarshaler GetInstance(string cookie)
        {
            return staticInstance;
        }

        #region ICustomMarshaler

        public override IntPtr MarshalManagedToNative(object managedObj)
        {
            throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture,
                                                              "{0} cannot be used to pass data to libgit2.",
                                                              GetType().Name));
        }

        #endregion

        public static unsafe string FromNative(char* pNativeData)
        {
            return FromNative(Encoding, (byte*)pNativeData);
        }

        public static string FromNative(IntPtr pNativeData)
        {
            return FromNative(Encoding, pNativeData);
        }

        public static string FromNative(IntPtr pNativeData, int length)
        {
            return FromNative(Encoding, pNativeData, length);
        }

        public static string FromBuffer(byte[] buffer)
        {
            return FromBuffer(Encoding, buffer);
        }

        public static string FromBuffer(byte[] buffer, int length)
        {
            return FromBuffer(Encoding, buffer, length);
        }
    }

    class WriteStream : Stream
    {
        readonly GitWriteStream nextStream;
        readonly IntPtr nextPtr;

        public WriteStream(GitWriteStream nextStream, IntPtr nextPtr)
        {
            this.nextStream = nextStream;
            this.nextPtr = nextPtr;
        }

        public override bool CanWrite { get { return true; } }

        public override bool CanRead { get { return false; } }

        public override bool CanSeek { get { return false; } }

        public override long Position
        {
            get { throw new NotImplementedException(); }
            set { throw new InvalidOperationException(); }
        }

        public override long Length { get { throw new InvalidOperationException(); } }

        public override void Flush()
        { }

        public override void SetLength(long value)
        {
            throw new InvalidOperationException();
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            throw new InvalidOperationException();
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new InvalidOperationException();
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            int res;
            unsafe
            {
                fixed (byte* bufferPtr = &buffer[offset])
                {
                    res = nextStream.write(nextPtr, (IntPtr)bufferPtr, (UIntPtr)count);
                }
            }

            Ensure.Int32Result(res);
        }
    }


    // This activates a lightweight mode which will help put under the light
    // incorrectly released handles by outputing a warning message in the console.
    //
    // This should be activated when tests are being run on the CI server.
    //
    // Uncomment the line below or add a conditional symbol to activate this mode

    // #define LEAKS_IDENTIFYING

    // This activates a more throrough mode which will show the stack trace of the
    // allocation code path for each handle that has been improperly released.
    //
    // This should be manually activated when some warnings have been raised as
    // a result of LEAKS_IDENTIFYING mode activation.
    //
    // Uncomment the line below or add a conditional symbol to activate this mode

    // #define LEAKS_TRACKING

    #if LEAKS_IDENTIFYING
    /// <summary>
    /// Holds leaked handle type names reported by <see cref="Core.Handles.Libgit2Object"/>
    /// </summary>
    public static class LeaksContainer
    {
        private static readonly HashSet<string> _typeNames = new HashSet<string>();
        private static readonly object _lockpad = new object();

        /// <summary>
        /// Report a new leaked handle type name
        /// </summary>
        /// <param name="typeName">Short name of the leaked handle type.</param>
        public static void Add(string typeName)
        {
            lock (_lockpad)
            {
                _typeNames.Add(typeName);
            }
        }

        /// <summary>
        /// Removes all previously reported leaks.
        /// </summary>
        public static void Clear()
        {
            lock (_lockpad)
            {
                _typeNames.Clear();
            }
        }

        /// <summary>
        /// Returns all reported leaked handle type names.
        /// </summary>
        public static IEnumerable<string> TypeNames
        {
            get
            {
                string[] result = null;
                lock (_lockpad)
                {
                    result = _typeNames.ToArray();
                }
                return result;
            }
        }
    }
    #endif
}

namespace LibGit2Sharp.Core.Handles
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Globalization;
    using System.Linq;
    using System.Runtime.InteropServices;
    using System;

    [StructLayout(LayoutKind.Sequential)]
    internal class GitBuf : IDisposable
    {
        public IntPtr ptr;
        public UIntPtr asize;
        public UIntPtr size;

        public void Dispose()
        {
            Proxy.git_buf_dispose(this);
        }
    }

    internal static class DisposableExtensions
    {
        public static void SafeDispose(this IDisposable disposable)
        {
            if (disposable == null)
            {
                return;
            }

            disposable.Dispose();
        }
    }

    internal unsafe abstract class Libgit2Object : IDisposable
    {
#if LEAKS_TRACKING
        private readonly string trace;
        private readonly Guid id;
#endif

        protected void* ptr;

        internal void* Handle
        {
            get
            {
                return ptr;
            }
        }

        bool owned;
        bool disposed;

        internal unsafe Libgit2Object(void* handle, bool owned)
        {
            this.ptr = handle;
            this.owned = owned;

#if LEAKS_TRACKING
            id = Guid.NewGuid();
            Trace.WriteLine(string.Format(CultureInfo.InvariantCulture, "Allocating {0} handle ({1})", GetType().Name, id));

            trace = new StackTrace(2, true).ToString();
#endif
        }

        internal unsafe Libgit2Object(IntPtr ptr, bool owned)
            : this(ptr.ToPointer(), owned)
        {
        }

        ~Libgit2Object()
        {
            Dispose(false);
        }

        internal bool IsNull
        {
            get
            {
                return ptr == null;
            }
        }

        internal IntPtr AsIntPtr()
        {
            return new IntPtr(ptr);
        }

        public abstract void Free();

        void Dispose(bool disposing)
        {
#if LEAKS_IDENTIFYING
            bool leaked = !disposing && ptr != null;

            if (leaked)
            {
                LeaksContainer.Add(GetType().Name);
            }
#endif

            if (!disposed)
            {
                if (owned)
                {
                    Free();
                }

                ptr = null;
            }

            disposed = true;

#if LEAKS_TRACKING
            if (!leaked)
            {
                Trace.WriteLine(string.Format(CultureInfo.InvariantCulture, "Disposing {0} handle ({1})", GetType().Name, id));
            }
            else
            {
                Trace.WriteLine(string.Format(CultureInfo.InvariantCulture, "Unexpected finalization of {0} handle ({1})", GetType().Name, id));
                Trace.WriteLine(trace);
                Trace.WriteLine("");
            }
#endif
        }

            public void Dispose()
        {
            Dispose(true);
        }
    }

    internal unsafe class TreeEntryHandle : Libgit2Object
    {
        internal TreeEntryHandle(git_tree_entry *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal TreeEntryHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_tree_entry_free((git_tree_entry*) ptr);
        }

        public static implicit operator git_tree_entry*(TreeEntryHandle handle)
        {
            return (git_tree_entry*) handle.Handle;
        }
    }

    internal unsafe class ReferenceHandle : Libgit2Object
    {
        internal ReferenceHandle(git_reference *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal ReferenceHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_reference_free((git_reference*) ptr);
        }

        public static implicit operator git_reference*(ReferenceHandle handle)
        {
            return (git_reference*) handle.Handle;
        }
    }

    internal unsafe class RepositoryHandle : Libgit2Object
    {
        internal RepositoryHandle(git_repository *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal RepositoryHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_repository_free((git_repository*) ptr);
        }

        public static implicit operator git_repository*(RepositoryHandle handle)
        {
            return (git_repository*) handle.Handle;
        }
    }

    internal unsafe class SignatureHandle : Libgit2Object
    {
        internal SignatureHandle(git_signature *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal SignatureHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_signature_free((git_signature*) ptr);
        }

        public static implicit operator git_signature*(SignatureHandle handle)
        {
            return (git_signature*) handle.Handle;
        }
    }

    internal unsafe class StatusListHandle : Libgit2Object
    {
        internal StatusListHandle(git_status_list *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal StatusListHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_status_list_free((git_status_list*) ptr);
        }

        public static implicit operator git_status_list*(StatusListHandle handle)
        {
            return (git_status_list*) handle.Handle;
        }
    }

    internal unsafe class BlameHandle : Libgit2Object
    {
        internal BlameHandle(git_blame *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal BlameHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_blame_free((git_blame*) ptr);
        }

        public static implicit operator git_blame*(BlameHandle handle)
        {
            return (git_blame*) handle.Handle;
        }
    }

    internal unsafe class DiffHandle : Libgit2Object
    {
        internal DiffHandle(git_diff *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal DiffHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_diff_free((git_diff*) ptr);
        }

        public static implicit operator git_diff*(DiffHandle handle)
        {
            return (git_diff*) handle.Handle;
        }
    }

    internal unsafe class PatchHandle : Libgit2Object
    {
        internal PatchHandle(git_patch *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal PatchHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_patch_free((git_patch*) ptr);
        }

        public static implicit operator git_patch*(PatchHandle handle)
        {
            return (git_patch*) handle.Handle;
        }
    }

    internal unsafe class ConfigurationHandle : Libgit2Object
    {
        internal ConfigurationHandle(git_config *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal ConfigurationHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_config_free((git_config*) ptr);
        }

        public static implicit operator git_config*(ConfigurationHandle handle)
        {
            return (git_config*) handle.Handle;
        }
    }

    internal unsafe class ConflictIteratorHandle : Libgit2Object
    {
        internal ConflictIteratorHandle(git_index_conflict_iterator *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal ConflictIteratorHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_index_conflict_iterator_free((git_index_conflict_iterator*) ptr);
        }

        public static implicit operator git_index_conflict_iterator*(ConflictIteratorHandle handle)
        {
            return (git_index_conflict_iterator*) handle.Handle;
        }
    }

    internal unsafe class IndexHandle : Libgit2Object
    {
        internal IndexHandle(git_index *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal IndexHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_index_free((git_index*) ptr);
        }

        public static implicit operator git_index*(IndexHandle handle)
        {
            return (git_index*) handle.Handle;
        }
    }

    internal unsafe class ReflogHandle : Libgit2Object
    {
        internal ReflogHandle(git_reflog *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal ReflogHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_reflog_free((git_reflog*) ptr);
        }

        public static implicit operator git_reflog*(ReflogHandle handle)
        {
            return (git_reflog*) handle.Handle;
        }
    }

    internal unsafe class TreeBuilderHandle : Libgit2Object
    {
        internal TreeBuilderHandle(git_treebuilder *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal TreeBuilderHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_treebuilder_free((git_treebuilder*) ptr);
        }

        public static implicit operator git_treebuilder*(TreeBuilderHandle handle)
        {
            return (git_treebuilder*) handle.Handle;
        }
    }

    internal unsafe class PackBuilderHandle : Libgit2Object
    {
        internal PackBuilderHandle(git_packbuilder *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal PackBuilderHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_packbuilder_free((git_packbuilder*) ptr);
        }

        public static implicit operator git_packbuilder*(PackBuilderHandle handle)
        {
            return (git_packbuilder*) handle.Handle;
        }
    }

    internal unsafe class NoteHandle : Libgit2Object
    {
        internal NoteHandle(git_note *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal NoteHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_note_free((git_note*) ptr);
        }

        public static implicit operator git_note*(NoteHandle handle)
        {
            return (git_note*) handle.Handle;
        }
    }

    internal unsafe class DescribeResultHandle : Libgit2Object
    {
        internal DescribeResultHandle(git_describe_result *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal DescribeResultHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_describe_result_free((git_describe_result*) ptr);
        }

        public static implicit operator git_describe_result*(DescribeResultHandle handle)
        {
            return (git_describe_result*) handle.Handle;
        }
    }

    internal unsafe class SubmoduleHandle : Libgit2Object
    {
        internal SubmoduleHandle(git_submodule *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal SubmoduleHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_submodule_free((git_submodule*) ptr);
        }

        public static implicit operator git_submodule*(SubmoduleHandle handle)
        {
            return (git_submodule*) handle.Handle;
        }
    }

    internal unsafe class AnnotatedCommitHandle : Libgit2Object
    {
        internal AnnotatedCommitHandle(git_annotated_commit *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal AnnotatedCommitHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_annotated_commit_free((git_annotated_commit*) ptr);
        }

        public static implicit operator git_annotated_commit*(AnnotatedCommitHandle handle)
        {
            return (git_annotated_commit*) handle.Handle;
        }
    }

    internal unsafe class ObjectDatabaseHandle : Libgit2Object
    {
        internal ObjectDatabaseHandle(git_odb *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal ObjectDatabaseHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_odb_free((git_odb*) ptr);
        }

        public static implicit operator git_odb*(ObjectDatabaseHandle handle)
        {
            return (git_odb*) handle.Handle;
        }
    }

    internal unsafe class RevWalkerHandle : Libgit2Object
    {
        internal RevWalkerHandle(git_revwalk *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal RevWalkerHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_revwalk_free((git_revwalk*) ptr);
        }

        public static implicit operator git_revwalk*(RevWalkerHandle handle)
        {
            return (git_revwalk*) handle.Handle;
        }
    }

    internal unsafe class RemoteHandle : Libgit2Object
    {
        internal RemoteHandle(git_remote *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal RemoteHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_remote_free((git_remote*) ptr);
        }

        public static implicit operator git_remote*(RemoteHandle handle)
        {
            return (git_remote*) handle.Handle;
        }
    }

    internal unsafe class ObjectHandle : Libgit2Object
    {
        internal ObjectHandle(git_object *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal ObjectHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_object_free((git_object*) ptr);
        }

        public static implicit operator git_object*(ObjectHandle handle)
        {
            return (git_object*) handle.Handle;
        }
    }

    internal unsafe class RebaseHandle : Libgit2Object
    {
        internal RebaseHandle(git_rebase *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal RebaseHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_rebase_free((git_rebase*) ptr);
        }

        public static implicit operator git_rebase*(RebaseHandle handle)
        {
            return (git_rebase*) handle.Handle;
        }
    }

    internal unsafe class OdbStreamHandle : Libgit2Object
    {
        internal OdbStreamHandle(git_odb_stream *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal OdbStreamHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_odb_stream_free((git_odb_stream*) ptr);
        }

        public static implicit operator git_odb_stream*(OdbStreamHandle handle)
        {
            return (git_odb_stream*) handle.Handle;
        }
    }

    internal unsafe class WorktreeHandle : Libgit2Object
    {
        internal WorktreeHandle(git_worktree *ptr, bool owned)
            : base((void *) ptr, owned)
        {
        }

        internal WorktreeHandle(IntPtr ptr, bool owned)
            : base(ptr, owned)
        {
        }

        public override void Free()
        {
            NativeMethods.git_worktree_free((git_worktree*) ptr);
        }

        public static implicit operator git_worktree*(WorktreeHandle handle)
        {
            return (git_worktree*) handle.Handle;
        }
    }

}

namespace LibGit2Sharp.Handlers
{
    using System.Collections.Generic;
    using System.Security.Cryptography.X509Certificates;

    /// <summary>
    /// Delegate definition to handle Progress callback.
    /// Returns the text as reported by the server. The text
    /// in the serverProgressOutput parameter is not delivered
    /// in any particular units (i.e. not necessarily delivered
    /// as whole lines) and is likely to be chunked as partial lines.
    /// </summary>
    /// <param name="serverProgressOutput">text reported by the server.
    /// Text can be chunked at arbitrary increments (i.e. can be composed
    /// of a partial line of text).</param>
    /// <returns>True to continue, false to cancel.</returns>
    public delegate bool ProgressHandler(string serverProgressOutput);

    /// <summary>
    /// Delegate definition to handle UpdateTips callback.
    /// </summary>
    /// <param name="referenceName">Name of the updated reference.</param>
    /// <param name="oldId">Old ID of the reference.</param>
    /// <param name="newId">New ID of the reference.</param>
    /// <returns>True to continue, false to cancel.</returns>
    public delegate bool UpdateTipsHandler(string referenceName, ObjectId oldId, ObjectId newId);

    /// <summary>
    /// Delegate definition for the credentials retrieval callback
    /// </summary>
    /// <param name="url">The url</param>
    /// <param name="usernameFromUrl">Username which was extracted from the url, if any</param>
    /// <param name="types">Credential types which the server accepts</param>
    public delegate Credentials CredentialsHandler(string url, string usernameFromUrl, SupportedCredentialTypes types);

    /// <summary>
    /// Delegate definition for the certificate validation
    /// </summary>
    /// <param name="certificate">The certificate which the server sent</param>
    /// <param name="host">The hostname which we tried to connect to</param>
    /// <param name="valid">Whether libgit2 thinks this certificate is valid</param>
    /// <returns>True to continue, false to cancel</returns>
    public delegate bool CertificateCheckHandler(Certificate certificate, bool valid, string host);

    /// <summary>
    /// Delegate definition for transfer progress callback.
    /// </summary>
    /// <param name="progress">The <see cref="TransferProgress"/> object containing progress information.</param>
    /// <returns>True to continue, false to cancel.</returns>
    public delegate bool TransferProgressHandler(TransferProgress progress);

    /// <summary>
    /// Delegate definition to indicate that a repository is about to be operated on.
    /// (In the context of a recursive operation).
    /// </summary>
    /// <param name="context">Context on the repository that is being operated on.</param>
    /// <returns>true to continue, false to cancel.</returns>
    public delegate bool RepositoryOperationStarting(RepositoryOperationContext context);

    /// <summary>
    /// Delegate definition to indicate that an operation is done in a repository.
    /// (In the context of a recursive operation).
    /// </summary>
    /// <param name="context">Context on the repository that is being operated on.</param>
    public delegate void RepositoryOperationCompleted(RepositoryOperationContext context);

    /// <summary>
    /// Delegate definition for callback reporting push network progress.
    /// </summary>
    /// <param name="current">The current number of objects sent to server.</param>
    /// <param name="total">The total number of objects to send to the server.</param>
    /// <param name="bytes">The number of bytes sent to the server.</param>
    /// <returns>True to continue, false to cancel.</returns>
    public delegate bool PushTransferProgressHandler(int current, int total, long bytes);

    /// <summary>
    /// Delegate definition for callback reporting pack builder progress.
    /// </summary>
    /// <param name="stage">The current stage progress is being reported for.</param>
    /// <param name="current">The current number of objects processed in this this stage.</param>
    /// <param name="total">The total number of objects to process for the current stage.</param>
    /// <returns>True to continue, false to cancel.</returns>
    public delegate bool PackBuilderProgressHandler(PackBuilderStage stage, int current, int total);

    /// <summary>
    /// Provides information about what updates will be performed before a push occurs
    /// </summary>
    /// <param name="updates">List of updates about to be performed via push</param>
    /// <returns>True to continue, false to cancel.</returns>
    public delegate bool PrePushHandler(IEnumerable<PushUpdate> updates);

    /// <summary>
    /// Delegate definition to handle reporting errors when updating references on the remote.
    /// </summary>
    /// <param name="pushStatusErrors">The reference name and error from the server.</param>
    public delegate void PushStatusErrorHandler(PushStatusError pushStatusErrors);

    /// <summary>
    /// Delegate definition for checkout progress callback.
    /// </summary>
    /// <param name="path">Path of the updated file.</param>
    /// <param name="completedSteps">Number of completed steps.</param>
    /// <param name="totalSteps">Total number of steps.</param>
    public delegate void CheckoutProgressHandler(string path, int completedSteps, int totalSteps);

    /// <summary>
    /// Delegate definition for checkout notification callback.
    /// </summary>
    /// <param name="path">The path the callback corresponds to.</param>
    /// <param name="notifyFlags">The checkout notification type.</param>
    /// <returns>True to continue checkout operation; false to cancel checkout operation.</returns>
    public delegate bool CheckoutNotifyHandler(string path, CheckoutNotifyFlags notifyFlags);

    /// <summary>
    /// Delegate definition for unmatched path callback.
    /// <para>
    ///   This callback will be called to notify the caller of unmatched path.
    /// </para>
    /// </summary>
    /// <param name="unmatchedPath">The unmatched path.</param>
    public delegate void UnmatchedPathHandler(string unmatchedPath);

    /// <summary>
    /// Delegate definition for remote rename failure callback.
    /// <para>
    ///   This callback will be called to notify the caller of fetch refspecs
    ///   that haven't been automatically updated and need potential manual tweaking.
    /// </para>
    /// </summary>
    /// <param name="problematicRefspec">The refspec which didn't match the default.</param>
    public delegate void RemoteRenameFailureHandler(string problematicRefspec);

    /// <summary>
    /// Delegate definition for stash application callback.
    /// </summary>
    /// <param name="progress">The current step of the stash application.</param>
    /// <returns>True to continue checkout operation; false to cancel checkout operation.</returns>
    public delegate bool StashApplyProgressHandler(StashApplyProgress progress);

    /// <summary>
    /// Delegate to report information on a rebase step that is about to be performed.
    /// </summary>
    /// <param name="beforeRebaseStep"></param>
    public delegate void RebaseStepStartingHandler(BeforeRebaseStepInfo beforeRebaseStep);

    /// <summary>
    /// Delegate to report information on the rebase step that was just completed.
    /// </summary>
    /// <param name="afterRebaseStepInfo"></param>
    public delegate void RebaseStepCompletedHandler(AfterRebaseStepInfo afterRebaseStepInfo);

    /// <summary>
    /// The stages of pack building.
    /// </summary>
    public enum PackBuilderStage
    {
        /// <summary>
        /// Counting stage.
        /// </summary>
        Counting,

        /// <summary>
        /// Deltafying stage.
        /// </summary>
        Deltafying
    }

    /// <summary>
    /// Delegate definition for logging.  This callback will be used to
    /// write logging messages in libgit2 and LibGit2Sharp.
    /// </summary>
    /// <param name="level">The level of the log message.</param>
    /// <param name="message">The log message.</param>
    public delegate void LogHandler(LogLevel level, string message);

}
